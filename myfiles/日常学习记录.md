# 1 2019最新-JVM-尚硅谷周阳

##  1.JVM

### 1.1 方法区

​	供各线程共享的运行时内存区域，它存储了每一个类的结构信息，例如运行时常量池(Runtime Constant Poll)、字段和方法数据、构造函数和普通方法的字节码内容。上面讲的是规范，在不同虚拟机里头实现是不一样的，最典型的就是永久代(PermGen space)和元空间(Metaspace)。

​	实例变量存在堆内存中，和方法区无关。

### 1.2 栈

​	栈管运行，堆管存储。

​	栈也叫栈内存，主管Java程序的运行，是在线程创建时创建，它的生命周期是跟随线程的生命期，线程结束栈内存也就释放，对于栈来说不存在垃圾回收问题，只要线程一结束该站就Over，生命周期和线程一直，是线程私有的，8种基本类型的变量+对象的引用变量+实例方法都是在函数的栈内存汇总分配。

#### 1.2.1 栈存储什么 

​	Java 方法 = 栈帧

​	栈帧种主要保存3类数据：

+ 本地变量(Local Variables)：输入参数和输出参数以及方法内的变量；
+ 栈操作(Operand Stack)：记录出栈、入栈的操作；
+ 栈针数据(Frame Data)：包括类文件、方法等等；

#### 1.2.2 栈运行原理

​	栈中的数据都是以栈帧(Stack Frame)的格式存在，栈帧是一个内存区块，是一个数据集，是一个有关方法和运行期数据的数据集。遵循"先进后出"和"后进先出"原则。

​	每个方法执行的同时都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息，每一个方法从调用直至执行完毕的过程，就对应着一个栈帧在虚拟机中入栈到出栈的过程。栈的大小和具体JVM的实现有关，通常在256K-756K之间约等于1M左右。

​	HotSpot是使用指针的方式来访问对象：Java堆中会存放访问类元数据的地址，reference存储的就直接是对象的地址。

### 1.3 堆结构

![alt images](./images/微信截图_20200614101506.png)

![alt iamges](./images/微信截图_20200614101813.png)

![alt images](./images/微信截图_20200614103831.png)

### 1.4 永久代

![alt images](./images/微信截图_20200614105140.png)

永久区(java7之前有)：

​	永久存储区是一个常驻内存区域，用于存放JDK自身所携带的Class、Interface的元素局，也就是说它存储的是运行环境必须的类信息，被装载进此区域的数据是不会被垃圾回收器回收掉的，关闭JVM才会释放此区域所占用的内存。

### 1.5 堆参数调整

![alt images](./images/微信截图_20200614110100.png)

![alt images](./images/微信截图_20200614110409.png)

​	在Java8中，永久代已经被移除，被一个称为元空间的区域所取代，元空间的本质和永久代类似。

​	元空间与永久代之间最大的区别在于：永久代使用的JVM的堆内存，但是Java8以后的元空间并不在虚拟机中而是使用本机物理内存。

​	因此，默认情况下，元空间的大小仅受本地内存限制。类的元数据放入native memory，字符串池和类的静态变量放入java堆中，这样可以加载多少类的元数据就不再由MaxPermSize控制，而由系统的实际可用空间来控制。

![alt images](./images/微信截图_20200614111417.png)

#### 1.5.1 GC收集日志信息

Minor GC：

![alt images](./images/微信截图_20200614220710.png)

Major GC(FullGC)：

![alt images](./images/微信截图_20200614221357.png)

### 1.6  GC算法

####  1.6.1 GC是什么(分代收集算法)

+ 次数上频繁收集Young区
+ 次数上较少收集Old区
+ 基本不动元空间

#### 1.6.2 GC 4大算法

GC算法总体概述

![alt images](./images/微信截图_20200614233141.png)

​	JVM在进行GC时，并非每次都对上面三个内存区域一起回收，大部分时候回收的都是指新生代。因此GC按照回收的区域又分为两种类型，一种是普通GC(minor GC)，一种是全局GC(major GC或Full GC)。

​	Minor GC和Full GC的区别：

​	普通GC(minor GC)：只针对新生代区域的GC，指发生在新生代的垃圾收集动作，因此大多数Java对象存活率都不高，所以Minor GC非常频繁，一般回收速度也比较块。

​	全局GC(major GC或Full GC)：指发生在老年代的垃圾收集动作，出现了Major GC，经常会伴随至少一次的Minor GC(但并不是绝对的)。Major GC的速度一般要比Minor GC慢上10倍以上。

##### 1.6.2.1 引用计数法

缺点：

+ 每次对象赋值时均要维护引用计数器，且计数器本身也有一定的消耗；
+ 较难处理循环引用；

##### 1.6.2.2 复制算法(Copying)

![alt images](./images/微信截图_20200615153601.png)

复制算法的缺点也是相当明显的：

+ 浪费了一般的内存，这太要命了；
+ 如果对象的存活率很高，我们可以极端一点，假设是100%存活，那么我们需要将所有对象都复制一遍，并将所有引用地址重置一遍。复制这一工作所花费的时间，在对象存活率达到一定程度时，将会变的不可忽视。所有从以上描述不难看出，复制算法要想使用，最起码对象的存活率要非常低才行，而且最重要的是，我们必须要克服50%内存的浪费；

##### 1.6.2.3 标记清除(Mark-Sweep)

​	用通俗的话解释一下标记清除算法，就是当程序运行期间，若可以使用的内存被耗尽的时候，GC线程就会被触发并将程序暂停，随后将要回收的对象标记一遍，最终统一回收这些对象，完成标记清除工作接下来便让程序恢复运行。

主要进行两项工作，标记和清除；

+ 标记：从引用根节点开始标记遍历所有的GC Roots，先标记出要回收的对象；
+ 清除：遍历整个堆，把标记的对象清除；

缺点：此算法需要暂停这个应用，会产生内存碎片。

老年代一般是由标记清除或者是标记整理的混合实现。

![alt images](./images/微信截图_20200615155640.png)

![alt images](./images/微信截图_20200615155843.png)

劣势：

+ 首先，它的缺点就是效率比较低(递归与全堆对象遍历)，而且进行GC的时候，需要停止应用程序，这会导致用户体验比较差；
+ 其次，主要的缺点则是这种方式清理出来的空闲内存是不连续的，这点不难理解，我们的死亡对象都是随机的出现在内存的各个角落的，现在把它们清除之后，内存的布局自然会乱七八糟，而为了应付这一点，JVM就不得不维持一个内存的空闲列表，这又是一种开销。而且在分配数组对象的时候，寻找连续的内存空间会不太好找；

1.6.2.4 标记压缩(Mark-Compact)

![alt images](./images/微信截图_20200615162540.png)

#### 1.6.3 总结

![alt images](./images/微信截图_20200615162943.png)

![alt images](./images/微信截图_20200615163215.png)

![alt images](./images/微信截图_20200615163321.png)

#### 1.6.4 JMM(Java内存模型)

![alt images](./images/微信截图_20200615165823.png)

![alt images](./images/微信截图_20200615165929.png)

# 2 JVM-java虚拟机-从入门到精通-尚硅谷(20200625-20200714)

## 2.1  内存与垃圾回收

### 2.1.1  JVM与Java体系结构

![alt iamges](./images/微信截图_20200616154603.png)

![alt images](./images/微信截图_20200616154818.png)

![alt images](./images/微信截图_20200616163845.png)

![alt images](./images/微信截图_20200616164101.png)

![alt images](./images/微信截图_20200616165837.png)

![alt images](./images/微信截图_20200616170047.png)

![alt images](./images/微信截图_20200616170537.png)

![alt images](./images/微信截图_20200617101307.png)

![alt images](./images/微信截图_20200617103910.png)

![alt images](./images/微信截图_20200617104002.png)

![alt images](./images/微信截图_20200617104937.png)

![alt images](./images/微信截图_20200617105345.png)

![alt images](./images/微信截图_20200617161136.png)

![alt images](./images/微信截图_20200617161822.png)

![alt images](./images/微信截图_20200617161914.png)

![alt images](./images/微信截图_20200617162115.png)

![alt images](./images/微信截图_20200617162236.png)

![alt images](./images/微信截图_20200617162438.png)

![alt images](./images/微信截图_20200618095830.png)

![alt images](./images/微信截图_20200618144604.png)

![alt images](./images/微信截图_20200618145111.png)

### 2.1.2 类加载子系统

![alt images](./images/微信截图_20200618150535.png)

![alt images](./images/微信截图_20200618150610.png)

![alt images](./images/微信截图_20200618150654.png)

![alt images](./images/微信截图_20200618163103.png)

![alt iamges](./images/微信截图_20200618163626.png)

![alt images](./images/微信截图_20200618164006.png)

![alt images](./images/微信截图_20200618170317.png)

![alt images](./images/微信截图_20200618170422.png)

![alt images](./images/微信截图_20200619092937.png)

![alt images](./images/微信截图_20200619101026.png)

![alt images](./images/微信截图_20200619101131.png)

![alt images](./images/微信截图_20200619101220.png)

![alt images](./images/微信截图_20200619104535.png)

![alt images](./images/微信截图_20200619105345.png)

![alt images](./images/微信截图_20200619105511.png)

![alt images](./images/微信截图_20200619112211.png)

![alt images](./images/微信截图_20200619154210.png)

![alt images](./images/微信截图_20200619154408.png)

![alt images](./images/微信截图_20200619154910.png)

![alt images](./images/微信截图_20200619155554.png)

![alt images](./images/微信截图_20200619155634.png)

![alt images](./images/微信截图_20200619155846.png)

![alt images](./images/微信截图_20200619162635.png)

![alt images](./images/微信截图_20200619162813.png)

![alt images](./images/微信截图_20200619162952.png)

### 2.1.3 运行时数据区概述及线程

![alt images](./images/微信截图_20200619163745.png)

![alt images](./images/微信截图_20200619164149.png)

![alt images](./images/微信截图_20200619215116.png)

### 2.1.4 程序计数器(PC寄存器)

![alt images](./images/微信截图_20200619215522.png)

![alt images](./images/微信截图_20200619220912.png)

![alt images](./images/微信截图_20200619221019.png)

![alt images](./images/微信截图_20200619221249.png)

![alt images](./images/微信截图_20200619222706.png)

![alt images](./images/微信截图_20200619222832.png)

![alt images](./images/微信截图_20200619223534.png)

### 2.1.5 虚拟机栈

#### 2.1.5.1 虚拟机栈概述

![alt images](./images/微信截图_20200619224623.png)

![alt images](./images/微信截图_20200621094151.png)

![alt images](./images/微信截图_20200621094227.png)

![alt images](./images/微信截图_20200621094347.png)

![alt images](./images/微信截图_20200621094923.png)

![alt images](./images/微信截图_20200621095318.png)

#### 2.1.5.2 栈的存储单位

![alt images](./images/微信截图_20200621101855.png)

![alt images](./images/微信截图_20200621102131.png)

![alt images](./images/微信截图_20200621110314.png)

![alt images](./images/微信截图_20200621131356.png)

#### 2.1.5.3 局部变量表

![alt images](./images/微信截图_20200621131803.png)

![alt images](./images/微信截图_20200621132922.png)

![alt images](./images/微信截图_20200621141235.png)

![alt images](./images/微信截图_20200621141547.png)

 ![alt images](./images/微信截图_20200621142757.png)

变量的分类：

​	按照数据类型分：

​		1、基本数据类型	

​		2、引用数据类型

​	按照在类中声明的位置分：

​		1、成员变量：在使用前，都经历过默认初始化赋值

​			1)类变量：linking的prepare阶段：给类变量默认值--->inital阶段：给类变量显式赋值即静态代码块赋值；

​			2)实例变量：随着对象的创建，会在堆空间中分配实例变量空间，并进行默认赋值；

​		2、局部变量：在使用前，必须要进行显式赋值的，否则，编译不通过；

![alt images](./images/微信截图_20200621143850.png)

#### 2.1.5.4 操作数栈

#### 2.1.5.5 代码追踪

![alt images](./images/微信截图_20200621144221.png)

![alt images](./images/微信截图_20200621144644.png)

![alt images](./images/微信截图_20200621144750.png)

![alt images](./images/微信截图_20200621150032.png)

#### 2.1.5.6 栈顶缓存技术

![alt images](./images/微信截图_20200621160732.png)

#### 2.1.5.7 动态链接

 ![alt images](./images/微信截图_20200621161117.png)

![alt images](./images/微信截图_20200621162141.png)

![alt images](./images/微信截图_20200622142236.png)

![alt images](./images/微信截图_20200622143417.png)

![alt images](./images/微信截图_20200622160739.png)

![alt images](./images/微信截图_20200622161051.png)

![alt images](./images/微信截图_20200622161607.png)

![alt images](./images/微信截图_20200622164802.png)

![alt images](./images/微信截图_20200622165004.png)

![alt images](./images/微信截图_20200622214727.png)

![alt images](./images/微信截图_20200622215129.png)

#### 2.1.5.8 方法的调用：解析与分派

![alt images](./images/微信截图_20200622220600.png)

#### 2.1.5.9 方法返回地址

![alt images](./images/微信截图_20200622220815.png)

![alt images](./images/微信截图_20200622221004.png)

![alt images](./images/微信截图_20200622221154.png)

![alt images](./images/微信截图_20200622222344.png)

![alt images](./images/微信截图_20200622222623.png)

![alt images](./images/微信截图_20200622222748.png)

### 2.1.6 本地方法接口

![alt images](./images/微信截图_20200623214630.png)

 ![alt images](./images/微信截图_20200623214906.png)

![alt images](./images/微信截图_20200623215243.png)

![alt images](./images/微信截图_20200623215313.png)

![alt images](./images/微信截图_20200623215703.png)

![alt images](./images/微信截图_20200623220045.png)

### 2.1.7 本地方法栈

![alt images](./images/微信截图_20200624100202.png)

![alt images](./images/微信截图_20200624100440.png)

### 2.1.8 堆

#### 2.1.8.1 堆的核心概述

![alt images](./images/微信截图_20200625222136.png)

![alt images](./images/微信截图_20200625222951.png)

![alt images](./images/微信截图_20200625223941.png)

 ![alt images](./images/微信截图_20200625224833.png)

#### 2.1.8.2 设置堆内存大小与OOM

![alt images](./images/微信截图_20200627094510.png)

#### 2.1.8.3 年轻代与老年代

![alt images](./images/微信截图_20200627101921.png)

![alt images](./images/微信截图_20200627102302.png)

#### 2.1.8.4 图解对象分配过程

![alt images](./images/微信截图_20200627103948.png)

![alt images](./images/微信截图_20200627104858.png)

![alt images](./images/微信截图_20200627105807.png)

![alt images](./images/微信截图_20200627111727.png)

#### 2.1.8.5 Minor GC、Major GC、Full GC

![alt images](./images/微信截图_20200627112514.png)

![alt images](./images/微信截图_20200627112832.png)

![alt images](./images/微信截图_20200627113123.png)

![alt images](./images/微信截图_20200627113203.png)

![alt images](./images/微信截图_20200627113342.png)

#### 2.1.8.6 堆空间分代思想

![alt images](./images/微信截图_20200627114304.png)

![alt images](./images/微信截图_20200627114333.png)

#### 2.1.8.7 内存分配策略

![alt images](./images/微信截图_20200627114705.png)

![alt images](./images/微信截图_20200627114745.png)

#### 2.1.8.8 为对象分配内存：TLAB 

![alt images](./images/微信截图_20200628095521.png)

![alt images](./images/微信截图_20200628095716.png)

![alt images](./images/微信截图_20200628095746.png)

![alt images](./images/微信截图_20200628100504.png)

#### 2.1.8.9 小结堆空间的参数配置

![alt images](./images/微信截图_20200628100744.png)

![alt images](./images/微信截图_20200628100935.png)

![alt images](./images/微信截图_20200628154832.png)

#### 2.1.8.10 堆是分配对象的唯一选择吗

![alt images](./images/微信截图_20200628155455.png)

![alt images](./images/微信截图_20200628155729.png)

![alt images](./images/微信截图_20200628160509.png)

![alt images](./images/微信截图_20200628160555.png)

![alt images](./images/微信截图_20200628160637.png)

![alt images](./images/微信截图_20200628160704.png)

![alt images](./images/微信截图_20200628163053.png)

![alt images](./images/微信截图_20200628164122.png)

![alt images](./images/微信截图_20200628165111.png)

![alt images](./images/微信截图_20200628165208.png)

![alt images](./images/微信截图_20200628165359.png)

![alt images](./images/微信截图_20200628165449.png)

![alt images](./images/微信截图_20200628165735.png)

![alt images](./images/微信截图_20200628165824.png)

![alt images](./images/微信截图_20200628170050.png)

### 2.1.9 方法区

#### 2.1.9.1 栈、堆、方法区的交互关系

![alt images](./images/微信截图_20200629165521.png)

![alt images](./images/微信截图_20200629165734.png)

#### 2.1.9.2 方法区的理解

![alt images](./images/微信截图_20200629170745.png)

![alt images](./images/微信截图_20200629171852.png)

![alt images](./images/微信截图_20200629172251.png)

![alt images](./images/微信截图_20200629172652.png)

![alt images](./images/微信截图_20200629172729.png)

#### 2.1.9.3 设置方法区大小与OOM

![alt images](./images/微信截图_20200630165326.png)

![alt images](./images/微信截图_20200630170128.png)

![alt images](./images/微信截图_20200630171245.png)

#### 2.1.9.4 方法区的内部结构

![alt images](./images/微信截图_20200630171734.png)

![alt images](./images/微信截图_20200630172202.png)

![alt images](./images/微信截图_20200701092712.png)

![alt images](./images/微信截图_20200701092808.png)

![alt images](./images/微信截图_20200701092909.png)

![alt images](./images/微信截图_20200701094420.png)

![alt images](./images/微信截图_20200701094858.png)

![alt images](./images/微信截图_20200701095101.png)

![alt images](./images/微信截图_20200701101419.png)

![alt images](./images/微信截图_20200701101537.png)

![alt images](./images/微信截图_20200701103029.png)

![alt images](./images/微信截图_20200701103209.png)

#### 2.1.9.5 方法区使用举例

#### 2.1.9.6 方法区的演进细节

![alt images](./images/微信截图_20200701152401.png)

![alt images](./images/微信截图_20200701153332.png)

![alt images](./images/微信截图_20200701153446.png)

![alt images](./images/微信截图_20200701153525.png)

![alt images](./images/微信截图_20200701155202.png)

![alt images](./images/微信截图_20200701161615.png)

![alt images](./images/微信截图_20200701161649.png)

![alt images](./images/微信截图_20200701161716.png)

![alt images](./images/微信截图_20200701231957.png)

![alt images](./images/微信截图_20200702101653.png)

![alt images](./images/微信截图_20200702101731.png)

![alt images](./images/微信截图_20200702105226.png)

![alt images](./images/微信截图_20200702105251.png)

![alt images](./images/微信截图_20200702105505.png)

#### 2.1.9.7 方法区的垃圾回收

![alt images](./images/微信截图_20200702110115.png)

![alt images](./images/微信截图_20200702110538.png)

![alt images](./images/微信截图_20200702110620.png)

#### 2.1.9.8 总结

![alt images](./images/微信截图_20200702112132.png)

#### 2.1.9.8 对象实例化的几种方式

##### 对象的实例化

![alt images](./images/微信截图_20200702163839.png)

![alt images](./images/微信截图_20200702165433.png)

![alt images](./images/微信截图_20200702170253.png)

1、加载类元信息--->2、为对象分配内存--->3、处理并发问题--->4、属性的默认初始化(零值初始化)--->5、设置对象头的信息--->6、属性的显式初始化、代码块中初始化、构造器中初始化

##### 对象的内存布局

![alt images](./images/微信截图_20200705092827.png)

![alt images](./images/微信截图_20200705093310.png)

##### 对象的访问定位

![alt images](./images/微信截图_20200705093707.png)

![alt images](./images/微信截图_20200705093756.png)

### 2.1.10 直接内存

![alt images](./images/微信截图_20200705094310.png)

![alt images](./images/微信截图_20200705094821.png)

![alt images](./images/微信截图_20200705094903.png)

![alt images](./images/微信截图_20200705095325.png)

![alt images](./images/微信截图_20200705100021.png)

### 2.1.11 执行引擎

#### 2.1.11.1 执行引擎概述

![alt images](./images/微信截图_20200705102514.png)

![alt images](./images/微信截图_20200705102537.png)

![alt images](./images/微信截图_20200705102737.png)

![alt images](./images/微信截图_20200705103246.png)

![alt images](./images/微信截图_20200705103514.png)

#### 2.1.11.2 Java代码编译和执行过程

![alt images](./images/微信截图_20200705103544.png)

![alt images](./images/微信截图_20200705103806.png)

![alt images](./images/微信截图_20200705103853.png)

![alt images](./images/微信截图_20200705103925.png)

![alt images](./images/微信截图_20200705104129.png)

![alt images](./images/微信截图_20200705104928.png)

#### 2.1.11.3 机器码、指令、汇编语言

![alt images](./images/微信截图_20200705105120.png)

![alt images](./images/微信截图_20200705105209.png)

![alt images](./images/微信截图_20200705105451.png)

![alt images](./images/微信截图_20200705105547.png)

![alt images](./images/微信截图_20200705105618.png)

![alt images](./images/微信截图_20200705105758.png)

![alt images](./images/微信截图_20200705105851.png)

#### 2.1.11.4 解释器

![alt images](./images/微信截图_20200705110339.png)

![alt images](./images/微信截图_20200705110638.png)

![alt images](./images/微信截图_20200705110731.png)

![alt images](./images/微信截图_20200705110908.png)

![alt images](./images/微信截图_20200705112519.png)

![alt images](./images/微信截图_20200705112544.png)

![alt images](./images/微信截图_20200705112937.png)

![alt images](./images/微信截图_20200705113324.png)

![alt images](./images/微信截图_20200705113121.png)

#### 2.1.11.5 JIT编译器

![alt images](./images/微信截图_20200705113732.png)

![alt images](./images/微信截图_20200705114052.png)

![alt images](./images/微信截图_20200705114128.png)

![alt images](./images/微信截图_20200705114301.png)

![alt images](./images/微信截图_20200705114408.png)

![alt images](./images/微信截图_20200705114506.png)

![alt images](./images/微信截图_20200705114814.png)

![alt images](./images/微信截图_20200705114845.png)

![alt images](./images/微信截图_20200705140231.png)

![alt images](./images/微信截图_20200705140749.png)

![alt images](./images/微信截图_20200705141034.png)

![alt images](./images/微信截图_20200705141158.png)

![alt images](./images/微信截图_20200705141227.png)

![alt images](./images/微信截图_20200705141250.png)

![alt images](./images/微信截图_20200705141358.png)

![alt images](./images/微信截图_20200705141530.png)

### 2.1.12 StringTable

#####  2.1.12.1 String的基本特性

![alt images](./images/微信截图_20200705142950.png)

![alt images](./images/微信截图_20200705143622.png)

![alt images](./images/微信截图_20200705143703.png)

![alt images](./images/微信截图_20200705144830.png)

在后台执行命令：jinfo -falg StringTableSize 4060(进程号)，可以查看参数信息；

#####  2.1.12.2 String的内存分配

![alt images](./images/微信截图_20200705154037.png)

![alt images](./images/微信截图_20200705154141.png)

![alt images](./images/微信截图_20200705154226.png)

![alt images](./images/微信截图_20200705154246.png)

#####  2.1.12.3 String的基本操作

![alt images](./images/微信截图_20200705154631.png)

![alt images](./images/微信截图_20200705155026.png)

![alt images](./images/微信截图_20200705155047.png)

#####  2.1.12.4 字符串拼接操作

![alt images](./images/微信截图_20200705161411.png)

![alt images](./images/微信截图_20200705163231.png)

![alt images](./images/微信截图_20200705163735.png)

#####  2.1.12.5 intern()的是使用

![alt images](./images/微信截图_20200706102817.png)

![alt images](./images/微信截图_20200706103739.png)

![alt images](./images/微信截图_20200706111610.png)

![alt images](./images/微信截图_20200706111933.png)

![alt images](./images/微信截图_20200706145147.png)

![alt images](./images/微信截图_20200706145403.png)

![alt images](./images/微信截图_20200706145708.png)

![alt images](./images/微信截图_20200706145800.png)

对于程序中大量存在的字符串，尤其其中存在很多重复字符串时，使用intern()可以节省内存空间。

![alt images](./images/微信截图_20200706153923.png)

 2.1.12.6 StringTable的垃圾回收

#####  2.1.12.7 G1中的String去重操作

![alt images](./images/微信截图_20200706170814.png)

![alt images](./images/微信截图_20200706170939.png)

![alt images](./images/微信截图_20200706171021.png)

### 2.1.13 垃圾回收概述

#### 2.1.13.1 什么是垃圾

![alt images](./images/微信截图_20200706214246.png)

![alt images](./images/微信截图_20200706214450.png)

![alt images](./images/微信截图_20200706214807.png)

![alt images](./images/微信截图_20200706214842.png)

![alt images](./images/微信截图_20200706214931.png)

#### 2.1.13.2 为什么需要GC

![alt images](./images/微信截图_20200707221506.png)

#### 2.1.13.3 早起垃圾回收

![alt images](./images/微信截图_20200707222156.png)

![alt images](./images/微信截图_20200707222317.png)

#### 2.1.13.4 Java垃圾回收机制

![alt images](./images/微信截图_20200707222422.png)

![alt images](./images/微信截图_20200707222545.png)

![alt images](./images/微信截图_20200707222825.png)

![alt images](./images/微信截图_20200707222859.png)

### 2.1.14 垃圾回收相关算法

##### 1.标记阶段：引用计数算法

![alt images](./images/微信截图_20200709093148.png)

![alt images](./images/微信截图_20200709093414.png)

![alt images](./images/微信截图_20200709093640.png)

![alt images](./images/微信截图_20200709094145.png)

##### 2.标记阶段：可达性分析算法

![alt images](./images/微信截图_20200709094355.png)

![alt images](./images/微信截图_20200709094520.png)

![alt images](./images/微信截图_20200709094543.png)

![alt images](./images/微信截图_20200709094740.png)

![alt images](./images/微信截图_20200709094926.png)

![alt images](./images/微信截图_20200709095036.png)

##### 3.对象的finalization机制

![alt images](./images/微信截图_20200709100942.png)

![alt images](./images/微信截图_20200709101235.png)

![alt images](./images/微信截图_20200709102533.png)

![alt images](./images/微信截图_20200709102802.png)

##### 4.MAT与JProfiler的GC Roots溯源

![alt images](./images/微信截图_20200709144234.png)

![alt images](./images/微信截图_20200709144357.png)

![alt images](./images/微信截图_20200709144433.png)

##### 5.清除阶段：标记-清除算法

![alt images](./images/微信截图_20200709162409.png)

![alt images](./images/微信截图_20200709162516.png)

![alt images](./images/微信截图_20200709162757.png)

![alt images](./images/微信截图_20200709162934.png)

##### 6.清除阶段：复制算法

![alt images](./images/微信截图_20200709163419.png)

![alt images](./images/微信截图_20200709163504.png)

![alt images](./images/微信截图_20200709163745.png)

![alt images](./images/微信截图_20200709164226.png)

##### 7.清除阶段：标记-压缩算法

![alt images](./images/微信截图_20200709164307.png)

![alt images](./images/微信截图_20200709164427.png)

![alt images](./images/微信截图_20200709164610.png)

![alt images](./images/微信截图_20200709164735.png)

![alt images](./images/微信截图_20200709164753.png)

##### 8.小结

![alt images](./images/微信截图_20200709165006.png)

##### 9.分代收集算法

![alt images](./images/微信截图_20200709222449.png)

![alt images](./images/微信截图_20200709222615.png)

![alt images](./images/微信截图_20200709223011.png)

##### 10.增量收集算法、分区算法

![alt images](./images/微信截图_20200709223207.png)

![alt images](./images/微信截图_20200709223502.png)

![alt images](./images/微信截图_20200709223802.png)

![alt images](./images/微信截图_20200709223909.png)

![alt images](./images/微信截图_20200709223956.png)

### 2.1.15 垃圾回收相关概念

#### 1.System.gc()的理解

![alt images](./images/微信截图_20200712094903.png)

#### 2.内存溢出与内存泄漏

![alt images](./images/微信截图_20200712100230.png)

![alt images](./images/微信截图_20200712100558.png)

![alt images](./images/微信截图_20200712102358.png)

![alt images](./images/微信截图_20200712102447.png)

![alt images](./images/微信截图_20200712102910.png)

![alt images](./images/微信截图_20200712103215.png)

#### 3.Stop The World

![alt images](./images/微信截图_20200712103317.png)

![alt images](./images/微信截图_20200712105438.png)

#### 4.垃圾回收的并行与并发

![alt images](./images/微信截图_20200712110115.png)

![alt images](./images/微信截图_20200712110137.png)

![alt images](./images/微信截图_20200712110228.png)

![alt images](./images/微信截图_20200712110323.png)

![alt images](./images/微信截图_20200712110446.png)

#### 5.安全点与安全区域

![alt images](./images/微信截图_20200712110545.png)

![alt images](./images/微信截图_20200712110603.png)

![alt images](./images/微信截图_20200712110757.png)

![alt images](./images/微信截图_20200712110848.png)

![alt images](./images/微信截图_20200712111010.png)

#### 6.再谈引用：强引用

![alt images](./images/微信截图_20200712111056.png)

![alt images](./images/微信截图_20200712111410.png)

![alt images](./images/微信截图_20200712111710.png)

![alt images](./images/微信截图_20200712113712.png)

![alt images](./images/微信截图_20200712113750.png)

![alt images](./images/微信截图_20200712113813.png)

#### 7.再谈引用：软引用

![alt images](./images/微信截图_20200712113835.png)

![alt images](./images/微信截图_20200712114112.png)

#### 8.再谈引用：弱引用

![alt images](./images/微信截图_20200712152039.png)

![alt images](./images/微信截图_20200712153014.png)

#### 9.再谈引用：虚引用

![alt images](./images/微信截图_20200712153236.png)

![alt images](./images/微信截图_20200712153402.png)

#### 10.再谈引用：终结器引用

![alt images](./images/微信截图_20200712155800.png)

### 2.1.16 垃圾回收器

#### 1.GC分类与性能指标

![alt images](./images/微信截图_20200712162403.png)

#### ![alt images](./images/微信截图_20200712163103.png)

![alt images](./images/微信截图_20200712163015.png)

![alt images](./images/微信截图_20200712163228.png)

![alt images](./images/微信截图_20200712163310.png)

![alt images](./images/微信截图_20200712163610.png)

![alt images](./images/微信截图_20200712163928.png)

![alt images](./images/微信截图_20200712164311.png)

![alt images](./images/微信截图_20200712164456.png)

![alt images](./images/微信截图_20200712164655.png)

![alt images](./images/微信截图_20200712164750.png)

#### 2.不同的垃圾回收器概述

![alt images](./images/微信截图_20200712164935.png)

![alt images](./images/微信截图_20200712165052.png)

![alt images](./images/微信截图_20200712165612.png)

![alt images](./images/微信截图_20200712165809.png)

![alt images](./images/微信截图_20200712165902.png)

![alt images](./images/微信截图_20200713110213.png)

![alt images](./images/微信截图_20200713110638.png)

![alt images](./images/微信截图_20200713110905.png)

#### 3.Serial回收器：串行回收

![alt images](./images/微信截图_20200713111311.png)

![alt images](./images/微信截图_20200713111613.png)

![alt images](./images/微信截图_20200713111657.png)

![alt images](./images/微信截图_20200713111839.png)

#### 4.ParNew回收器：并行回收

![alt images](./images/微信截图_20200713143331.png)

![alt images](./images/微信截图_20200713143434.png)

![alt images](./images/微信截图_20200713143612.png)

![alt images](./images/微信截图_20200713143708.png)

#### 5.Parallel回收器：吞吐量优先

![alt images](./images/微信截图_20200713144154.png)

![alt images](./images/微信截图_20200713144411.png)

![alt images](./images/微信截图_20200713144701.png)

![alt images](./images/微信截图_20200713144751.png)

![alt images](./images/微信截图_20200713161510.png)

![alt images](./images/微信截图_20200713161957.png)

#### 6.CMS回收器：低延迟

![alt images](./images/微信截图_20200713162436.png)

![alt images](./images/微信截图_20200713162801.png)

![alt images](./images/微信截图_20200713162837.png)

![alt images](./images/微信截图_20200713162936.png)

![alt images](./images/微信截图_20200713163059.png)

![alt images](./images/微信截图_20200713163221.png)

![alt images](./images/微信截图_20200713222310.png) 

![alt images](./images/微信截图_20200713222441.png) 

![alt images](./images/微信截图_20200713222501.png) 

![alt images](./images/微信截图_20200713223032.png) 

![alt images](./images/微信截图_20200713223542.png) 

![alt images](./images/微信截图_20200713223732.png) 

![alt images](./images/微信截图_20200713223859.png) 

#### 7.G1回收器：区域化分代式

![alt images](./images/微信截图_20200713224114.png) 

![alt images](./images/微信截图_20200713224651.png) 

![alt images](./images/微信截图_20200713225006.png) 

![alt images](./images/微信截图_20200713225104.png)

![alt images](./images/微信截图_20200713225427.png) 

![alt images](./images/微信截图_20200713225533.png)

![alt images](./images/微信截图_20200713225649.png)

![alt images](./images/微信截图_20200713230038.png)

![alt images](./images/微信截图_20200714100932.png) 

![alt images](./images/微信截图_20200714103101.png) 

![alt images](./images/微信截图_20200714103200.png) 

![alt images](./images/微信截图_20200714104049.png) 

![alt images](./images/微信截图_20200714105325.png) 

![alt images](./images/微信截图_20200714105520.png)

![alt images](./images/微信截图_20200714105658.png) 

![alt images](./images/微信截图_20200714105851.png) 

![alt images](./images/微信截图_20200714110104.png)

![alt images](./images/微信截图_20200714110137.png) 

![alt images](./images/微信截图_20200714111936.png) 

![alt images](./images/微信截图_20200714112225.png) 

![alt images](./images/微信截图_20200714151816.png) 

![alt images](./images/微信截图_20200714151919.png) 

![alt images](./images/微信截图_20200714152349.png) 

#### ![alt images](./images/微信截图_20200714152824.png)

![alt images](./images/微信截图_20200714153120.png) 

![alt images](./images/微信截图_20200714153224.png) 

![alt images](./images/微信截图_20200714153411.png) 

![alt images](./images/微信截图_20200714153619.png) 

![alt images](./images/微信截图_20200714153739.png) 

#### 8.垃圾回收器总结

![alt images](./images/微信截图_20200714153904.png) 

![alt images](./images/微信截图_20200714154116.png) 

![alt images](./images/微信截图_20200714154139.png) 

![alt images](./images/微信截图_20200714162626.png) 

![alt images](./images/微信截图_20200714162731.png) 

![alt images](./images/微信截图_20200714162824.png) 

![alt images](./images/微信截图_20200714162918.png) 

#### 9.GC日志分析

![alt images](./images/微信截图_20200714163051.png) 

![alt images](./images/微信截图_20200714163321.png) 

![alt images](./images/微信截图_20200714163627.png) 

![alt images](./images/微信截图_20200714163839.png) 

![alt images](./images/微信截图_20200714164000.png) 

![alt images](./images/微信截图_20200714164037.png) 

![alt images](./images/微信截图_20200714164132.png) 

![alt images](./images/微信截图_20200714164218.png) 

![alt images](./images/微信截图_20200714164245.png) 

![alt images](./images/微信截图_20200714164348.png) 

![alt images](./images/微信截图_20200714164633.png)

![alt images](./images/微信截图_20200714164839.png)

 日志分析工具的使用

![alt images](./images/微信截图_20200714165217.png) 

#### 10.垃圾回收器的新发展

![alt images](./images/微信截图_20200714165504.png) 

![alt images](./images/微信截图_20200714165624.png) 

![alt images](./images/微信截图_20200714170214.png) 

![alt images](./images/微信截图_20200714170302.png) 

![alt images](./images/微信截图_20200714170447.png)

![alt images](./images/微信截图_20200714170552.png)

![alt images](./images/微信截图_20200714170716.png)

![alt images](./images/微信截图_20200714170842.png)

![alt images](./images/微信截图_20200714170939.png)

![alt images](./images/微信截图_20200714171020.png)

![alt images](./images/微信截图_20200714171045.png)

![alt images](./images/微信截图_20200714171111.png) 

![alt images](./images/微信截图_20200714171140.png)

![alt images](./images/微信截图_20200714171212.png) 

## 2.2 字节码与类的加载

## 2.3 性能监控与调优

## 2.4 大厂面试

# 3.计算机组成原理(20200627-)

## 1.1.1 软硬件发展

![alt images](./images/微信截图_20200627144808.png)

![alt images](./images/微信截图_20200627145126.png)

![alt images](./images/微信截图_20200627145232.png)

![alt images](./images/微信截图_20200627145232.png)





## 1.1.2 分类及发展方向

# 4.计算机组成原理(20200627-)

## 4.1 第一单元 计算机的指令系统

### 4.1.1 计算机程序及分类

![alt images](./images/微信截图_20200628213508.png)

![alt images](./images/微信截图_20200628213358.png)

![alt images](./images/微信截图_20200628214125.png)

![alt images](./images/微信截图_20200628214320.png)

![alt images](./images/微信截图_20200628214416.png)

![alt images](./images/微信截图_20200628214516.png)

![alt images](./images/微信截图_20200628214816.png)

![alt images](./images/微信截图_20200628215053.png)

![alt images](./images/微信截图_20200629221713.png)

![alt images](./images/微信截图_20200629221840.png)

![alt images](./images/微信截图_20200629222301.png)

![alt images](./images/微信截图_20200629222409.png)

![alt images](./images/微信截图_20200629222458.png)

![alt images](./images/微信截图_20200629223038.png)

![alt images](./images/微信截图_20200629223119.png)

![alt images](./images/微信截图_20200629223146.png)

![alt images](./images/微信截图_20200629223146.png)

![alt images](./images/微信截图_20200629223352.png)

![alt images](./images/微信截图_20200629223443.png)

![alt images](./images/微信截图_20200629223500.png)

![alt images](./images/微信截图_20200629223718.png)

![alt images](./images/微信截图_20200629224529.png)

![alt images](./images/微信截图_20200630223603.png)

![alt images](./images/微信截图_20200630223637.png)

![alt images](./images/微信截图_20200630223657.png)

![alt images](./images/微信截图_20200630223900.png)

![alt images](./images/微信截图_20200630224113.png)

![alt images](./images/微信截图_20200630224208.png)

![alt images](./images/微信截图_20200630224241.png)

![alt images](./images/微信截图_20200630224518.png)

![alt images](./images/微信截图_20200630224731.png)

![alt images](./images/微信截图_20200630224944.png)

![alt images](./images/微信截图_20200630225156.png)

![alt images](./images/微信截图_20200701224128.png)

![alt images](./images/微信截图_20200701224407.png)

![alt images](./images/微信截图_20200701224505.png)

![alt images](./images/微信截图_20200701224948.png)

![alt images](./images/微信截图_20200701225158.png)

![alt images](./images/微信截图_20200701225310.png)

![alt images](./images/微信截图_20200701225845.png)

![alt images](./images/微信截图_20200701225921.png)

![alt images](./images/微信截图_20200701225946.png)

![alt images](./images/微信截图_20200701230146.png)

![alt images](./images/微信截图_20200701230237.png)

![alt images](./images/微信截图_20200701230413.png)

![alt images](./images/微信截图_20200701230855.png)

![alt images](./images/微信截图_20200703153111.png)

![alt images](./images/微信截图_20200703153220.png)

![alt images](./images/微信截图_20200703153447.png)

![alt images](./images/微信截图_20200703221700.png)

![alt images](./images/微信截图_20200703222254.png)

![alt images](./images/微信截图_20200703222550.png)

![alt images](./images/微信截图_20200703223332.png)

![alt images](./images/微信截图_20200704214802.png)

![alt images](./images/微信截图_20200704215140.png)

![alt images](./images/微信截图_20200704215437.png)

![alt images](./images/微信截图_20200704215625.png)

![alt images](./images/微信截图_20200704215712.png)

![alt images](./images/微信截图_20200707210858.png)

![alt images](./images/微信截图_20200707211528.png)

![alt images](./images/微信截图_20200707211559.png)

![alt images](./images/微信截图_20200707211709.png)

![alt images](./images/微信截图_20200707212029.png)

![alt images](./images/微信截图_20200707212502.png)

![alt images](./images/微信截图_20200709215345.png)

### 4.1.2 指令系统基础知识![alt images](./images/微信截图_20200709220418.png)

![alt images](./images/微信截图_20200709220448.png)

![alt images](./images/微信截图_20200709220755.png)

![alt images](./images/微信截图_20200709221119.png)



### 4.1.3 MIPS指令系统简介

### 4.1.4 THCO MIPS指令系统

### 4.1.5 THINP AD 指令模拟器

# 5.图解Java设计模式(20200714-)

![alt images](./images/微信截图_20200714211405.png)

![alt images](./images/微信截图_20200714211517.png)

![alt images](./images/微信截图_20200714213020.png)

![alt images](./images/微信截图_20200714213138.png) 

##   5.1 七大设计原则介绍

![alt images](./images/微信截图_20200714230756.png)

![alt images](./images/微信截图_20200714231251.png) 

### 5.1.1 单一职责原则 

![alt images](./images/微信截图_20200714231402.png) 

![alt images](./images/微信截图_20200714232205.png) 

### 5.1.2 接口隔离原则(Interface Segregation Principle)

![alt images](./images/微信截图_20200715111613.png) 

### 5.1.3 依赖倒转原则(Dependence Inversion Principle)

![alt images](./images/微信截图_20200715222554.png)

![alt images](./images/微信截图_20200715224323.png)

![alt images](./images/微信截图_20200715224359.png) 

###  5.1.4 里氏替换原则(Liskov Substitution Priinciple)

![alt images](./images/微信截图_20200716142314.png) 

![alt images](./images/微信截图_20200716142404.png) 

![alt images](./images/微信截图_20200716143300.png) 

### 5.1.5 开闭原则(Open Closed Principle)

![alt images](./images/微信截图_20200716145028.png) 

![alt images](./images/微信截图_20200716145427.png)

### 5.1.6 迪米特法则(Demeter Principle)

![alt images](./images/微信截图_20200716155455.png) 

![alt images](./images/微信截图_20200716160646.png) 

### 5.1.7 合成复用原则(Composite Reuse Principle)

![alt images](./images/微信截图_20200716164906.png) 

## 5.2 UML类图

![alt images](./images/微信截图_20200716165428.png) 

![alt images](./images/微信截图_20200716170642.png) 

### 5.2.1 类图-依赖关系(dependence)

### 5.2.2 类图-泛化关系(generalization)

泛化关系实际上就是继承关系，它是依赖关系的特例

### 5.2.3 类图-实现关系(Implementation)

它是依赖关系的特例

### 5.2.4 类图-关联关系(Association)

关联关系实际上就是类与类之间的联系，它是依赖关系的特例；

### 5.2.5 类图-聚合关系(Aggreation)

聚合关系表示的是整体和部分的关系，整体与部分可以分开。聚合关系是关联关系的特例，所以具有关联的导航性与多重性。

![alt images](./images/微信截图_20200716221942.png)

### 5.2.6 类图-组合关系(Composition)

组合关系也是整体与部分的关系，但是整体与部分不可以分开。

## 5.3 设计模式

![alt images](./images/微信截图_20200717110101.png) 

![alt images](./images/微信截图_20200717110147.png) 

### 5.3.1 单例设计模式

![alt images](./images/微信截图_20200717111725.png) 

![alt images](./images/微信截图_20200717111807.png) 

![alt images](./images/微信截图_20200717111834.png) 

![alt images](./images/微信截图_20200717112129.png) 

![alt images](./images/微信截图_20200717112339.png) 

![alt images](./images/微信截图_20200717112550.png) 

![alt images](./images/微信截图_20200717152345.png) 

![alt images](./images/微信截图_20200717152447.png) 

![alt images](./images/微信截图_20200717152703.png) 

![alt images](./images/微信截图_20200717152830.png) 

![alt images](./images/微信截图_20200717153115.png) 

![alt images](./images/微信截图_20200717153209.png) 

![alt images](./images/微信截图_20200717153315.png) 

![alt images](./images/微信截图_20200717153539.png) 

![alt images](./images/微信截图_20200717154227.png) 

![alt images](./images/微信截图_20200717154459.png) 

![alt images](./images/微信截图_20200719092930.png) 

![alt images](./images/微信截图_20200719093340.png) 

### 5.3.2 工厂模式

#### 5.3.2.1 简单工厂模式

![alt images](./images/微信截图_20200719100851.png) 

#### 5.3.2.2 工厂方法模式

![alt images](./images/微信截图_20200719103842.png) 

#### 5.3.2.3 抽象工厂模式

![alt images](./images/微信截图_20200719110820.png) 

![alt images](./images/微信截图_20200719114724.png) 

### 5.3.3 原型模式

![alt images](./images/微信截图_20200719145135.png) 

![alt images](./images/微信截图_20200719145410.png) 

![alt images](./images/微信截图_20200719152556.png) 

![alt images](./images/微信截图_20200719152648.png) 

![alt images](./images/微信截图_20200719152716.png) 

![alt images](./images/微信截图_20200719154540.png) 

![alt images](./images/微信截图_20200719154805.png) 

### 5.3.4 建造者模式(Builder Pattern)

![alt images](./images/微信截图_20200720220115.png) 

![alt images](./images/微信截图_20200720220144.png) 

![alt images](./images/微信截图_20200720220344.png) 

![alt images](./images/微信截图_20200720222525.png) 

![alt images](./images/微信截图_20200720222555.png) 

### 5.3.5 适配器模式(Adapter Pattern)

![alt images](./images/微信截图_20200721101647.png)

![alt images](./images/微信截图_20200721101854.png)

####  5.3.5.1 类适配器模式

![alt images](./images/微信截图_20200721103053.png) 

![alt images](./images/微信截图_20200721104942.png) 

####   5.3.5.2 对象适配器模式

![alt images](./images/微信截图_20200721220815.png) 

![alt images](./images/微信截图_20200721221351.png) 

####   5.3.5.3 接口适配器模式

![alt images](./images/微信截图_20200721221540.png) 

![alt images](./images/微信截图_20200721225346.png) 

### 5.3.6 桥街模式(Bridge Pattern)

![alt images](./images/微信截图_20200722215231.png) 

![alt images](./images/微信截图_20200722215424.png)

![alt images](./images/微信截图_20200722230219.png)

![alt images](./images/微信截图_20200722230318.png) 

###  5.3.7 装饰者模式

![alt images](./images/微信截图_20200723220133.png) 

![alt images](./images/微信截图_20200723220240.png) 

![alt images](./images/微信截图_20200723220307.png) 

![alt images](./images/微信截图_20200723220335.png) 

### 5.3.8 组合模式(Composite Pattern)

![alt images](./images/微信截图_20200725224342.png) 

![alt images](./images/微信截图_20200725224627.png) 

![alt images](./images/微信截图_20200725224717.png) 

![alt images](./images/微信截图_20200725230850.png) 

![alt images](./images/微信截图_20200725230948.png) 

### 5.3.9 外观模式(Facade)

![alt images](./images/微信截图_20200726095041.png) 

![alt images](./images/微信截图_20200726095121.png) 

![alt images](./images/微信截图_20200726095156.png) 

![alt images](./images/微信截图_20200726095218.png) 

### 5.3.10 享元模式(Flyweight Pattern)

![alt images](./images/微信截图_20200726104810.png) 

![alt images](./images/微信截图_20200726100817.png) 

![alt images](./images/微信截图_20200726104847.png) 

![alt images](./images/微信截图_20200726104915.png) 

![alt images](./images/微信截图_20200726104939.png)

### 5.3.11 代理模式

![alt images](./images/微信截图_20200727222245.png) 

#### 5.3.11.1 静态代理

![alt images](./images/微信截图_20200727222441.png) 

![alt images](./images/微信截图_20200727222508.png) 

#### 5.3.11.2 动态代理

![alt images](./images/微信截图_20200727222609.png) 

#### 5.3.11.3 Cglib代理

![alt images](./images/微信截图_20200727225751.png) 

![alt images](./images/微信截图_20200727225818.png) 

![alt images](./images/微信截图_20200727225853.png) 

### 5.3.12 模板方法模式(Template Method Pattern)

![alt images](./images/微信截图_20200729223026.png) 

![alt images](./images/微信截图_20200729223109.png) 

![alt images](./images/微信截图_20200729223138.png) 

![alt images](./images/微信截图_20200729223210.png) 

![alt images](./images/微信截图_20200729223301.png) 

### 5.3.13 命令模式(Command Pattern)

![alt images](./images/微信截图_20200730195139.png) 

![alt images](./images/微信截图_20200730195208.png) 

![alt images](./images/微信截图_20200730195236.png) 

![alt images](./images/微信截图_20200730195259.png) 

![alt images](./images/微信截图_20200730195320.png) 

### 5.3.14 访问者模式(Visitor Pattern)

![alt images](./images/微信截图_20200802225130.png) 

![alt images](./images/微信截图_20200802225159.png) 

![alt images](./images/微信截图_20200802225229.png) 

![alt images](./images/微信截图_20200802225255.png) 

### 5.3.15 迭代器模式(Iterator Pattern)

![alt images](./images/微信截图_20200806234436.png) 

![alt images](./images/微信截图_20200806222152.png) 

![alt images](./images/微信截图_20200806234505.png) 

![alt images](./images/微信截图_20200806234529.png) 

![alt images](./images/微信截图_20200806234549.png) 

### 5.3.16 观察者模式(Observer)

![alt images](./images/微信截图_20200809154039.png) 

![alt images](./images/微信截图_20200809154116.png) 

![alt images](./images/微信截图_20200809154154.png) 

![alt images](./images/微信截图_20200809154219.png) 

### 5.3.17 中介者模式(Mediator Pattern)



# 6.计算机网络原理(20200723-20200822)

## 1 第一章 计算机网络概述

![alt images](./images/微信截图_20200723222052.png) 

### 1.1 计算机网络在信息时代中的作用

计算机网络向用户提供的最重要的功能有两个：连通性和共享；

连通性：计算机网络使上网用户之前都可以交换信息，好像这些用户的计算机都可以彼此直接连通一样；

共享：即资源共享，可以是信息共享、软件共享，也可以是硬件共享；

### 1.2 因特网概述

#### 1.2.1 网络的网络

网络(network)：由若干结点(node)和连接这些结点的链路(link)组成；

互联网：是"网络的网络(network of network)"；

连接在因特网上的计算机都称为主机(host)；

网络把很多计算机连接在一起，而因特网则把很多网络连接在一起；

#### 1.2.2 因特网发展的三个阶段

1.第一阶段是单个网络ARPANET向互联网发展的过程；

2.第二阶段的特点是简称了三级结构的因特网；

3.第三阶段的特点是逐渐形成了多层次ISP结构的因特网；

Internet和internet的区别：

​	以小写字母i开始的internet(互联网或互连网)是一个通用名词，泛指由多个计算机网络互连而成的网络；

​	以大写字母I开始的Internet(因特网)则是一个专用名词，它指当前全球最大的、开放的、由众多网络相互连接而成的特定计算机网络，它采用TCP/IP协议族作为通信的规则，且其前身是美国的ARPANET；

#### 1.2.3 因特网的标准化工作

### 1.3 因特网的组成

#### 1.3.1 因特网的边缘部分

#### 1.3.2 因特网的核心部分

### 1.4 计算机网络在我国的发展

### 1.5 计算机网络的类别

#### 1.5.1 计算机网络的定义

#### 1.5.2 几种不同类别的网络

不同作用范围的网络：

​	1.广域网WAN(Wide Area Network)

​	2.城域网MAN(Aetropolitan Area Network)

​	3.局域网LAN(Local Area Network)

​	4.个人区域网(Personal Area Network)

不同使用者的网络

​	1.公用网(public network)

​	2.专用网(private network)

### 1.6 计算机网络的性能

#### 1.6.1 计算机网络的性能指标

1.速率：网络技术中的速率指的是连接在计算机网络上的主机在数字信道上传送数据的速率，也称为数据率(data rate)或比特率(bit rate)，速率是计算机网络中最重要的一个性能指标；

2.带宽(bandwidth)："带宽"有以下两种不同的意义：1)带宽本来是指某个信号具有的频带宽度，表示通信线路允许通过的信号频带范围就称为线路的带宽(或通频宽)；2)在计算机网络中，带宽用来表示网络的通信线路所能传送数据的能力，因此网络带宽表示在单位时间内从网络中某一点到另一点所能通过的"最高数据率"；

3.吞吐量(throughput)：表示在单位时间内通过某个网络(或信道、接口)的数据量；有时吞吐量还可用每秒传送的字节数或帧数来表示；

4.时延(delay或latency)：是指数据(一个报文或分组，甚至比特)从网络(或链路)的一端传送到另一端所需的时间，时延是个很重要的性能指标，有时也称为延迟或迟延；

​	1)发送时延(transmission delay)：是主机或路由器发送数据帧所需要的时间，也就是从发送数据帧的第一个比特算起，到该帧的最有一个比特发送完毕所需的时间，也叫传输时延，计算公式：发送时延=数据帧长度(b)/信道带宽(b/s)；

​	2)传播时延(propagation delay)：是电磁波在信道中传播一定的距离需要花费的时间，计算公式：传播时延=信道长度(m)/电磁波在信道上的传播速率(m/s)；发送时延和传播时延的区别：发送时延发生在机器的内部发送器中(一般就是反正在网络适配器汇中)，而传播时延则发生在机器外部的传输信道媒体上；

​	3)处理时延：主机或路由器在收到分组时要花费一定的时间进行处理，例如分析分组的首部、从分组中提取数据部分、进行差错检验或查找适当的路由等等；

​	4)排队时延：分组在经过网络传输时，要经过很多的路由器，但分组在进入路由器后要先在输入队列中排队等待处理，在路由器确定了转发接口后，还要在输出队列中排队等待转发；数据在网络中经历的总时延就是以上四种时延之和；

5.时延带宽积：时延带宽积=传播时延x带宽，链路的时延带宽积又称为以比特为单位在链路长度；

6.往返时间RTT：表示从发送发发送数据开始，到发送方收到来自接收方的确认(接收方收到数据后便立即发送确认)，总共经历的时间；在互联网汇中，往返时间还包括各中间节点的处理时延、排队时延以及转发数据时的发送时延；

7.利用率：利用率有信道利用率和网络利用率两种；信道或网络利用率过高会产生非常大的时延；

#### 1.6.2 计算机网络的非性能特征

1.费用

2.质量

3.标准化

4.可靠性

5.可扩展性和可升级性

6.易于管理和维护

### 1.7 计算机网络体系结构

#### 1.7.1 计算机网络体系结构的形成

#### 1.7.2 协议与划分层次

![alt images](./images/微信截图_20200724230713.png) 

#### 1.7.3 具有五层协议的体系结构

1.应用层(application layer)：应用层是体系结构中的最高层，直接为用户的应用进程提供服务，这里的进程就是指正在运行的程序；

2.传输层(transport layer)：运输层的任务就是负责向两个主机中进程之间的通信提供服务；

​	运输层主要使用一下两种协议：

​	1）传输控制协议TCP(Transmission Control Protocol)：面向连接的，数据传输的单位事报文段(segment)，能够提供可靠的交付；

​	2）用户数据报协议UDP(User Dategram Protocol)：无连接的，数据传输的单位事用户数据报，不保证提供可靠的交付，只能提供"尽最大努力交付(best-effort-deliverry)"；

3.网络层(networl layer)：网络层负责为分组交换网上的不同主机提供通信服务

4.数据链路层(data link layer)：简称为链路层；

5.物理层(physical layer)：在物理层上所传数据的单位事比特，物理层的任务就是透明地传送比特流；

#### 1.7.4 实体、协议、服务和服务的访问点

协议是控制两个对等实体(或多个实体)进行通信的规则的集合；

在协议的控制下，两个对等实体间的通信使得本层能够向上一层提供服务，是实现本层协议，还需要使用下面一层所提供的服务；协议的实现保证了能够像上一层提供服务，使用本层服务的实体只能看见服务而无法看见下面的协议，下面的协议对上面的实体是透明的；

协议是"水平的"，即协议是控制对等实体之间通信的规则，但服务是"垂直的"，即服务是由下层向上层通过层间接口提供的；

![alt images](./images/微信截图_20200726112038.png) 

![alt images](./images/微信截图_20200726112221.png) 

#### 1.7.5 TCP/IP的体系结构

 

## 2 第二章 物理层

### 2.1 物理层的基本概念

### 2.2 数据通信的基础知识

#### 2.2.1 数据通信系统的模型

1.通信的目的是传送消息(message)，如语音、文字、图像等都是消息；数据(data)是运送消息的实体；信号(signal)则是数据的电气的或电磁的表现；

2.根据信号中代表消息的参数的取值方式不同，信号可分为两大类：

​	1）模拟信号，或连续信号，代表消息的参数的取值是连续的

​	2）数字信号，或离散信号，代表消息的参数的取值是离散的，在使用时间域(或简称为时域)的波形表示数字信号时，则表示不同离散数值的基本波形就称为码元；在使用二进制编码时，只有两种不同的码元，一种代表0状态而另一种代表1状态；

#### 2.2.2 有关信道的几个基本概念

1.从通信的双方信息交互的方式来看，可以有以下三种基本方式：

​	1）单向通信，又称为单工通信，即只能有一个方向的通信而没有反方向的交互；无线电广播或有线电广播以及电视广播就属于这种类型；

​	2）双向交替通信，又称为半双工通信，即通信的双方都可以发送信息，但不能双方同时发送(当然也就不能同时接受)。这种通信方式是一方发送另一方接收，过一段时间后再反过来。

​	3）双向同时通信，又称为全双工通信，即通信的双方可以同时发送和接受信息。

​	单向通信只需要一条信道，而双向交替通信或双向同时通信则需要两条信道(每个方向各一条)。显然，双向同时通信的传输效率最高。

#### 2.2.3 信道的极限容量

1.从概念上讲，限制码元的信道上的传输速率的因素有以下两个：

​	1）信道能够通过的频率范围：在任何信道中，码元传输的速率是有上限的，传输速率超过此上限，就会出现严重的码元间串扰的问题，事接收端堆码元的判决(即识别)称为不可能。

​	2）信噪比：香农公式表明，信道的带宽或信道中的信噪比越大，信息的极限传输速率就越高。香农公式指出了信息传输速率的上限，香农公式的意义在于：只要信息传输速率低于信道的极限信息传输速率，就一定可以找到某种办法来实现无差错的传输。

### 2.3 物理层下面的传输媒体

传输媒体也称为传输介质或传输媒介，它就是数据传输系统中在发送器和接收器之间的屋里通路。传输媒体可以分为两大类，即导向传输媒体和非导向传输媒体。在导向传输媒体中，电磁波被导向沿着固定媒体(铜线或光纤)传播，而非导向传播媒体就是指自由空间，在非导向传输媒体中电磁波的传输称为无线传输。

#### 2.3.1 导向传输媒体

1.双绞线：无论是哪种类别的线，衰减都随频率的升高而增大；使用更粗的导线可以降低衰减，但却增加了导线的价格和重量；

2.同轴电缆

3.光缆：光纤通信就是利用光导纤维(光纤)传递光脉冲来进行通信，有光脉冲相当于1，而没有光脉冲相当于0；

#### 2.3.2 非导向传输媒体

传统的微波通信主要有两种主要的方式：即地面微波接力通信和卫星通信。

微波接力通信可传输电话、电报、图像、数据等信息。



### 2.4 信道复用技术

#### 2.4.1 频分复用、时分复用和统计时分复用

#### 2.4.2 波分复用

#### 2.4.3 码分复用

### 2.5 数字传输系统

1.脉码调制PCM体制

缺点：1）速率标准不统一；2）不是同步传输；

2.同步光纤网SONET和同步数字系列SDH

​	SONET标准定义了四个光接口层，自下而上为：光子层(Photonic Layer)，段层(Section Layer)，线路层(Line Layer)，路径层(Path Layer)；

### 2.6 宽带接入技术

#### 2.6.1 xDSL技术

xDSL技术就是用数字技术对现有的模拟电话用户线进行改造，使它能够承载宽带业务。

#### 2.6.2 光纤同轴混合网(HFC网)

HFC网的最大优点是它具有很宽的频带，并且能够利用已经有相当大的覆盖面的有线电视网。

#### 2.6.3 FTTx技术



## 3 第三章 数据链路层

数据链路层属于计算机网络的底层，数据链路层使用的信道主要有以下两种类型：

​	1）点对点信道

​	2）广播信道

### 3.1 使用点对点信道的数据链路层

#### 3.1.1 数据链路和帧

![alt images](./images/微信截图_20200729212154.png) 

![alt images](./images/微信截图_20200729212236.png)

![alt images](./images/微信截图_20200729212356.png) 

![alt images](./images/微信截图_20200729212526.png) 

![alt images](./images/微信截图_20200729212643.png) 

1.链路(link)：从一个结点到相邻结点的一段物理路线，而中间没有任何其他的交换结点；链路只是一条路径的组成部分；

2.数据链路(data link)：在一条线路上传输数据时，除了必须有一条物理线路外，还必须有一些必要的通信协议来控制这些数据的传输，把实现这些协议的硬件和软件加到链路上，就构成了数据链路；现在最常用的方法是使用网络适配器(如拨号上网使用拨号适配器，以及通过以太网上网使用局域网适配器)来实现这些协议的硬件和软件；一般的适配器都包括了数据链路层和物理层这两层的功能；

3.点对点信道的数据链路层的协议数据单元是帧，数据链路层把网络层交下来的数据构成帧发送到链路上，以及把接收到的帧中的数据取出并上交给网络层；在因特网中，网络成协议数据单元就是IP数据报(或简称为数据报、分组或包)；

![alt images](./images/微信截图_20200729162809.png) 

4.点对点信道的数据链路层在进行通信时的主要步骤如下：

​	1）结点A的数据链路层把网络层交下来的IP数据报添加首部和尾部封装成帧；

​	2）结点A把封装好的帧发送给结点B的数据连路层；

​	3）若结点B的数据链路层收到的帧无差错，则从收到的帧中提取出IP数据报上交给上面的网络层；否则丢弃这个帧；

#### 3.1.2 三个基本问题

**封装成帧、透明传输、差错检测。**

1. 封装成帧：就是在一段数据的前后分别添加首部和尾部，这样就构成了一个帧。接受端在收到物理层上交的比特流后，就能根据首部和尾部的标记，从收到的比特流中识别帧的开始和结束。	分组交换的一个重要概念就是：所有在因特网上传送的数据都是以分组为传送单位，网络层的IP数据报传送到数据链路层就成为帧的数据部分。
2. 透明传输：字节填充(byte stuffing)/字符填充(character stuffing)
3. 错检测：目前在数据链路层广泛使用了缓缓冗余检验CRC(Cyclic Redundancy Check)的验错技术。  如果我们在传送数据时不以帧为单位来传送，那么就无法加入冗余码以进行差错检验，因此，如果要在数据链路层进行差错检验，就必须把数据划分为帧，每一帧都加上冗余码，一帧接一帧地传送，然后在接收方逐帧进行差错检验。


### 3.2 点对点协议PPP

PPP(Point-to-Point Protocol)

#### 3.2.1 PPP协议的特点

1. 1.PPP协议应满足的需求：

   ​	1）简单，协议标准化的一个主要目的就是提高协议的互操作性；

   ​	2）封装成帧；

   ​	3）透明性；

   ​	4）多种网络层协议；

   ​	5）多种类型链路；

   ​	6）差错检测(error detection)；

   ​	7）检测连接状态；

   ​	8）最大传送单元；最大传送单元MTU，MTU是数据链路层的帧可以载荷的数据部分的最大长度，而不是帧的总长度；

   ​	9）网络层地址协商；

   ​	10）数据压缩协商；

2. PPP协议不需要的功能

   ​	1）纠错(error correction)：在TCP/IP协议族中，可靠传输由运输层的TCP协议负责，而数据链路层的PPP协议只进行检错，这就是说，PPP协议是不可靠传输协议；

   ​	2）流量控制：在TCP/IP协议族中，端到端的流量控制由TCP负责；

   ​	3）序号：

   ​	4)多点线路：

   ​	5）半双工或单工链路

3. PPP协议的组成

   1）一个将IP数据报封装到串行链路的方法

   2）一个用来建立、配置和测试数据链路连接的链路控制协议LCP(Link Control Protocol)；

   3）一套网络控制协议NCP(Network Control Protocol)；

#### 3.2.2 PPP协议的帧格式

1. 字段的意义
2. 字节填充
3. 零比特填充

#### 3.2.3 PPP协议的工作状态

![alt images](./images/微信截图_20200730102733.png)

### 3.3 使用广播信道的数据链路层

广播信道可以进行一对多的通信，局域网使用的就是广播信道。

局域网的优点：

1. 具有广播功能，从一个站点可很方便地访问全网，局域网上的主机可共享连接在局域网上的各种硬件和软件资源；
2. 便于系统的扩展和逐渐地演变，各设备的位置可灵活调整和改变；
3. 提高了系统的可靠性(reliability)、可用性(availability)、和生存性(survivability)；

#### 3.3.1 局域网的数据链路层

局域网最主要的特点是：网络为一个单位所拥有，且地理范围和站点数目均有限。

必须指出，局域网工作的层次跨越了数据链路层和物理层。

1. 以太网的两个标准

2. 适配器的作用：计算机与外界局域网的连接是通过通信适配器(adapter)，适配器本来是在主机箱内插入的一块网络接口板(或者是在笔记本电脑中插入的一块PCMCIA卡)，这种接口板又称为网络接口卡NIC(Network Interface Card)或简称为"网卡"，由于较新的计算机主板上已经潜入了这种适配器，不使用单独的网卡了。在适配器上面装有处理器和存储器(包括RAM和ROM)。适配器和局域网之间的通信时通过电缆或双绞线以串行传输方式进行的，而适配器和计算机之间的通信则是 通过计算机主板上的I/O总线以并行传输方式进行的。因此，适配器的一个重要功能是要进行数据串行传输和并行传输的转换。由于网络上的数据率和计算机总线上的数据率并不相同，因此在适配器中必须装有堆数据进行缓存的存储芯片。若在主板上插入适配器时，还必须把管理该适配器的设备驱动程序安装到计算机的操作系统中。这个驱动程序以后就会告诉适配器，应当从存储器的什么位置上把多长的数据块发送到局域网，或者应当在存储器的什么位置上把局域网传送的数据块存储下来。适配器还要能够实现以太网协议。

   适配器接收和发送各种帧时不使用计算机的CPU，这时CPU可以处理其他任务，当适配器收到有差错的帧时，就把这个真丢弃而不必通知计算机，当适配器收到正确的帧时，它就使用中断来通知该计算机并交付给协议栈中的网络层，当计算机要发送IP数据报时，就由协议栈把IP数据报向下交给适配器，组装成帧后发送到局域网。计算机的硬件地址就在适配器的ROM中，而计算机的软件地址-IP地址则在计算机的存储器中。

   ![alt images](./images/微信截图_20200730112137.png) 

3.3.2 CSMA/CD协议

以太网采用的协调方式是使用一种特殊的协议CSMA/CD，它是载波监听多点接入/碰撞检测(Carrier Sense Multiple Access with Collision Detection)的缩写；

"多点接入"就是说明这是总线型网络，许多计算机以多点接入的方式连接在一根总线上；协议的实质是"载波监听"和"碰撞检测"；

"载波监听"就是"发送前先监听"，即每一个站在发送数据之前先要检测一下总线上是否有其他站在发送数据，如果有，则暂停不要发送数据，要等待信道变为空闲时再发送；其实总线上并没有什么"载波"，"载波监听"就是用电子技术检测总线上有没有其他计算机发送的数据信号；

"碰撞检测"就是"边发送边监听"，即适配器边发送数据边检测信道上的信号电压的变化情况，以便判断自己在发送数据时其他站是否也在发送数据。当几个站同时在总线上发送数据时，总线上的信号电压变化幅度将会增大(互相叠加)，当适配器检测到的信号电压变化幅度超过一定的门限值时，就认为总线上至少有两个站同时在发送数据，表明产生了碰撞，所谓"碰撞"就是发生了冲突，因此"碰撞检测"也称为"冲突检测"；

CSMA/CD协议的要点归纳如下：

1. 适配器从网络层获得一个分组，加上以太网的首部和尾部，组成以太网帧，放入适配器的缓存中，准备发送；
2. 若适配器检测到信道空闲(即在96比特时间内没有检测到信道上有信号)，就发送这个帧，若检测到信道忙，则继续检测并等待信道转为空闲(加上96比特时间)，然后发送这个帧；
3. 在发送过程中继续假侧信道，若一直未检测到碰撞，就顺利把这个帧成功发送完毕，若检测到碰撞，则中止数据的发送，并发送人为干扰信号；
4. 在中止发送后，适配器就执行指数退避算法，等待r倍512比特时间后，返回到步骤2；

### 3.4 使用广播信道的以太网

#### 3.4.1 使用集线器的星型拓扑

集线器的一些特点如下：

1. 从表面上看，使用集线器的局域网在物理上是一个星型网，但由于集线器是使用电子器件来模拟实际电缆线的工作，因此整个系统扔像一个传统以太网那样运行；
2. 一个集线器有很多接口，例如，8至16个，每个接口通过RJ-45插头(与电话机使用的插头RJ-11相似，但略大一些)用两对双绞线与一个工作站上的适配器相连(这种插座可连接4对双绞线，实际上只用2对，即发送和接收各使用一对双绞线)，因此，一个集线器很像一个多接口的转发器；
3. 集线器工作在物理层，它的每个接口仅仅简单地转发比特，收到1就转发1，收到0就转发0，不进行碰撞检测；
4. 集线器采用了专门的芯片，进行自适应串音回波抵消；

#### 3.4.2 以太网的信道利用率

当数据率一定时，以太网的连线的长度收到限制，同时以太网帧长不能太短；

#### 3.4.3 以太网的MAC层

1. MAC层的硬件地址：在局域网中，硬件地址又称为物理地址或MAC地址(因为这种地址用在MAC帧中)；

   "名字指出我们所要寻找的那个资源，地址指出那个资源在何处，路由告诉我们如何到达该处"；

   IEEE802标准为局域网规定了一种48位的全球地址(一般都简称为"地址")，是指局域网上的每台计算机中固定在适配器的ROM中的地址，因此，假定连接子啊局域网上的一台计算机的适配器坏了而我们更换了一个新的适配器，那么这台计算机的局域网的"地址"也就改变了，虽然这台计算机的地理位置一点也没有变化，所接入的局域网也没有任何变化；

   注意，如果连接在局域网上的主机或路由器安装有多个适配器，那么这样的主机就有多个主机或路由器就有多个"地址"，更准确写说，这种48位"地址"应当是某个接口的标识符；

   MAC地址也叫作硬件地址(hardware address)或物理地址，可见"MAC地址"实际上就是适配器地址或适配器标识符EUI-48，当这块适配器插入(或嵌入)到某台计算机后，适配器上的标识符EUI-48就成为了这台计算机的MAC地址了。

2. MAC帧的格式：以太网V2的MAC帧比较为简单，有五个字段组成，前两个字段分别为6字节长的目的地址和源地址字段。第三个字段是2字节的类型字段，用来标志上一层使用的是什么协议，以便把收到的MAC帧的数据上交给上一层的这个协议。

   曼彻斯特编码的每一个码元(不管码元是1或0)的正中间一定有一次电压的转换(从高到低或从低到高)，当发送方把一个以太网帧发送完毕后，就不再发送其他码元了(即不发送1，也不发送0)，因此，发送方网络适配器的接口上的电压也就不再变化了，这样，接收方就可以容易地找到以太网帧的结束位置，在这个位置往前数4字节(帧检验序列FCS是4字节)，就能确定数据字段的结束位置。

   在以太网上传输数据时是以帧为单位传送，以太网在传送帧时，各帧之间还必须有一定的间隙，因此，接收端只要收到帧开始定界符，其后面的连续到达的比特流就都属于同一个MAC帧，可见以太网不需要使用帧结束定界符，也不需要使用字段插入来保证透明传输。

   IEEE802.3标准规定凡出现下列情况之一即为无效的MAC帧：

   ​	1）真的长度不是整数的字节；

   ​	2）用收到的帧检验序列FCS查出有差错；

   ​	3）收到的帧的MAC客户数据字段的长度不在46-1500字节之间，考虑到MAC帧首部和尾部的长度共有18字节，可以得出有效的MAC帧长度为64-1518字节之间；

### 3.5 扩展的以太网

#### 3.5.1 在物理层扩展以太网

#### 3.5.2 在数据链路层扩展以太网

在数据链路层扩展以太网要使用网桥，网桥工作在数据链路层，它根据MAC帧的目的地址对收到的帧进行转发和过滤，当网桥收到一个帧时，并不是向所有的接口转发此帧，而是先检查此帧的目的MAC地址，然后在确定将该帧转发到哪一个接口，或者是把他丢弃(即过滤)；

1. 网桥的内部结构

   两个以太网通过网桥连接起来后，就成为一个覆盖范围更大的以太网，而原来的每个以太网就可以称为网段(segment)；

   网桥依靠转发表来转发帧，转发表也叫做转发数据库或路由目录；

   网桥是通过内部的接口管理软件和网桥协议实体来完成操作的；

   使用网桥可以带来一下好处：

   ​	1）过滤通信量，增大吞吐量：网桥工作在链路层的MAC子层，可以使以太网各网段成为隔离开的碰撞域，如果把网桥换成工作在物理层的转发器，那就没有这种过滤通信量的功能；

   ​	2）扩大了物理范围；

   ​	3）提高了可靠性；

   ​	4）可互连不同物理层、不同MAC子层和不同速率的以太网；

   网桥的缺点：

   ​	1）由于网桥堆接收的帧要先存储和查找转发表，然后才转发，而转发之前，还必须执行CSMA/CD算法(发生碰撞时要退避)，这就增加了时延；

   ​	2）在MAC子层并没有流量控制功能；

   ​	3）网桥只适合用户数不太多(不超过几百个)和通信量不太大的以太网，否则有时还会因传播过多的广播信息而产生拥塞，这就是所谓的广播风暴；

   网桥在转发帧时，不该表帧的源地址；

2. 透明网桥

   当网桥刚刚连接到以太网时，其转发表示空的，网桥按照以下自学习(self-learning)算法处理收到的帧(这样就逐步建立起其转发表)，并且按照转发表把帧转发出去；这种自学习算法的原理并不复杂，因为：若从某个站A发出的帧从接口X进入了某网桥，那么从这个接口出发沿相反方向一定可把一个帧送到A，所以网桥只要每收到一个帧，就记下其源地址和进入网桥的接口，作为转发表中的一个项目，在建立转发表时是把帧首部中的源地址卸载"地址"这一栏的下面，在转发帧时，则是根据收到的帧首部中的目的地址来转发，这时就把在"地址"蓝限免已经记下的源地址当作目的地址，而把记下的进入接口当作转发接口。

   网桥和集线器(或转发器)的一个重要区别：网桥是按存储转发方式工作的，一定是先把整个帧收下来(但集线器或转发器是逐比特转发)再进行处理，而不管其目的地址是什么；

   网桥自学习和转发帧的一般步骤：

   ​	1）网桥收到一帧先进行自学习，查找转发表中与收到帧的源地址有无相匹配的项目，如没有，就在转发表中增加一个项目(源地址、进入的接口和时间)，如果，则把原有的项目进行更新

   ​	2）转发帧，查找转发表中与收到帧的目的地址有无相匹配的项目，如没有，则通过锁在其他接口(但进入网桥的接口除外)进行转发，如有，则按转发表中给出的接口进行转发，但应注意，若转发表中给出的接口就是该帧进入网桥的接口，则应丢弃这个帧(因为这时不需要经过网桥进行转发)；

   透明网桥还使用生成树(spaaing tree)算法，即互连在一起的网桥在进行彼此通信后，就能找出原来的网络拓扑的一个子集，在这个子集里，整个连通的网络不存在回路，即子啊任何两个站之间只有一条路径；

3. 源路由网桥

4. 多接口网桥---以太网交换机

### 3.6 高速以太网

速率达到或超过100Mb/s的以太网称为告诉以太网；

#### 3.6.1 100BASE-T以太网

100BASE-T可使用交换式集线器提供很多的服务质量，可在全双工方式下工作而无冲突发生，因此，CSMA/CD协议对全双工方式工作的快速以太网是不起作用的(但在半双工方式工作时则一定要使用CSMA/CD协议)；

#### 3.6.2 吉比特以太网

#### 3.6.3 10吉比特以太网

#### 3.6.4 使用高速以太网进入宽带接入

### 3.7 其他类型的高速局部网或接口

## 4 第四章 网络层

本章最重要的内容是：

1. 虚拟互连网络的概念；
2. IP地址与物理地址的关系；
3. 传统的分类的IP地址(包括子网掩码)和无分类域间路由选择CIDR；
4. 路由选择协议的工作原理；

### 4.1 网络层提供的两种服务

因特网采用的设计思路是这样的：网络层向上只提供简单灵活的、无连接的、尽最大努力交付的数据报服务。网络层不提供服务质量的承诺；采用这种设计思路的好处是：网络的造价大大降低，运行方式灵活，能够适应多种应用；

![alt images](./images/微信截图_20200803101348.png) 

### 4.2 网际协议IP

![alt images](./images/微信截图_20200803102120.png) 

#### 4.2.1 虚拟互连网络

没有一种单一的网络能够适应所有用户的需求；

从一般的概念来讲，将网络互相连接起来要使用一些中间设备，根据中间设备所在的层次，可以有以下四种不同的中间设备：

1. 物理层使用的中间设备叫做转发器(repeater)；
2. 数据链路层使用的中间设备叫做网桥或桥接器(bridge)；
3. 网络层使用的中间设备叫做路由器(router)；
4. 在网络层以上使用的中间设备叫做网关(gateway)，用网关连接两个不兼容的系统需要在高层进行协议的转换；

当中间设备是转发器或网桥时，这仅仅是把一个网络扩大了，而从网络层的角度看，着任然是一个网络，一般并不称之为网络互连，网关由于不叫复杂，目前使用得较少，因此，现在我们讨论网络互连时都是指用路由器互连和路由选择。路由器其实就是一台专用计算机，用来在互联网中进行路由选择；由于历史原因，很多有关TCP/IP的文献曾经把网络层使用的路由器称为网关。

所谓虚拟互连网络也就是逻辑互连网络，它的意思就是互连起来的各种物理网络的异构性本来是客观存在的，但是我们利用IP协议就可以使这些性能各异的网络在网络层上看起开好像是一个统一的网络。这种使用IP协议的虚拟互联网络可简称为IP网(IP网是虚拟的，但平常不必每次都强调"虚拟二字")。使用IP网的好处是：当IP网上的主机进行通信时，就好像在一个单个网络上通信一样，它们看不见互连的各网络的具体异构细节(如具体的编址方案、路由选择协议，等等)；

互联网可以由多种异构网络互连组成；

#### 4.2.2 分类的IP地址

1. IP地址及其表示方法

   整个的因特网就是一个单一的、抽象的网络，IP地址就是给因特网上的每一个主机(或路由器)的每一个接口分配一个在全世界范围是唯一的32位的标识符，IP地址的结构使我们可以再因特网上很方便地进行寻址。

   IP地址的编址方法工经历了三个历史阶段，这三个阶段是:

   ​	1）分类的IP地址；

   ​	2）子网的划分；

   ​	3）构成超网；

   所谓"分类的IP地址"就是将IP地址划分为若干个固定类，每一类都由两个固定长度的字段组成，其中第一个字段是网络号(net-id)，它标志主机(或路由器)所连接到的网络，一个网络号在整个因特网范围内必须是唯一的；第二个字段是主机号(host-id)，它标志该主机(或路由器)，一个主机号在它前面的网络号所指明的网络范围内必须是唯一的；由此可见，一个IP地址在整个因特网范围内是唯一的；

   这种两级的IP地址可以记为：IP地址::={<网络号>,<主机号>}；

   对主机或路由器来说，IP地址都是32位的二进制代码，为了提高可读性，我们常常把32位的IP地址中的每8位用其等效的十进制数据表示，并且在这些数字之间加上一个点，这就叫做点分十进制记法；

2. 常用的三种类别的IP地址

   ![alt images](./images/微信截图_20200803163802.png) 

   IP地址具有以下一些重要特点：

   ​	1）每一个IP地址都由网络号和主机号两部分组成，从这个意义上说，IP地址是一种分等级的地址结构；分两个等级的好处是：第一，IP地址管理机构在分配IP地址时只分配网络号(第一级)，而剩下的主机号(第二级)则由得到网络号的单位自行分配，这样就方便了IP地址的管理；第二，路由器仅根据目的主机所连接的网络号来转发分组(而不考虑目的的主机号)，这样就可以使路由表中的项目数大幅度减少，从而减少了路由表所占的存储空间以及查找路由表的时间；

   ​	2）实际上IP地址是标志一个主机(或路由器)和一条链路的接口；当一个主机同时连接到两个网络上时，该主机就必须同时具有两个相应的IP地址，其网络号必须是不同的。这种主机称为多归属主机(multiithomed host)。由于一个路由器至少应当连接到两个网络，因此一个路由器至少应当由两个不同的IP地址；

   ​	3）按照因特网的观点，一个网络是指具有相同网络号net-id的主机的集合，因此，用转发器或网桥连接起来的若干个局域网仍为一个网络，因为这些局域网都具有同样的网络号，具有不同网络号的局域网必须使用路由器进行互连；

   ​	4）在IP地址中，所有分配到网络号的网络(不管是范围很小的局域网，还是可能覆盖很大地理范围的广域网)都是平等的；

#### 4.2.3 IP地址与硬件地址

IP地址与硬件地址的区别：从层次的角度看，物理地址是数据链路层和物理层使用的地址，而IP地址是网络层和以上各层使用的地址，是一种逻辑地址(称IP地址是逻辑地址是因为IP地址是用软件实现的)；

IP地址放在IP数据报的首部，而硬件地址则放在MAC帧的首部，在网络层和网络层以上使用的是IP地址，而数据链路层及以下使用的是硬件地址；当IP数据报放入数据链路层的MAC帧中以后，整个IP数据报就成为MAC帧的数据，因而在数据链路层看不到数据报的IP地址；

1. 在IP层抽象的互联网上只能看到IP数据报；
2. 虽然在IP数据报首部有源站IP地址，但路由器只根据目的站的IP地址的网络号进行路由选择；
3. 在局域网的链路层，只能看到MAC帧；
4. 尽管互连在一起的网络的硬件地址体系各不相同，但IP层抽象的互联网却屏蔽 了下层这些很复杂的细节，只要我们在网络层上讨论问题，就能够使用统一的、抽象的IP地址研究主机和主机或路由器之间的通信；

#### 4.2.4 地址解析协议ARP和逆地址解析协议RARP

地址解析协议ARP在主机ARP高速缓存中应存放一个从IP地址到硬件地址的映射表，并且这个映射表还经常动态更新(新增或超时删除)；

每一个主机都设有一个ARP高速缓存(ARP cache)，里面有本局域网上的各主机和路由器的IP地址到硬件地址的映射表，这些都是该主机目前知道的一些地址；

ARP是解决同一局域网的主机或路由器的IP地址和硬件地址的映射问题；

从IP地址到硬件地址的解析是自动进行的，主机的用户对这种地址解析过程时不知道的；只要主机或路由器要和本网络上的另一个已知IP地址或路由器进行通信，ARP协议就会自动把这个IP地址解析为链路层所需要的硬件地址；

ARP的四种典型情况：

1. 发送方是主机，要把IP数据报发送到本网络上的另一个主机，这时用ARP找到目的主机的硬件地址；
2. 发送发是主机，要把IP数据报发送到另一个网络上的一个主机，这时用ARP找到本网络上的一个路由器的硬件地址，剩下的工作由这个路由器来完成；
3. 发送发是路由器，要把IP数据报转发到本网络上的一个主机，这时用ARP找到目的主机的硬件地址；
4. 发送方是路由器，要把IP数据报转发到另一个网络上的一个主机，这时用ARP找到本网络上的一个路由器的硬件地址，剩下的工作由这个路由器来完成；

为什么不直接使用硬件地址进行通信，而是要使用抽象的IP地址并调用ARP来寻找出相应的硬件地址：由于全世界存在着各式各样的网络，它们使用不同的硬件地址，要使这些异构网络能够互相通信就必须进行非常复杂的硬件地址转换工作，因此由用户或用户主机来完成这项工作时不可能的事，但统一的IP地址把这个复杂问题解决了，连接到因特网的主机只需拥有统一的IP地址，它们之间的通信就像连接子在同一网络上那样简单方便，因此上述的调用ARP的复杂过程都是由计算机自动进行的，对用户来说是看不见这种调用过程的；

#### 4.2.5 IP数据报的格式

![alt images](./images/微信截图_20200804103934.png) 

1. IP数据报首部的固定部分中的各字段

   1）版本，占4位，指IP协议的版本；

   2）首部长度，占4位，可表示的最大十进制数值是15；

   3）区分服务，占8位，用来获得更好的服务；

   4）总长度，总长度指首部和数据之和的长度，单位为字节，总长度字段为16位，因此数据报的最大 长度为65535字节；

   5）标识(identification)，占16位；

   6）标志(flag)，占3位，但目前只有两位有意义；

   7）片偏移，占13位，片偏移指出：较长的分组在分片后，某片在原分组中的相对位置；

   8）生存时间(TTL Time To Live)，占8位，表明是数据报在网络中的寿命；

   9）协议，占8位，协议字段指出了此数据报携带的数据时使用何种协议，以便使目的主机的IP层知道应将数据部分上交到那个处理过程；

   10）首部检验和，占16位，这个字段只检验数据报的首部，但不包括数据部分；

   11）源地址，占32位；

   12）目的地址，占32位；

2. IP数据报首部的可变部分

#### 4.2.6 IP层转发分组的流程

在互联网上转发分组时，是从一个路由器转发到下一个路由器；在路由表中，对每一条路由最主要的是以下两个信息：(目的网络地址，下一跳地址)；

能不能在路由表中不实用IP地址而直接使用硬件地址呢？不行，使用抽象的IP地址，本来就是为了隐藏各种底层网络的复杂性而便于分析和研究问题，这样就不可避免地要付出些代价，例如在选择路由时多了一些开销，但反过来，如果在路由表中直接使用硬件地址，那就回带来更多的麻烦；

根据以上所述，可归纳出分组转发算法如下：

1. 从数据报的首部提取目的主机的IP地址D，得出目的网络地址为N；
2. 若N就是与路由器直接相连的某个网络地址，则进行直接交付，不需要再经过其他的路由器，直接把数据报交付给目的主机(这里包括把目的主机地址D转换为具体的硬件地址，把数据报封装为MAC帧，在发送此帧)；否则就是间接交付，执行3；
3. 若路由表中有目的地址为D的特定主机路由，则把数据报传送给路由表中所指明的下一跳路由器；否则，执行4；
4. 若路由表中有到达网络N的路由，则把数据报传送给路由表中所指明的下一跳路由器；否则，执行5；
5. 若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器；否则，执行6；
6. 报告转发分组出错；

### 4.3 划分子网和构造超网

#### 4.3.1 划分子网

1. 从两级IP地址到三级IP地址

   划分子网的基本思路如下：

   1）一个拥有很多物理网络的单位，可将所属的物理网络划分为若干个子网(subnet)；划分子网纯属一个单位内部的事情，本单位意外的网络看不见这个网络是有多少个子网组成，因为这个单位对外任然变现为一个网络；

   2）划分子网的方法是从网络的主机号借用若干个作为子网号subnet-id，当然主机号也就相应减少了同样的位数；于是两级IP地址在本单位内部就变为三级IP地址：网络号、子网号和主机号，也可以用以下记法来表示：IP地址::=={<网络号>,<子网号>.<主机号>}；

   3）凡是从其他网络发送到本单位某个主机的IP数据报，任然是根据IP数据报的目的网络号找到连接在本单位网络上的路由器，但此路由器在收到IP数据报后，再按目的网络号和子网号找到目的子网，把IP数据报交付给目的主机；

2. 子网掩码(subnet mask)

   使用子网掩码的好处就是：不管网络有没有划分子网，只要把子网掩码和IP地址进行逐位的与运行(AND)，就立即导出网络地址来，这样在路由器处理到来的分组时就可采用同样的算法；

   现在因特网的标准规定：所有的网络都必须使用子网掩码，同时在路由器的路由表中也必须有子网掩码这一栏，如果一个网络不划分子网，那么该网络的子网掩码就使用默认子网掩码，默认子网掩码中1的位置和IP地址中的网络号字段net-id正好相对应；因此，若用默认子网掩码和某个不划分子网的IP地址逐位相"与"(AND)，就应当能够得出该IP地址的网络地址来，这样做可以不用查找改地址的类别位就能知道这是哪一类的IP地址；

   ![alt images](./images/微信截图_20200804231539.png) 

   划分子网增加了灵活性，但却减少了能够连接在网络上的主机总数；


#### 4.3.2 使用子网时分组的转发

![alt images](./images/微信截图_20200805105959.png) 

使用子网划分后，路由表必须包含以下三项内容：目的网络地址、子网掩码和下一跳地址；

#### 4.3.3 无分类编址CIDR(构造超网)

1. 网络前缀

   CIDR最主要的特点有两个：

   1）CIDR消除了传统的A类、B类、C类地址以及划分子网的概念，因而可以更加有效地分配IPv4的地址空间，并且可以再新的IPv6使用之前容许因特网的规模继续增长。CIDR把32位的IP地址划分为两个部分，前面的部分是"网络前缀"(network-prefix)(或简称为"前缀")，用来指明网络，后面的部分则用来指明主机；IP地址::={<网络前缀>,<主机号>}；

   2）CIDR把网络前缀都相同的连续的IP地址组成一个"CIDR地址块"；

   斜线记法中，斜线后面的数字就是地址掩码中的1的个数；

   网络前缀越短，其地址块所包含的地址数就越多，而在三级结构的IP地址中，划分子网是使网络前缀变长；

2. 最长前缀匹配

   在查找路由表时可能会得到不止一个匹配结果，这样就带来一个问题，我们应当从这些匹配结果中选择那一条路由呢？正确的答案是：应当从匹配结果中选择具有最长网络前缀的路由；这叫做最长前缀匹配(longest-prefix matching)，就是因为网络前缀越长，其地址块就越小，因而路由就越具体(more specific)；最长前缀匹配又称为最长匹配或最佳匹配；

3. 使用二叉线索查找路由表

   为了进行更加有效的查找，通常是把无分类编址的路由表存放在一种层次的数据结构中，然后自上而下地按层次进行查找，我们最常用的就是二叉线索(binary trie)，它是一种特殊结构的树，IP地址中从左到右的比特值决定了从根节点逐层向下层延伸的路径，而二叉线索中的各个路径就代表路由表中存放的各个地址；

### 4.4 网际控制报文协议ICMP

为了更有效的转发IP数据报和提高交付成功的机会，在网际层使用了网际控制报文协议ICMP(Internet Control Message Protocol)，ICMP允许主机或路由器报告差错情况和提供有关异常情况的报告；ICMP不是高层协议，而是IP层的协议，作为IP层数据报的数据，加上数据报的首部，组成IP数据报发送出去；

#### 4.4.1 ICMP报文的种类

ICMP有ICMP差错报告报文和ICMP询问报文两种；

![alt images](./images/微信截图_20200805161125.png) 

![alt images](./images/微信截图_20200805164619.png) 

常用的ICMP询问报文有两种：

1. 回送请求和回答，这种询问报文用来测试目的站是否可达以及了解其有关状态；
2. 时间戳请求和回答，可用来进行时钟同步和测量时间；

#### 4.4.2 ICMP的应用举例

ICMP的一个重要应用就是分组间探测PING(Packet InterNet Groper)，用来测试两个主机之间的连通性。PING使用了ICMP回送请求与回送回答报文，PING是应用层直接使用网络层ICMP的一个例子，没有通过运输层的TCP或UDP；

### 4.5 因特网的路由选择协议

#### 4.5.1 有关路由选择协议的几个基本概念

1. 理想的路由算法

   一个理想的路由算法应具有如下的一些特点：

   1）算法必须是正确的和完整的；

   2）算法在计算上应简单；

   3）算法应能适应通信量和网络拓扑的变化；

   4）算法应具有稳定性；

   5）算法应是正平的；

   6）算法应是最佳的，所谓"最佳"只能是相对于某一种特定要求下得出的较为合理的选择而已；

   倘若从路由算法能否随网络的通信量或拓扑自适应地进行调整变化来划分，则只有两大类，即静态路由选择策略与动态路由选择策略；静态路由选择也叫做非自适应路由选择，其特点是简单和开销较小，但不能及时适应网络状态的变化，对于很简单的小网络，完全可以采用静态路由选择，用人工配置每一条路由；动态路由选择也叫做自适应路由选择，其特点是能较好地使用网络状态的变化，但实现起来较为负责，开销也比较大，因此，动态路由选择适用于较复杂的大网络；

2. 分层次的路由选择协议

   自治系统(autonomous system)：自治系统AS的经典定义是在单一的技术管理下的一组路由器，而这些路由器使用一种AS内部的路由选择协议和共同的度量以确定分组在该AS内的路由，同时还使用一种AS之间的路由选择协议用以确定分组在AS之间的路由；

   尽管一个AS使用了多种内部路由选择协议和度量，但重要的是一个AS对其他AD表现出的是一个单一的和一致的路由选择策略；

   在目前的因特网中，一个大的ISP就是一个自治系统，这样，因特网就把路由选择协议划分为两大类：

   1）内部网关协议IGP(Interior Gateway Protocol)：在一个自治系统内部使用的路由选择协议，而这与在互联网中的其他自治系统用什么路由选择协议无关，如RIP和OSPF协议；

   2）外部网关协议EGP(External Gateway Protocol)：若源主机和目的主机处在不同的自治系统中(着两个自治系统可能使用不同的内部网关协议)，当数据报传到一个自治系统的边界时，就需要使用一种协议将路由选择信息传递到另一个自治系统中，这样的协议就是外部网关协议EGP，目前使用最多的外部网关协议是BGP；

#### 4.2.5 内部网关协议RIP

1. 工作原理

   路由信息协议RIP(Routing Information Protocol)是一种分布式的基于距离向量的路由选择协议，是因特网的标准协议，其最大优点就是简单；

   RIP协议要求网络中的每一个路由器都要维护从它自己到其他每一个目的网络的距离记录(因此，这时一组距离，即"距离向量")，RIP协议将"距离"定义为如下：从一路由器到直接连接的网络的距离定义是1，从一路由器到非直接连接的网络的距离定义为所经过的路由器数加1；RIP协议的"距离"也称为"跳数"(hop count)，RIP认为好的路由就是它通过的路由器的数目少，即"距离短"，RIP允许一条路径最多只能包含15个路由器，可见RIP只适用于小型互联网；

   RIP不能在两个网络之间同时使用多条路由，RIP选择一条具有最少路由器的路由(即最短路由)，哪怕还存在一条高速(低时延)但路由器较多的路由；

   RIP协议和OSPF协议，都是分布式路由选择协议，共同特点就是每一条路由器都要不断地和其他一些路由器交换路由信息，我们一定要弄清以下三个要点，即合那些路由器交换信息？交换什么信息？在什么时候交换信息？

   RIP协议的特点如下：

   1）仅和相邻路由器交换信息，如果两个路由器之间的通信不需要经过另一个路由器，那么这两个路由器就是相邻的，RIP协议规定，不相邻的路由器不交换信息；

   2）路由器交换的信息是当前本路由器所知道的全部信息，即自己的路由表，也就是说，交换的信息是："我到本自治系统中所有网络的(最短)距离，以及到每个网络应经过的下一跳路由器"；

   3）按固定的时间间隔交换路由信息，例如，每隔30秒，然后路由器根据收到的路由I西宁西更新路由表，当网络拓扑发生变化时，路由器也及时向相邻路由器通告拓扑变化后的路由信息；

   路由表中最主要的信息就是：到某个网络的距离(即最短距离)，以及应经过的下一跳地址，路由表更新的原则是找出到每个目的网络的最短距离，这种更新算法又称为距离向量算法；

2. 距离向量算法

   ![alt images](./images/微信截图_20200806165829.png) 

   ![alt images](./images/微信截图_20200806165908.png) 

   RIP协议让一个自治系统中的所有路由器和自己相邻路由器定期交换路由信息，并不断更新其路由表，使得从每一个路由器到每一个目的网络的路由都是最短的(即跳数最少)，这里还应当注意：虽然所有的路由最终都拥有了整个自治系统的全局路由信息，但由于每一个路由器的位置不同，它们的路由表当然也应当是不同的；

3. RIP协议的报文格式

   ![alt images](./images/微信截图_20200806172358.png) 

   总之，RIP协议最大的优点就是实现简单，开销较小，但RIP协议的缺点也较多，首先，RIP限制了网络的规模，它能使用的最大距离为15(16表示不可达)，其次，路由器之间交换的路由信息是路由器中的完整路由表，因而随着网络规模的扩大，开销也就增加，最后，"坏消息传播得慢"，使更新过程的收敛时间过长，因此对于规模较大的网络就应当使用OSPF协议；

#### 4.5.3 内部网关协议OSPF

1. OSPF协议的基本特点

   开放最短路径优先OSPF(Open Shortest Path First)，OSPF最主要的特征就是使用分布式的链路状态协议(link state protocol)；

   1）向本自治系统中所有路由器发送信息；

   2）发送的信息就是与本路由器相邻的所有路由器的链路状态，但这只是路由器所知道的部分信息，所谓"链路状态"就是说明本路由器都和那些路由器相邻，以及该链路的"度量"(metric)；

   3）只有当链路状态发生变化时，路由器才向所有路由器用洪泛发发送此信息；

   由于各路由器之间频繁地减缓链路状态信息，因此所有的路由器最终都能建立一个链路状态数据库(link-state database)，这个数据库实际上就是全网的拓扑结构图，这个拓扑结构图在全网范围内是一致的(这称为链路状态数据库的同步)，因此，每一个路由器都知道全网共有多少个路由器，以及那些路由器是相连的，其代价是多少，等等，每一个路由器使用链路状态数据库中的数据，构造出自己的路由表；而RIP协议的每一个路由器虽然知道到所有网络的距离以及下一跳路由器，但却不知道全网的拓扑结构(只有到了下一跳路由器，才能知道再下一跳应当怎样走)；

   OSPF的链路状态数据库能较快地进行更新，使各个路由器能及时更新其路由表，OSPF的更新过程收敛得快是其重要的优点；

   ![alt images](./images/微信截图_20200807113541.png) 

   ![alt images](./images/微信截图_20200807113819.png) 

2. OSPF的五种分组类型

   ![alt images](./images/微信截图_20200807141812.png) 

#### 4.5.4 外部网关协议BGP

边界网关协议BGP只能是力求寻找一条能够达到目的网络且比较好的路由(不能兜圈子)，而并非要寻找一条最佳路由，BGP采用了路径向量(path vector)路由选择协议；

BGP所交换的网络可达性的信息就是要到达某个网络(用网络前缀表示)所要经过的一系列AS；

![alt images](./images/微信截图_20200807144645.png) 

#### 4.5.5 路由器的构成

1. 路由器的结构

   路由器是一种具有多个输入端口和多个输出端口的专用计算机，其任务是转发分组，从路由器某个输入端口收到的分组，按照分组要去的目的地(即目的网络)，把该分组从路由器的某个合适的输出端口转发给下一跳路由器，下一跳路由器也按照这种方法处理 分组，直到该分组到达终点为止，路由器的转发分组正是在网络层的主要工作；

   ![alt images](./images/微信截图_20200807145723.png) 

   整个的路由器结构可划分为两大部分：路由选择部分和分组转发部分；

   路由选择部分也叫做控制部分，其核心构件是路由选择处理机，路由选择处理机的任务是根据所选定的路由选择协议构造出路由表，同时经常或定期地和相邻路由器交换路由信息而不断地更新和维护路由表；

   分组转发部分由交换结构、一组输入端口和一组输入端口(请注意：这里的端口就是硬件接口)；

   交换结构(switching fabric)又称为交换组织，它的作用就是就是根据转发表(forwarding table)对分组进行处理，将某个输入端口进入的分组从一个合适的输出端口转发出去；

   "转发"和"路由选择"的区别：在互联网中，"转发"就是路由器根据转发表把收到的IP数据报从路由器合适的端口转发出去，"转发"仅仅涉及到一个路由器；但"路由选择"则涉及到很多路由器，路由表则是很多路由器协同工作的结果，这些路由器按照复杂的路由算法，得出整个网络的拓扑变化情况，因而能够动态地改变所选择的路由，并由此构造出整个路由表，路由表一般仅包含从目的网络到下一跳(用IP地址表示)的映射，而转发表是从路由表得出的，转发表必须包含完成转发功能所必需的信息，这就是说，在转发表的每一行必须包含从要到达的目的网络到输出端口和某些MAC地址信息(如下一跳的以太网地址)的映射；

   将转发表和路由表用不同的数据结构实现会带来一些好处，这是因为在转发分组时，转发表的结构应当使查找过程最优化，但路由表则需要对网络拓扑变化的计算最优化；路由表总是用软件实现的，但转发表则甚至可用特殊硬件来实现；

   请读者注意，在讨论路由选择的原理时，往往不去区分转发表和路由表的区别，而可以笼统地都使用路由表这一名词；

   在图4-42中，路由器和输入和输出端口里面都各有三个方框，用方框1、2和3分别代表物理层、数据链路层和网络层的处理模块；物理层进行比特的接收，数据链路层则按照链路层协议接收传送分组的帧，把帧的首部和尾部剥去后，分组就被送入网络层的处理模块，若接收到的分组时路由器之间交换路由信息的分组(如RIP或OSPF分组等)，则把这种分组送交路由器的路由选择部分中的路由选择处理机，若接收到的是数据分组，则按照分组首部中的目的地址查找转发表，根据得出的结果，分组就经过交换结构达到合适的输出端口；一个路由器的输入端口和输出端口就做在路由器的线程接口卡上；

   输入端口中的查找和转发功能在路由器额交换功能中是最重要的；

   ![alt images](./images/微信截图_20200807161848.png) 

2. 交换结构

   ![alt images](./images/微信截图_20200807163414.png) 

### 4.6 IP多播

#### 4.6.1 IP多播的基本概念

在因特网范围的多播要考路由器来实现，这些路由器必须增加一些能够识别多播数据报的软件；

多播数据报和一般的IP数据报的区别就是它使用D类IP地址作为目的地址，并且首部中的协议字段值是2,表明使用IGMP协议；

#### 4.6.2 在局域网上进行硬件多播

![alt images](./images/微信截图_20200809095048.png)

#### 4.6.3 网际组管理协议IGMP和多播路由器选择协议

1. IP多播需要两种协议

   IGMP协议是让啊连接在本地局域网上的多播路由器知道本局域网上是否有主机(严格将，是主机上的某个进程)参加或退出了某个多播组；

   多播转发必须动态地适应多播组成员的变化(这时网络拓扑并未发生变化)，请注意，单播路由选择通常是网络拓扑发生变化时才需要更新路由；

   多播路由器在转发多播数据报时，不能仅仅根据多播数据报中的目的地址，而是还要考虑这个多播数据报从什么地方来和要到什么地方去；

   多播数据报可以由没有加入多播组的主机发出，也可以通过没有组成员接入的网络；

2. 网际组管理协议IGMP

   ![alt images](./images/微信截图_20200809100636.png) 

3. 多播路由选择协议

   已有了多种实用的多播路由选择协议，它们在转发多播数据报时使用了一下三种方法：

   1）洪泛与剪除，这种方法适合于较小的多播组，而所有的组成员接入的局域网也是相邻接的；

   2）隧道技术(tunneling)，隧道技术适用于多播组的位置在地理上很分散的情况，这种使用隧道技术传送数据报又叫做IP中的IP(IP-in-IP)；

   3）基于核心的发现技术，这种方法对于多播组的大小在较大范围内变化时都适合；

   ![alt images](./images/微信截图_20200809102644.png) 

### 4.7 虚拟专用网VPN和网络地址转换NAT

#### 4.7.1 虚拟专用VPN(Vitural Pirvate Network)

RFC1918指明了一些专用地址(private address)，这些地址只能用于一个机构的内部通信，而不能用于和因特网上的主机通信。换言之，专用地址只能用作本地地址而不能用作全球地址，在因特网中的所有路由器，对目的地址是专用地址的数据报一律不进行转发；

![alt images](./images/微信截图_20200809105148.png) 

![alt images](./images/微信截图_20200809111139.png) 

#### 4.7.2 网络地址转换NAT(Network Adress Translation)

网络地址转换NAT方法是在1994年提出的，这种方法需要在专用网连接到因特网的路由器上安装NAT软件，装有NAT软件的路由器叫做NAT路由器，它至少有一个有效的外部全球IP地址，这样，所有使用本地地址的主机在和外界通信时，都要在NAT路由器上将其本地地址转换成全球IP地址，才能和因特网连接；

## 5 第五章 运输层

### 5.1 运输层协议概述

#### 5.1.1 进程之间的通信

两个主机进行通信就是两个主机中的应用进程互相通信，IP协议虽然能把分组发送到目的主机，但是这个分组还停留在主机的网络层而没有交付给主机中的应用进程；从运输层的角度看，通信的真正端点并不是主机而是主机中的进程，也就是说，端到端的通信是应用进程之间的通信；

网络层和运输层的区别：网络层是为主机之间提供逻辑通信，而运输层为应用进程之间提供端到端的逻辑通信；

#### 5.1.2 运输层的两个主要协议

TCP/IP运输层的两个主要协议都是因特网的正式标准：

1. 用户数据报协议UDP(User Datagram Protocol)：在传送数据之前不需要先建立连接，远地主机的运输层在收到UDP报文后，不需要给出任何确定；
2. 传输控制协议TCP(Transmission Control Protocol)：提供面向连接的服务，在传送数据之前必须先建立连接，数据传送结束后要释放连接；

![alt images](./images/微信截图_20200809135432.png) 

#### 5.1.3 传输层的端口

应用层所有的应用进程都可以通过传输层再传送到IP层，这就是复用(multiplexing)；运输层从IP层收到数据后必须交付给指明的应用进程，这就是分用(demultiplexing)；

协议端口号(protocol port number)，通常简称为端口(port)；

请注意，这种在协议层间的抽象的协议端口是软件端口，和路由器或交换机上的硬件端口是完全不同的概念；硬件端口是不同硬件设备进行交互的接口，而软件端口是应用层的各种协议进程与运输实体进行层间交互的一种地址，不同系统的具体实现端口的方法可以是不同的(取决于系统使用的操作系统)；

TCP/IP的运输层用一个16为端口号来标志一个端口，但请注意，端口号只具有本地意义，它只是为了标志本计算机应用层中的各个进程在和运输层交互时的层间接口，在因特网不同计算机中，相同的端口号是没有关联的；

运输层的端口号共分为下面的两大类：

1. 服务器端使用的端口号
2. 客户端使用的端口号

![alt images](./images/微信截图_20200809141318.png) 

### 5.2 用户数据报协议UDP

#### 5.2.1 UDP概述

用户数据报协议UDP只在IP的数据报之上增加了很少一点功能，这就是复用和分用的功能以及差错检测的功能，UDP的主要特点是：

1. UDP是无连接的；
2. UDP使用尽最大努力交付，即不保证可靠交付，因此主机不需要维持复杂的连接状态表(这里面有很多参数)；
3. UDP是面向报文的；
4. UDP没有拥塞控制，因此网络出现的拥塞不会使源主机的发送速率降低；
5. UDP支持一对一、一对多、多对一和多对多的交互通信；
6. UDP的首部开销小，只有8个字节；

#### 5.2.2 UDP的首部格式

![alt images](./images/微信截图_20200810091215.png) 

### 5.3 传输控制协议TCP概述

#### 5.3.1 TCP最主要的特点

1. TCP是面向连接的运输层协议；
2. 每一条TCP连接只能有两个端点(endpoint)，每一条TCP连接只能是点对点的(一对一)；
3. TCP提供可靠交付的服务，也就是说，通过TCP连接传送的数据，无差错、不丢失、不重复、并且按序到达；
4. TCP提供全双工通信，TCP允许通信双方的应用进程在任何时候都能发送数据；
5. 面向字节流，TCP中的"流"(stream)指的是流入到进程或从进程流出的字节序列；"面向字节流"的含义是：虽然应用程序和TCP的交互时一次一个数据块(大小不等)，但TCP把应用程序交下来的数据看成仅仅是一连串的无结构的字节流，TCP并不知道所传送的字节流的含义；

#### 5.3.2 TCP的连接

TCP把连接作为最基本的抽象；TCP连接的端点叫做套接字(socket)或插口；

根据RFC793的定义：端口号拼接到(contatenated with)IP地址即构成了套接字，因此套接字的表示方法是在点分十进制的IP地址后面写上端口号，中间用冒号或逗号隔开；套接字socket = (IP地址：端口号)；

总之，TCP连接就是有协议所提供的一种抽象，虽然有时为了方便，我们也可以说，在一个应用进程和另一个应用进程之间建立了一条TCP连接，但一定要记住：TCP连接的端点是套接字，即(IP地址：端口号)，也还应记住：同一个IP地址可以由多个不同的TCP连接，而同一个端口号也可以出现在多个不同的TCP连接中；

### 5.4 可靠传输的工作原理

#### 5.4.1 停止等待协议

全双工通信的双方及时发送方也是接收方；

"停止等待"就是每发送完一个分组就停止发送，等待对方的确认，在收到确认后再发送下一个分组；

1. 无差错情况

   ![alt images](./images/微信截图_20200810105158.png) 

2. 出现差错

   ![alt images](./images/微信截图_20200810105629.png) 

   ![alt images](./images/微信截图_20200810105703.png) 

3. 确认丢失和确定迟到

   ![alt images](./images/微信截图_20200810110126.png) 

4. 信道利用率

   为了提高传输效率，发送发可以不实用低效率的停止等待协议，而是采用流水线传输，流水线传输就是发送方可连续发送多个分组，不必每发完一个分组就停顿下来等待对方的确定，这样可使信道上一直有数据不间断的传送，显然，这种传输方式可以获得很高的信道利用率，当使用流水线传输时，就要使用连续ARQ协议和滑动窗口协议；

#### 5.4.2 连续ARQ协议

![alt images](./images/微信截图_20200810151332.png) 

### 5.5 TCP报文段的首部格式

TCP虽然是面向字节流的，但TCP传送的数据单元却是报文段，一个TCP报文段分为首部和数据两部分，而TCP的全部功能都体现在它首部中各字段的作用；

![alt images](./images/微信截图_20200810152112.png) 

![alt images](./images/微信截图_20200810152251.png)

![alt images](./images/微信截图_20200810152554.png)

![alt images](./images/微信截图_20200810153422.png) 

![alt images](./images/微信截图_20200810160322.png) 

### 5.6 TCP可靠传输的实现

发送窗口的位置由窗口前沿和后沿的位置共同确定，发送窗口后沿的变化情况有两种可能，即不动(没有收到新的确认)和前移(收到新的确认)。发送窗口后沿不可能向后移动，因为不能撤销已收到的确认；发送窗口前沿通常不断向前移动，但也有可能不动，这对应于两种情况：一是没有收到新的确认，对方通知的窗口大小也不变，二是收到了新的确认但对方通知的窗口缩小了，使得发送窗口前沿正好不动；

发送窗口前沿也有可能向后收缩，这发生在对方通知的窗口缩小了，但TCP的标准强烈不赞成这样做，因为很可能发送方在收到这个通知以前已经发送了窗口中的很多数据，现在又要收缩窗口，不让发送这些数据，这样就会产生一些错误；

#### 5.6.1 以字节为单元的滑动窗口

TCP的滑动窗口是以字节为单位的；

![alt images](./images/微信截图_20200811101114.png) 

![alt images](./images/微信截图_20200811101152.png) 

![alt images](./images/微信截图_20200811101227.png) 

![alt images](./images/微信截图_20200811101905.png) 

![alt images](./images/微信截图_20200811102141.png) 

![alt images](./images/微信截图_20200811102515.png) 

#### 5.6.2 超时重传时间的选择

![alt images](./images/微信截图_20200811104031.png) 

![alt images](./images/微信截图_20200811104129.png) 

#### 5.6.3 选择确认SACK

选择确认(Selective ACK)；

### 5.7 TCP的流量控制

#### 5.7.1 利用滑动窗口实现流量控制

所谓流量控制(flow control)就是让发送方的发送速率不要太快，要让接收方来得及接收；利用滑动窗口机制可以很方便地在TCP连接上实现对发送方的流量控制；

![alt images](./images/微信截图_20200811144703.png) 

#### 5.7.2 必须考虑传输效率

在TCP的实现中广泛使用Nagle算法，算法如下：若发送应用进程把要发送的数据逐个字节地发送到TCP的发送缓存，则发送方就把第一个数据字节先发送出去，把后面到达的数据字节都缓存起来，当发送方收到对第一个字符的确定后，再把发送缓存中的所有数据组装成一个报文段发送出去，同时继续对随后到达的数据进行缓存，只有在收到对前一个报文段的确认后才继续发送下一个报文段，当数据到达快而网络速率较慢时，用这种的方法可明显减少所有的网络带宽。Nagle算法还规定，当到达的数据已达到发送窗口大小的一半或已达到报文段的最大长度时，就立即发送一个报文段；

![alt images](./images/微信截图_20200811145756.png) 

### 5.8 TCP的拥塞控制

#### 5.8.1 拥塞控制的一般原理

在计算机网络中的链路容量(即带宽)、交换结点中的缓存和处理机等，都是网络的资源，在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏，这种情况就叫做拥塞(congestion)；

拥塞控制与流量控制的关系密切，它们之间也存在着一些差别；所谓拥塞控制就是防止多多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载；拥塞控制所要做的都由一个前提，就是网络能够承受现有的网络负荷；拥塞控制是一个全局性的过程，涉及到所有的主机、所有的路由器，以及与降低网络传输性能有关的所有因素；但TCP连接的端点只要迟迟不能收到对方确认信息，就猜想在当前网络中的某处很可能发生了拥塞，但这时却无法知道拥塞到底发生在网络的何处，也无法知道发生拥塞的具体原因(是访问某个服务器的通信量过大？还是在某个地区出现自然灾害？)；

相反，流量控制往往指点对点通信量的控制，是个端到端的问题(接收端控制发送端)；流量控制所要做的就是抑制发送端发送数据的速率，以便使接收端来得及接收；

![alt images](./images/微信截图_20200811153135.png) 

#### 5.8.2 几种拥塞控制方法

1999年公布的因特网建议标准RFC2581定义了进行拥塞控制的四种算法，即慢开始(slow-start)、拥塞避免(congestion avoidance)、快重传(fast retransmit)和快恢复(fast recovery)；

1. 慢开始和拥塞避免

   ![alt images](./images/微信截图_20200811170218.png) 

   ![alt images](./images/微信截图_20200811171908.png) 

   ![alt images](./images/微信截图_20200811171951.png) 

   ![alt images](./images/微信截图_20200811172019.png) 

2. 快重传和快恢复

   ![alt images](./images/微信截图_20200811232812.png)

   ![alt images](./images/微信截图_20200811233037.png)  

   ![alt images](./images/微信截图_20200811233405.png) 

#### 5.8.3 随机早期检测RED(Random Early Detection)

![alt images](./images/微信截图_20200812091716.png) 

### 5.9 TCP的传输连接管理

![alt images](./images/微信截图_20200812091924.png) 

#### 5.9.1 TCP的连接建立

![alt images](./images/微信截图_20200812092856.png) ![alt images](./images/微信截图_20200812092926.png)

 为什么A还要发送一次确定呢？这主要是为了防止已失效的连接请求报文段突然又传送到了B，因而产生错误；

![alt images](./images/微信截图_20200812093441.png) 

#### 5.9.2 TCP的连接释放

![alt images](./images/微信截图_20200812095556.png) ![alt images](./images/微信截图_20200812095636.png) ![alt images](./images/微信截图_20200812095714.png) ![alt images](./images/微信截图_20200812095802.png) 

#### 5.9.3 TCP的有限状态机

![alt images](./images/微信截图_20200812100509.png) ![alt images](./images/微信截图_20200812100546.png) 

## 6 第六章 应用层

每个应用层都是为了解决某一类应用问题，而问题的解决又往往是通过位于不同主机中的多个应用进程之间的通信和协同工作来完成的，应用层的具体内容就是规定应用进程在通信时所遵循的协议；

应用层的许多协议都是基于客户服务器方式，即使是对等通信方式，实质上也是一种特殊的客户服务器方式，这里再明确一下，客户(client)和服务器(server)都是指通信中涉及的两个应用进程，客户服务器方式所描述的是进程之间服务和被服务的关系，这里最主要的特征就是：客户是服务请求方，服务器是服务提供方；

### 6.1 域名系统DNS

#### 6.1.1 域名系统概述

域名系统DNS(Domain Name System)是因特网使用的命名系统，用来把便与人们使用的机器名字转换为IP地址，域名系统其实就是名字系统；

![alt images](./images/微信截图_20200812104152.png) 

![alt images](./images/微信截图_20200812110135.png) 

6.1.2 因特网的域名结构

![alt images](./images/微信截图_20200812110752.png) 

![alt images](./images/微信截图_20200812111045.png) 

![alt images](./images/微信截图_20200812111941.png) 

#### 6.1.3 域名服务器

每一个区设置相应的权限域名服务器(authoritative name server)，用来保存该区中的所有主机的域名到IP地址的映射，总之，DNS服务器的管辖范围不是以"域"为单位，而是以"区"为单位，区是DNS服务器实际管辖的范围，区可能等于或小于域，但一定不可能大于域；

根据域名服务器所起的作用，可以把域名服务器划分为一下四种不同的类型：

1. 根域名服务器(root name server)：根域名服务器是最高层次的域名服务器，也是最重要的域名服务器，所有的根域名服务器都知道所有的顶级域名服务器的域名和IP地址，根域名服务器是最重要的域名服务器，因为不管是哪一个本地域名服务器，若要对因特网上任何一个域名进行解析(即转换为IP地址)，只要自己无法解析，就首先要求助于根域名服务器；
2. 顶级域名服务器(即TLD服务器)：这些域名服务器负责管理在该顶级域名服务器注册的所有二级域名，当收到DNS查询请求时，就给出相应的回答(可能是最后的结果，也可能是下一步应当找的域名服务器的IP地址)；
3. 权限域名服务器：负责一个区的域名服务器，当一个权限域名服务器还不能给出最后的查询回答时，就会告诉查询请求的DNS客户，下一步应当找哪一个权限域名服务器；
4. 本地域名服务器(local name server)：当一个主机发出DNS查询请求时，这个查询请求报文就发送给本地域名服务器，由此可看出本地域名服务器的重要性，每一个因特网服务提供者ISP，都可以拥有一个本地域名服务器，这种域名服务器有时也称为默认域名服务器；

![alt images](./images/微信截图_20200812154916.png) 

为了提高DNS查询效率，并减轻根域名服务器的负荷和减少因特网上的DNS查询报文数量，在域名服务器中广泛地使用了高速存缓(有时也称为高速缓存域名服务器)，高速缓存用来存放最近查询过的域名以及从何处获得域名映射信息的记录；

不但在本地域名服务器中需要高速缓存，在主机中也很需要，很多主机在启动时从本地域名服务器下载名字和地址的全部数据库，维护存放自己最近使用的域名的高速缓存，并且只在从缓存中找不到名字时才使用域名服务器；维护本地域名服务器数据库的主机自然应该定期地检查域名服务器以获取最新的映射信息，而且主机必须从缓存中删除无效的项，由于域名改动并不频繁，大多数网点不需花太多精力就能维护数据库的一致性；

### 6.2 文件传送协议

#### 6.2.1 FTP概述

文件传送协议FTP(File Transfer Protocol)是因特网上使用得最广泛的文件传送协议，FTP提供交互式的访问，允许客户指明文件的类型与格式(如指明是否使用ASCII码)，并允许文件具有存取权限(如访问文件的用户必须经过授权，并输入有效的口令)，FTP屏蔽了各计算机系统的细节，因而适合于在异构网络中任何计算机之间传送文件；

#### 6.2.2 FTP的基本工作原理

文件传送协议FTP只提供文件传送的一些基本服务，它使用TCP可靠的运输服务，FTP的主要功能是减少或消除在不同操作系统下处理文件的不兼容性；

#### 6.2.3 简单文件传送协议TFTP(Trivial File Transfer Protocol)

TFTP使用客户服务器方式，但它使用UDP数据报，因此TFTP需要有自己的差错改正措施，TFTP只支持文件传输而不支持交互，TFTP没有一个庞大的命令集，没有列目录的功能，也不能对用户进行身份鉴别；

### 6.3 远程中断协议TELENT

TELNET是一个简单的远程终端协议，是因特网的正式标准，又称为终端仿真协议；

![alt images](./images/微信截图_20200813110242.png) 

### 6.4 万维网WWW

6.4.1 万维网概述

万维网WWW(World Wide Web)，是一个大规模的、联机式的信息储藏所，英文简称为Web；

万维网是一个分布式的超媒体(hypermedia)系统，它是超文本(hypertext)系统的扩充，所谓超文本是包含指向其他文档的链接的文本，也就是说，一个超文本由多个信息源链接成，而这些信息源的数据实际上是不受限制的，利用一个链接可使用户找到另一个文档，而这又可链接到其他的文档(以此类推)，这些文档可以位于世界上任何一个接在因特网上的超文本系统中，超文本是万维网的基础；

超媒体与超文本的区别是文档内容不同，超文本文档仅包含文本信息，而超媒体文档还包含其他表示方式的信息，如图形、图像、声音、动画、甚至活动视频图像；

![alt images](./images/微信截图_20200813113256.png) 

#### 6.4.2 统一资源定位符URL(Uniform Resource Locator)

1. URL的格式

   统一资源定位符URL是用来表示因特网上得到的资源位置和访问这些资源的方法；这里所说的"资源"是指在因特网上可以被访问到的任何对象；

   URL相当于一个文件名在网络范围的扩展，因此，URL是与因特网相连的机器上的任何可访问对象的一个指针，由于访问不同对象所使用的协议不同，所以URL还指出读取某个对象时所使用的协议，URL的一般形式由一下四个部分组成：<协议>://<主机>:<端口>/<路径>;

   在<协议>后面是规定必须写上的格式"://"，不能省略，它的右边是第二部分<主机>，它指出这个万维网文档在哪一个主机上，这里的<主机>就是指该主机在因特网上的域名，再后面是第三部分和第四部分<端口>和<路径>，有时可省略；

2. 使用HTTP的URL

   ![alt images](./images/微信截图_20200813152931.png) 

#### 6.4.3 超文本传送协议HTTP

1. HTTP的操作过程

   ![alt images](./images/微信截图_20200813153129.png) 

   ![alt images](./images/微信截图_20200813153442.png)

   HTTP协议是无状态的(statesless)，HTTP的无状态特性简化了服务器的设计，是服务器更容易支持大量并发的HTTP请求；

   ![alt images](./images/微信截图_20200813155816.png) 

2. 代理服务器

   代理服务器(proxy server)是一种网络实体，它又称为万维网告诉缓存(Web cache)，代理服务器把最近的一些请求和响应暂存在本地磁盘中，当新请求达到时，若代理服务器发现这个请求与暂时存放的请求相同，就返回暂存的响应，而不需要按URL的地址再次去因特网访问该资源，代理服务器可在客户端或服务器端工作，也可在中间系统上工作；

   ![alt images](./images/微信截图_20200813161047.png) ![alt images](./images/微信截图_20200813161119.png) ![alt images](./images/微信截图_20200813161152.png) 

3. HTTP的报文结构

   ![alt images](./images/微信截图_20200813161915.png) 

4. 在服务器上存放用户的信息

   在RFC2109中对Cookie进行了定义，规定万维网站点可以使用Cookie来跟踪用户，Cookie愿意是"小甜饼"，目前尚无标准译名，在这里Cookie表示在HTTP服务器和客户之间传递的状态信息；

6.4.4 万维网的文档

1. 超文本标记语言HTML(HyperText Markup Language)

2. 动态万维网文档

   动态文档(dynamic document)是指文档的内容是在浏览器访问万维网服务器时才由应用程序动态创建；

   CGI程序的正式名字时CGI脚本，按照计算机科学的一般概念，"脚本"指的是一个程序，它被另一个程序(解释程序)而不是计算机的处理机来解释或执行；

3. 活动万维网文档

   实际上，Java技术是活动文档技术的一部分；

   Java技术共有三个主要组成部分：

   1）程序设计语言；

   2）运行(runtime)环境；

   3）类库(class library)；

4. 浏览器的结构

   ![alt images](./images/微信截图_20200814105452.png) ![alt images](./images/微信截图_20200814105814.png) 

#### 6.4.5 万维网的信息检索系统

1. 全文检索搜索与分类目录搜索

   在不知道要找的信息在何网点时，就要使用万维网的搜索工具，在万维网中用来进行搜索的工具叫做搜索引擎(search engine)，搜索引擎的种类很多，大体上可划分为两大类，即全文搜索引擎和分类目录搜索引擎；

   垂直搜索引擎(Vertical Search Engine)，它针对某一特定领域、特定人群或特定需求提供搜索服务，垂直搜索也是提供关键字来进行搜索的，但被放到了一个行业知识的上下文中，返回的结果更倾向于信息、消息、条目等；

   元搜索引擎(Meta Search Engine)，它把用户提交的搜索请求发送到多个独立的搜索引擎上去搜索，并把搜索结果集中统一处理，以统一的格式提供给用户，因此是搜索引擎上的搜索引擎；它的主要精力放在提供搜索速度、智能化处理搜索结构、个性化搜索功能的设置和用户检索界面的友好性上，元搜索引擎的查全率和查准率都比较高；

2. Google搜索技术的特点

### 6.5 电子邮件

#### 6.5.1 电子邮件概述

简单邮件传送协议SMTP(Simple Mail Transfer Protocol)和因特网文本报文格式(RFC822)，都是因特网的正式标准；

![alt images](./images/微信截图_20200814153235.png) 

邮件服务器需要使用两种不同的协议，一种协议用于用户代理向邮件服务器发送邮件或在邮件服务器之间发送邮件，如SMTP协议，而另一种协议用于用户代理从邮件服务器读取邮件，如邮局协议POP3；

![alt images](./images/微信截图_20200814154710.png) 

TCP/IP体系的电子邮件系统规定电子邮件地址(e-mail address)的格式如下：收件人邮箱名@邮箱所在主机的域名；

#### 6.5.2 简单邮件传送协议SMTP

1. 连接建立

   ![alt images](./images/微信截图_20200814161103.png) ![alt images](./images/微信截图_20200814161130.png) 

2. 邮件传送

   ![alt images](./images/微信截图_20200814161430.png) 

3. 连接释放

   ![alt images](./images/微信截图_20200814161511.png) 

#### 6.5.3 电子邮件的信息格式

![alt images](./images/微信截图_20200814161952.png) 

#### 6.5.4 邮件读取协议POP3和IMAP

现在常用的邮件读取协议有两个，即邮局协议第3个版本POP3和网际报文存取协议IMAP(Internet Message Access Protocol)；

不要把邮件读取协议POP或IMAP与邮件传送协议SMTP弄混，发件人的用户代理向发送方邮件服务器发送邮件，以及发送方邮件服务器向接收方邮件服务器发送邮件，都是使用SMTP协议，而POP或IMAP则是用户代理从接收方邮件服务器上读取邮件所使用的协议；

6.5.5 基于万维网的电子邮件

#### 6.5.6 通用因特网邮件扩充MIME

1. MIME概述

   通用因特网邮件扩充MIME并没有改动或取代SMTP，MIME的意图是继续使用目前的RFC822格式，但增加了邮件主体的结构，并定义了传送非ASCII码的编码规则，也就是说，MIME邮件可在现有的邮件程序和协议下传送；

2. 内容传送编码(Content-Transfer-Encoding)

3. 内容类型

### 6.6 动态主机配置协议DHCP(Dynamic Host Configuration Protocol)

连接到因特网的计算机的协议软件需要配置的项目包括:

1）IP地址；

2）子网掩码；

3）默认路由器的IP地址；

4）域名服务器的IP地址；

![alt images](./images/微信截图_20200815231237.png) ![alt images](./images/微信截图_20200815231307.png) ![alt images](./images/微信截图_20200815231336.png)

### 6.7 简单网络管理协议SNMP(Simple Network Management Protocol)

#### 6.7.1 网络管理的基本概念

网络管理包括对硬件、软件和人力的使用、综合与协调，以便对网络资源进行监视、测试、配置、分析、评价和控制，这样就能以合理的价格满足网络的一些需求，如实时运行性能、服务质量等，网络管理常简称为网管；

![alt images](./images/微信截图_20200815231925.png) ![alt images](./images/微信截图_20200815232316.png) 

SNMP最重要的指导思想就是要尽可能简单，SNMP的基本功能包括监视网络性能、检测分析网络差错和配置网络设备等；在网络正常工作时，SNMP可实现统计、配置和测试等功能，当网络出故障时，可实现各种差错检测和恢复功能；SNMPv3最大的改进就是安全特性，也就是说，只有被授权的人员才有资格执行网络管理的功能(如关闭某一条链路)和读取有关网络管理的信息(如读取一个配置文件的内容)；

![alt images](./images/微信截图_20200815233051.png) ![alt images](./images/微信截图_20200815233224.png) 

#### 6.7.2 管理信息结构SMI(Structure of Management Information)

管理信息结构SMI是SNMP的重要组成部分，SMI的功能应当有三个，即规定

1）被管对象应怎样命名；

2）用来存储被管对象的数据类型有哪些种；

3）在网络上传送的管理数据应如何编码；

1. 被管对象的命名

   SMI规定，所有的被管对象都必须处在对象命名树(object naming tree)上；

   ![alt images](./images/微信截图_20200817091152.png) 

2. 被管对象的数据类型

   任何数据都具有两种重要的属性，即值(value)与类型(type)；

   ![alt images](./images/微信截图_20200817092103.png) 

3. 编码方法

#### 6.7.3 管理信息库MIB

所谓"管理信息"就是指在因特网的网管框架中的被管对象的集合；被管对象必须维持可供管理程序读写的若干控制和状态信息，这些被管对象构成了一个虚拟的信息存储器，所以才称为管理信息库MIB；

6.7.4 SNMP的协议数据单元和报文

### 6.8 应用进程跨越网络的通信

#### 6.8.1 系统调用和应用编程接口

大多数操作系统使用系统调用(system call)的机制在应用程序和操作系统之间传递控制权，对程序员来说，系统调用和一般程序设计中的函数调用非常相似，只是系统调用是将控制权传递给了操作系统；

当某个应用进程启动系统调用时，控制权就从应用进程传递给了系统调用接口，此接口再把控制权传递给计算机的操作系统，操作系统把这个调用转给某个内部过程，并执行所请求的操作，内部过程一旦执行完毕，控制权就又通过系统调用接口返回给应用程序，总之，只要应用程序需要从操作系统获得服务，就要把控制权传递给操作系统，操作系统在执行必要的操作后把控制权返回给应用进程，因此，系统调用接口实际上就是应用进程的控制权和操作系统的控制权进行转换的一个接口，由于应用程序在使用系统调用之前要编写一些程序，特别是需要设置系统调用中的很多参数，因此这种系统调用接口又称为应用编程接口(application Programming Interface)；API从编程设计的角度定义了很多标准的系统调用函数，应用程序只要使用标准的系统调用函数就可得到系统操作的服务，因此冲程序设计的角度看，也可以把API看成是应用程序和操作系统之间的接口；

当应用进程(客户或服务器)需要使用网络进行通信时，必须首先发出socket系统调用，请求操作系统为其创建一个"套接字"，这个调用的实际效果是请求操作系统把网络听信所需要的一些系统资源(存储器空间、CPU时间、网络带宽等)分配给该应用进程，操作系统为这些资源的总和用一个叫做套接字描述符(socket descriptor)的号码(小的整数)来表示，然后把这个套接字描述符返回给应用进程，此后，应用进程所进行的网络操作(建立连接、收发收据、调整网络通信参数等)都必须使用这个套接字描述符，所以，几乎所有的网络系统调用都把这个套接字描述符作为套接字的很多参数中的第一个参数，在处理系统调用的时候，通过套接字描述符，操作系统就可以识别出应该使用那些资源来完成应用进程所请求服务，通信完毕后，应用进程通过一个关闭套接字的close系统调用通知操作系统回收与该套接字描述符相关的所有资源，因此可见，套接字是应用进程为了获得网络通信服务而与操作系统进行交互时使用的一种机制；

#### 6.8.2 几种常用的系统调用

1. 连接建立阶段
2. 数据传送阶段
3. 连接释放阶段

## 7 第七章 网络安全

### 7.1 网络安全问题概述

#### 7.1.1 计算机网络面临的安全性威胁

计算机网络上的通信面临以下的四种威胁：

1）截获(interception)，攻击者从网络上窃听他人的通信内容；

2）中断(interruption)，攻击者有意中断他人在网络上的通信；

3）篡改(modification)，攻击者故意篡改网络上传送的报文；

4）伪造(fabrication)，攻击者伪造信息在网络上传送；

上述四种威胁可划分为两大类，即被动攻击和主动攻击，在上述情况中，截获信息的攻击称为被动攻击，而中断、篡改和伪造的攻击称为主动攻击；

所有主动攻击都是上述几种方法的某种组合，但从类型上看，主动攻击又可进一步划分为三种，即：

1）更改报文流；

2）拒绝服务；

3）伪造连接初始化；

![alt images](./images/微信截图_20200817211016.png) 

#### 7.1.2 计算机网络安全的内容

1. 保密性，为用户提供安全可靠的保密通信时计算机网络安全最为重要的内容；
2. 安全协议的设计，目前的安全协议的设计方面，主要是针对具体的攻击(如假冒)设计安全通信协议，另一种是用经验来分析协议的安全性；
3. 访问控制，访问控制(access control)也叫做存取控制或接入控制；

所有上述计算机网络安全的内容都与密码技术紧密相关；

#### 7.1.3 一般的数据加密模型

### 7.2 两类密码体制

#### 7.2.1 对称密钥密码体制

所谓对称密匙加密体制，即加密密匙与解密密匙是相同的密码体制；

数加密标准DES属于对称密匙加密体制；

![alt images](./images/微信截图_20200818112451.png) 

#### 7.2.2 公钥密码体制

公钥密码体制使用不同的加密密钥与解密密钥；

任何加密方法的安全性取决于密钥的长度，以及攻破密文所需的计算量，而不是简单地取决于加密的体制(公钥密码体制或传统加密体制)；

![alt images](./images/微信截图_20200818142322.png) 

### 7.3 数字签名

数字签名必须保证能够实现以下三点功能：

1）接受者能够核实发送者对报文的签名，也就是说，接受者能够确信该报文的确是发送者发送的，其他人无法伪造对报文的签名，这就叫做报文鉴别；

2）接受者确信收到的数据和发送者发送的完全一样而没有被篡改过，这就叫做报文的完整性；

3）发送者事后不能抵赖对报文的签名，这就叫做不否认；

![alt images](./images/微信截图_20200818143436.png) ![alt images](./images/微信截图_20200818143645.png) 

### 7.4 鉴别

鉴别(authentication)和加密并不相同，鉴别是要验证通信的对方的确自己所要通信的对象，而不是其他冒充者，鉴别可分为两种，一种是报文鉴别，即所收到的报文的确是报文的发送者所发送的，而不是其他人伪造的或篡改的，另一种则是实体鉴别，实体可以是一个人，也可以是一个进程(客户或服务器)；

请注意，鉴别与授权(authorization)是不同的概念，授权涉及到的问题是：所进行的过程是否被允许(如是否可以对文件进行读或写)；

#### 7.4.1 报文鉴别

![alt images](./images/微信截图_20200818150759.png) ![alt images](./images/微信截图_20200818151228.png) ![alt images](./images/微信截图_20200818151536.png) 

#### 7.4.2 实体鉴别

报文鉴别是对每一个收到的报文都要鉴别报文的发送者，而实体鉴别是在系统接入的全部持续时间内对和自己通信对方实体只需验证一次；

### 7.5 密匙分配

#### 7.5.1 对称密匙的分配

#### 7.5.2 公钥的分配

### 7.6 因特网使用的安全协议

#### 7.6.1 网络层安全协议

1. IPsec与安全关联SA

   IPsec就是"IP 安全(Security)协议"的缩写；

   ![alt images](./images/微信截图_20200818232707.png) 

2. 鉴别首部协议AH

3. 封装安全有效载荷协议ESP

#### 7.6.2 运输层安全协议

![alt images](./images/微信截图_20200818233356.png) 

1. 安全套接层SSL

   ![alt images](./images/微信截图_20200818233725.png) ![alt images](./images/微信截图_20200818234139.png) ![alt images](./images/微信截图_20200818234210.png) 

2. 安全电子交易SET

   ![alt images](./images/微信截图_20200818234401.png) 

7.6.3 应用层的安全协议

1. PGP协议

   ![alt images](./images/微信截图_20200818235119.png) ![alt images](./images/微信截图_20200818235146.png) 

2. PEM协议

   ![alt images](./images/微信截图_20200818235322.png) 

### 7.7 链路加密与端到端加密

#### 7.7.1 链路加密

![alt images](./images/微信截图_20200819090757.png) 

#### 7.7.2 端到端加密

![alt images](./images/微信截图_20200819091703.png) ![alt images](./images/微信截图_20200819091732.png) 

### 7.8 防火墙

![alt images](./images/微信截图_20200819092917.png) ![alt images](./images/微信截图_20200819092950.png) 

## 8 第八章 因特网上的音频/视频服务

### 8.1 概述

计算机网络最初是为传送数据设计的，因特网IP层提供的"尽最大努力交付"服务以及每一个分组独立交付的策略，对传送数据信息十分合适，因特网使用的TCP协议可以很好地解决IP层不能可通可靠交付的这一问题；

多媒体信息(包括声音和图像信息)与不包括声音的图像的数据信息有很大的区别，其中最主要的两个特点如下：

1）多媒体信息的信息量往往很大；

2）在传输多媒体数据时，对时延和时延抖动有较高的要求；

![alt images](./images/微信截图_20200819143724.png) 

### 8.2 流式存储音频/视频

#### 8.2.1 具有元文件的万维网服务器

![alt images](./images/微信截图_20200819145226.png) ![alt images](./images/微信截图_20200819145251.png) 

#### 8.2.2 媒体服务器

![alt images](./images/微信截图_20200819155804.png) 

#### 8.2.3 实时流式协议RTSP

8.3 交互式音频/视频

#### 8.3.1 IP电话概述

1. 狭义的和广义的IP电话

2. IP电话网关

3. IP电话的通信质量

   IP电话的通话质量主要由两个因素决定：一个是通话双方端到端的时延和时延抖动，另一个是语音分组的丢失率，但这两个因素都是不确定的，而是取决于当时网络上的通信量；

#### 8.3.2 IP电话所需要的几种应用协议

#### 8.3.3 实时运输协议RTP

实时运输协议RTP(Real-time Transport Protocol)，为实时应用提供端到端的运输，但不提供任何服务质量的保证；

#### 8.3.4 实时运输控制协议RTCP

实时运输控制协议(RTP Control Protocol)是与RTP配合使用的协议，其主要功能是：服务质量的监视与反馈、媒体间的同步(如某一个RTP发送的声音和图像的配合)，以及多播组中成员的标志；

#### 8.3.5 H.323

8.3.6 会话发送协议SIP

### 8.4 改进"尽最大努力交付"的服务

#### 8.4.1 使因特网提供服务质量

为了使因特网能够提供一定的服务质量，应当设法增加一些机制，即：分组的分类、管制、调度以及呼叫接纳；

#### 8.4.2 调度和管制机制

1. 调度机制

   这里所说的"调度"就是指排队的规则，如果不采用专门的调度机制，那么在路由器的队列采用的默认排队规则就是先进先出FIFO(First In First Out)，当队列已满时，后到达的分组就被丢弃。先进先出的最大缺点是不能区分时间敏感分组和一般数据分组，并且也不公平，因为这使得排在长分组后面的短分组要等待很长的时间；

   按优先级排队；

   加权公平排队WFQ(Weighted Fair Queuing)；

2. 管制机制

   对一个数据流，我们可以根据以下三个方面进行管制；

   1）平均速率，网络需要控制一个数据流的平均速率，这里的平均速率是指在一定的时间间隔内通过的分组数；

   2）峰值速率，峰值速率限制了数据流在非常短的时间间隔内的流量，峰值速率也同时受到链路带宽的限制；

   3）突发长度，网络也限制在非常短的时间间隔内连续注入到网络中的分组数；

   ![alt images](./images/微信截图_20200820150653.png)

3. 漏桶机制与加权公平排队相结合

#### 8.4.3 综合服务IntServ与资源预留协议RSVP

#### 8.4.4 区分服务DiffServ

1. 区分服务的基本概念
2. 每跳行为PHB

## 9 无线网络

### 9.1 无线局域网WLAN

无线局域网常见写为WLAN(Wireless Local Area Network)；

#### 9.1.1 无线局域网的组成

无线局域网可分为两大类，第一类是有固定基础设施的，第二类是无固定基础设置的，所谓"固定基础设施"是指预先建立起来的、能够覆盖一定地址范围的一批固定基站；

1. IEEE802.11

   凡使用802.11系列协议的局域网又称为WI-FI(Wireless-Fidelity)，意思是"无线保真度"，在很多文献中，WI-FI几乎成为了无线局域网WLAN的同义词；

   ![alt images](./images/微信截图_20200820172422.png) 

2. 移动自组网络

   无固定基础设施的无线局域网，叫做自组网络(ad hoc network)；

   移动自组网络也就是移动分组无线网络；

#### 9.1.2 802.11局域网的物理层

![alt images](./images/微信截图_20200821095226.png) 

#### 9.1.3 802.11局域网的MAC层协议

1. CSMA/CA协议

   CSMA/CD有两个要点，一是发送前先检测信道，信道空闲就立即发送，信道忙就随机推迟发送，二是边发送边检测信道，一发现碰撞就立即停止发送；因此偶尔发生的碰撞并不会使局域网的运行效率降低很多；

   802.11委员会对CSMA/CD协议进行了修改，把碰撞检测改为碰撞避免AC(Collision Avoidance)，这样，802.11局域网就是用CSMA/CA协议，碰撞避免的思路是：协议的设计要尽量减少碰撞发生的概率；请注意，在无线局域网中，即使在发送过程中发生了碰撞，也要把整个帧发送完毕，因此在无线局域网中一旦发生碰撞，在这个帧的发送时间内信道资源都被浪费了；

   ![alt images](./images/微信截图_20200821102920.png) 

2. 对信道进行预约

9.1.4 802.11局域网的MAC帧

![alt images](./images/微信截图_20200821105056.png) 

1. 关于802.11数据帧的地址
2. 序号控制字段、持续期字段和帧控制字段

### 9.2 无线个人区域网WPAN

无线个人区域网(Wireless Personal Area Network)就是在个人工作地方把属于个人使用的电子设备(如便携式电脑、掌上电脑、便携式打印机以及蜂窝电话等)用无线技术连接起来自组网络，不需要使用接入点AP，整个网络的范围大约在10m左右；请注意，无线个人区域网WPAN和个人区域网PAN(Personal Area Network)并不完全等同，因为PAN不一定都是使用无线连接的；

WPAN是以个人为中心来使用的无线个人区域网，它实际上就是一个低功率、小范围、低速率的低价格的电缆替代技术，但WLAN却是同时为许多用户服务的无线局域网，它是一个大功率、中等范围、高速率的局域网；

1. 蓝牙系统
2. 低速WPAN
3. 高速WPAN

### 9.3 无线城域网WMAN

无线城域网(Wireless Metropolitan Area Network)；

## 10 下一代因特网

### 10.1 下一代网际协议IPv6(IPng)

#### 10.1.1 解决IP地址耗尽的措施

![alt images](./images/微信截图_20200821155640.png) ![alt images](./images/微信截图_20200821155717.png) 

#### 10.1.2 IPv6的基本首部

![alt images](./images/微信截图_20200821160421.png) 

![alt images](./images/微信截图_20200821160648.png) ![alt images](./images/微信截图_20200821164104.png) ![alt images](./images/微信截图_20200821164131.png) 

#### 10.1.3 IPv6的扩展首部

1. 扩展首部及下一个首部字段

   IPv4的数据报如果在首部中使用了选项，那么沿数据报传送的路径上每一个路由器都必须对这些选项一一进行检查，这就降低了路由器处理数据报的速度，然而实际上很多的选项在途中的路由器上是不需要检查的(因为不需要使用这些选项的信息)；IPv6把原来IPv4首部中选项的功能都放在扩展首部中，并把扩展首部留给路径两端的源点和终点的主机来处理，而数据报途中经过的路由器都不处理这些扩展首部(只有一个首部例外，即逐跳选项扩展首部)，这样就大大提高了路由器的处理效率；

   ![alt images](./images/微信截图_20200822091752.png) ![alt images](./images/微信截图_20200822092014.png) 

2. 扩展首部举例

#### 10.1.4 IPv6的地址空间

1. 地址的类型与地址空间

   一般来说，一个IPv6数据表的目的地址可以是以下三种基本类型地址之一：

   1）单播(unicast)，单播就是传统的点对点通信；

   2）多播(multicast)，多播就是一点对多点的通信，数据报发送到一组计算机中的每一个，IPv6没有采用广播的术语，而是将广播看作多播的一个特例；

   3）任播(anycast)，这是IPv6增加的一种类型，任播的终点是一组计算机，但数据报只交付给其中的一个，通常是距离最近的一个；

   ![alt images](./images/微信截图_20200822094228.png) ![alt images](./images/微信截图_20200822094534.png) 

2. 地址空间的分配

3. 特殊地址

4. 全球单播地址的等级结构

   ![alt images](./images/微信截图_20200822095830.png) 

#### 10.1.5 从IPv4向IPv6过渡

1. 双协议栈

   双协议栈(dual stack)是指在完全过渡到IPv6之前，使一部分主机(或路由器)装有两个协议栈，一个IPv4和一个IPv6；

   双协议栈主机使用域名系统DNS查询知道采用哪一种地址，若DNS返回的是IPv4地址，双协议栈的源主机就是用IPv4地址，但当DNS返回的是IPv6地址，源主机就使用IPv6地址；

2. 隧道技术

   向IPv6过渡的另一个方法是隧道技术(tunneling)，这种方法的要点就是在IPv6数据报要进入IPv4网络时，将IPv6数据报封装称为IPv4数据报(整个的IPv6数据报变成了IPv4数据报的数据部分)，然后，IPv6数据报就在IPv4网络的隧道中传输，当IPv4数据报离开IPv4网络中的隧道时再把数据部分(即原来的IPv6数据报)交给主机的IPv6协议栈；

   ![alt images](./images/微信截图_20200822102049.png) 

#### 10.1.6 ICMPv6

![alt images](./images/微信截图_20200822102820.png) ![alt images](./images/微信截图_20200822105753.png) 

### 10.2 多协议标记交换MPLS

#### 10.2.1 MPLS的产生背景

![alt images](./images/微信截图_20200822110613.png) 

10.2.2 MPLS的工作原理

1. 基本工作过程

   ![alt images](./images/微信截图_20200822112513.png) ![alt images](./images/微信截图_20200822142549.png) ![alt images](./images/微信截图_20200822142951.png) 

2. 转发等价类FEC

#### 10.2.3 MPLS首部的位置与格式

![alt images](./images/微信截图_20200822144303.png) 

### 10.3 P2P文件共享

---------------------------------------------------------完结---------------------------------------------------------



----------------------------------------------------SQL基础教程第2版 开始-------------------------------------------

# SQL基础教程第2版(20201020-20201026)

## 第0章 绪论-搭建SQL的学习环境

## 第1章 数据库和SQL

### 1.1 数据库是什么

#### 1.1.1 我们身边的数据库

#### 1.1.2 为什么DBMS那么重要

#### 1.1.3 DBMS的种类

### 1.2 数据库的结构

#### 1.2.1 RDBMS的常见系统结构

#### 1.2.2 表的结构

### 1.3 SQL概要

#### 1.3.1 标准SQL

#### 1.3.2 SQL的基本书写规则

### 1.4 表的创建

#### 1.4.1 表的内容的创建

#### 1.4.2 数据库的创建(CREATE TABLEBASE语句)

#### 1.4.3 表的创建(CREATE TABLE语句)

#### 1.4.4 命名规则

#### 1.4.5 数据类型的指定

#### 1.4.6 约束的设置

### 1.5 表的删除和更新

#### 1.5.1 表的删除(DROP TABLE语句)

#### 1.5.2 表定义的更新(ALTER TABLE语句)

#### 1.5.3 向Product表中插入数据

## 第2章 查询基础

### 2.1 SELECT语句基础

#### 2.1.1 列的查询

#### 2.1.2 查询出表中所有的列

#### 2.1.3 为列设定别名

#### 2.1.4 常数的查询

#### 2.1.5 从结果中删除重复行

#### 2.1.6 根据WHERE语句来选择记录

#### 2.1.7 注释的书写方法

### 2.2 算术运算符和比较运算符

#### 2.2.1 算术运算符

#### 2.2.2 需要注意NULL

#### 2.2.3 比较运算符

#### 2.2.4 对字符串使用不等号时的注意事项

#### 2.2.5 不能对NULL使用比较运算符

### 2.3 逻辑运算符

#### 2.3.1 NOT运算符

#### 2.3.2 AND运算符和OR运算符

#### 2.3.3 通过括号强化处理

#### 2.3.4 逻辑运算符和真值

#### 2.3.5 含有NULL时的真值

## 第3章 聚合与排序

### 3.1 对表进行聚合查询

#### 3.1.1 聚合函数

#### 3.1.2 计算表中数据的行数

#### 3.1.3 计算NULL之外的数据的行数

#### 3.1.4 计算合计值

#### 3.1.5 计算平均值

#### 3.1.6 计算最大值和最小值

#### 3.1.7 使用聚合函数删除重复值(关键字DISTINCT)

### 3.2 对表进行分组

#### 3.2.1 GROUP BY字句

#### 3.2.2 聚合键中包含NULL的情况

#### 3.2.3 使用WHERE子句时GROUP BY子句的执行结果

#### 3.2.4 与聚合函数和GROUP BY子句有关的常见错误

### 3.3 为聚合结果指定条件

#### 3.3.1 HAVING子句

#### 3.3.2 HAVING子句的构成要素

#### 3.3.3 相对于HAVING子句，更适合写在WHERE子句中的条件

### 3.4 对查询结果进行排序

#### 3.4.1 ORDER BY子句

#### 3.4.2 指定升序或降序

#### 3.4.3 指定多个排序键

#### 3.4.4 NULL的顺序

#### 3.4.5 在排序键中使用显示用的别名

#### 3.4.6 ORDER BY子句中可以使用的列

#### 3.4.7 不要使用编号

## 第4章 数据更新

### 4.1 数据的插入(INSERT语句的使用方法)

#### 4.1.1 什么是INSERT

#### 4.1.2 INSERT语句的基本语法

#### 4.1.3 列清单的省略

#### 4.1.4 插入NULL

#### 4.1.5 插入默认值

#### 4.1.6 从其他表中复制的数据

### 4.2 数据的删除(DELETE语句的使用方法)

#### 4.2.1 DROP TABLE语句和DELETE语句

#### 4.2.2 DELETE语句的基本语法

#### 4.2.3 指定删除对象的DELETE语句(搜索型DELETE)

### 4.3 数据的更新(UPDATE语句的使用方法)

#### 4.3.1 UPDATE语句的基本语法

#### 4.3.2 指定条件的UPDATE语句(搜索型UPDATE)

#### 4.3.3 使用NULL进行更新

#### 4.3.4 多列更新

### 4.4 事务

#### 4.4.1 什么是事务

#### 4.4.2 创建事务

#### 4.4.3 ACID特性

## 第5章 复杂查询

### 5.1 视图

![alt images](./images/微信截图_20201020192630.png) 

#### 5.1.1 视图和表

![alt images](./images/微信截图_20201020192911.png) 

#### 5.2.2 创建视图的方法

#### 5.2.3 视图的限制1-定义视图时不能使用ORDER BY字句

#### 5.2.4 视图的限制2-对视图进行更新

#### 5.2.5 删除视图

### 5.2 子查询

![alt images](./images/微信截图_20201020194421.png) 

#### 5.2.1 子查询和视图

![alt images](./images/微信截图_20201020194838.png) 

#### 5.2.2 子查询的名称

#### 5.2.3 标量子查询

#### 5.2.4 标量子查询的书写位置

#### 5.2.5 使用标量子查询时的注意事项

### 5.3 关联子查询

#### 5.3.1 普通的子查询和关联子查询的区别

#### 5.3.2 关联子查询也是用来对集合进行切分的

#### 5.3.3 组合条件一定要写在子查询中

## 第6章 函数、谓词、CASE表达式

### 6.1 各种各样的函数

#### 6.1.1 函数的种类

![alt images](./images/微信截图_20201022192547.png) 

#### 6.1.2 算术函数

![alt images](./images/微信截图_20201022192458.png) 

##### 6.1.2.1 ABS-绝对值

![alt images](./images/微信截图_20201022192623.png) 

##### 6.1.2.2 MOD-求余

![alt images](./images/微信截图_20201022192646.png) 

##### 6.1.2.3 ROUND-四舍五入

![alt images](./images/微信截图_20201022192715.png) 

#### 6.1.3 字符串函数

##### 6.1.3.1 ||-拼接

![alt images](./images/微信截图_20201022192946.png) 

##### 6.1.3.2 LENGTH-字符串长度

![alt images](./images/微信截图_20201022193009.png) 

##### 6.1.3.3 LOWER-小写转换

![alt images](./images/微信截图_20201022193031.png) 

##### 6.1.3.4 REPLACE-字符串的替换

![alt images](./images/微信截图_20201022193051.png) 

##### 6.1.3.5 SUBSTRING-字符串的截取

![alt images](./images/微信截图_20201022193143.png) 

##### 6.1.3.6 UPPER-大写转换

![alt images](./images/微信截图_20201022193203.png) 

#### 6.1.4 日期函数

##### 6.1.4.1 CURRENT_DATE-当前日期

![alt images](./images/微信截图_20201022193509.png) 

##### 6.1.4.2 CURRENT_TIME-当前时间

![alt images](./images/微信截图_20201022193533.png) 

##### 6.1.4.3 CURRENT_TIMESTAMP-当前日期和时间

![alt images](./images/微信截图_20201022193556.png) 

##### 6.1.4.4 EXTRACT-截取日期元素

![alt images](./images/微信截图_20201022193619.png) 

#### 6.1.5 转换函数

##### 6.1.5.1 CAST-类型转换

![alt images](./images/微信截图_20201022194044.png) 

##### 6.1.5.2 COALESCE-将NULL转换为其他值

![alt images](./images/微信截图_20201022194107.png) 

### 6.2 谓词

#### 6.2.1 什么是谓词

#### 6.2.2 LIKE谓词-字符串的部分一致查询

#### 6.2.3 BETWEEN谓词-范围查询

#### 6.2.4 IS NULL、IS NOT NULL-判断是否为NULL

#### 6.2.5 IN谓词-OR的简便用法

#### 6.2.6 使用子查询作为IN谓词的参数

![alt images](./images/微信截图_20201022194405.png) 

#### 6.2.7 EXIST谓词

![alt images](./images/微信截图_20201022194441.png) 

### 6.3 CASE表达式

#### 6.3.1 什么是CASE表达式

#### 6.3.2 CASE表达式的语法

#### 6.3.3 CASE表达式的使用方法

![alt images](./images/微信截图_20201023111743.png) 

![alt images](./images/微信截图_20201023111843.png) ![alt images](./images/微信截图_20201023111912.png) 

## 第7章 集合运算

![alt images](./images/微信截图_20201023112550.png) 

### 7.1 表的加减法

#### 7.1.1 什么是集合运算

#### 7.1.2 表的加法-UNION

#### 7.1.3 集合运算的注意事项

![alt images](./images/微信截图_20201023145806.png) ![alt images](./images/微信截图_20201023145855.png) ![alt images](./images/微信截图_20201023145831.png)

#### 7.1.4 包含重复行的集合运算-ALL选项

#### 7.1.5 选取表中公共部分-INTERSECT

![alt images](./images/微信截图_20201023150308.png) 

#### 7.1.6 记录的减法-EXCEPT

![alt images](./images/微信截图_20201023150332.png) 

### 7.2 联结(以列为单位对表进行联结)

![alt images](./images/微信截图_20201023150500.png) 

#### 7.2.1 什么是联结

#### 7.2.2 内联结-INNER JOIN

![alt images](./images/微信截图_20201023150555.png) 

#### 7.2.3 外联结-OUTER JOIN

![alt images](./images/微信截图_20201023150721.png) ![alt images](./images/微信截图_20201023150745.png) 

#### 7.2.4 3张以上的表的联结

#### 7.2.5 交叉联结-CROSS JOIN

![alt images](./images/微信截图_20201026092002.png) 

#### 7.2.6 联结的特定语法和过时语法

## 第8章 SQL高级处理

### 8.1 窗口函数

![alt images](./images/微信截图_20201026093638.png) 

#### 8.1.1 什么是窗口函数

![alt images](./images/微信截图_20201026093710.png) 

#### 8.1.2 窗口函数的语法

![alt images](./images/微信截图_20201026093820.png) 

#### 8.1.3 语法的基本使用方法-使用RANK函数

#### 8.1.4 无需指定PARTITION BY

#### 8.1.5 专用窗口函数的种类

![alt images](./images/微信截图_20201026094034.png) 

#### 8.1.6 窗口函数的使用范围

#### 8.1.7 作为窗口函数使用的聚合函数

#### 8.1.8 计算移动平均

#### 8.1.9 两个ORDER BY

### 8.2 GROUP BY运算符

#### 8.2.1 同时计算出合计值

#### 8.2.2 ROLLUP-同时得出合计和小计

#### 8.2.3 GROUPING函数-让NULL更加容易分辨

#### 8.2.4 CUBE-用数据来搭积木

#### 8.2.5 GROUPING SETS-取得期望的积木

## 第9章 通过应用程序连接数据库

### 9.1 数据库世界和应用程序世界的连接

#### 9.1.1 数据库和应用程序之间的关系

#### 9.1.2 驱动-两个世界之间的桥梁

#### 9.1.3 驱动的种类

![alt images](./images/微信截图_20201026225529.png) 

### 9.2 Java基础知识

#### 9.2.1 第一个程序Hello,world

#### 9.2.2 编译和程序执行

#### 9.2.3 常见错误

### 9.3 通过Java连接PostgreSQL

#### 9.3.1 执行SQL语句的Java程序

#### 9.3.2 Java是如何从数据库中获取数据的呢

#### 9.3.3 执行连接数据库的程序

#### 9.3.4 选取表中的数据

#### 9.3.5 更新表中的数据

#### 9.3.6 小结



# 编程隐匿在计算机软硬件背后的语言(20201028-)



======================================================================================

# 银行软件开发必备知识(20201113-)

## 上篇 金融业务知识

## 第一章 背景知识

### 第一节 我国金融体系间接

#### 金融市场

#### 金融主题



======================================================================================

# spring揭秘(20201216-)

## 第一部分 掀起Spring的盖头来

### 第1章 Spring框架的由来

#### 1.1 Spring之崛起

#### 1.2 Spring框架概述

#### 1.3 Spring大观园

#### 1.4 小结

## 第二部分 Spring的Ioc容器

### 第2章 Ioc的基本概念

#### 2.1 我们的理想是：让别人为你服务

#### 2.2 手语，呼喊，还是心有灵犀

##### 2.2.1 构造方法注入

##### 2.2.2 setter方法注入

##### 2.2.3 接口注入

##### 2.2.4 三种注入方式的比较

#### 2.3 Ioc的附加值

#### 2.4 小结

### 第3章 掌管大局的Ioc Service Provider

#### 3.1 Ioc Service Provider的职责

#### 3.2 运筹帷幄的秘密-Ioc Service Provider如何管理对象间的依赖关系

##### 3.2.1 直接编码方式

##### 3.2.2 配置文件方式

##### 3.2.3 元数据方式

#### 3.3 小结

### 第4章 Spring的Ioc容器之BeanFactory

#### 4.1 拥有BeanFactory之后的生活

#### 4.2 BeanFactory的对象注册与依赖绑定方式

##### 4.2.1 直接编码方式

##### 4.2.2 外部配置文件方式

1. Properties配置格式的加载
2. XML配置格式的加载

##### 4.2.3 注解方式

#### 4.3 BeanFactory的XML之旅

##### 4.3.1 <beans>和<bean>

1. <beans>之唯我独尊
2. <description>、<import>和<alias>

##### 4.3.2 孤孤单单一个人

- id属性
- class属性

##### 4.3.3 Help Me，Help You

1. 构造方法注入的XML之道
2. setter方法注入的XML之道
3. <property>和<constructor-arg>中可用的配置项
4. depends-on
5. autowire
6. dependency-check
7. lazy-init

##### 4.3.4 继承？我也会！

##### 4.3.5 bena的scope

1. singleton
2. prototype
3. request、session和global session
4. 自定义scope类型

##### 4.3.6 工厂方法与FactoryBean

1. 静态工厂方法(Static Factory Method)
2. 非静态工厂方法(Instance Factrory Method)
3. FactoryBean

##### 4.3.7 偷梁换柱之术

1. 方法注入
2. 殊途同归
3. 方法替换

#### 4.4 容器背后的秘密

![image-20201223145116586](images/image-20201223145116586.png)

##### 4.4.1 "战略性观望"

1. 容器启动阶段
2. Bean实例化阶段

##### 4.4.2 插手"容器的启动"

1. PropertyPlaceholderConfigurer
2. PropertyOverrideConfigurer
3. CustomEditorConfigurer

##### 4.4.3 了解bean的一生

1. Bean的实例化与BeanWrapper
2. 各色的Aware接口
3. BeanPostProcessor
4. InitializingBean和init-method
5. DisposableBean与destroy-method

#### 4.5 小结

### 第5章 Spring IoC容器ApplicationContext

#### 5.1 统一资源加载策略(I18n MessageSource)

##### 5.1.1 Spring中的Resource

##### 5.1.2 ResourceLoader，"更广义的URL"

1. 可用的ResourceLoader
   - DefaultResourceLoader
   - FileSystemResourceLoader
2. ResourcePatternResolver-批量查找的ResourceLoader
3. 回顾与展望

![image-20201227145410349](images/image-20201227145410349.png)

##### 5.1.3 ApplicationContext与ResourceLoader

1. 扮演ResourceLoader的角色
2. ResourceLoader类型的注入
3. Resource类型的注入
4. 在特定的情况下，ApplicationContext的Resource加载行为

#### 5.2 国际化信息支持

##### 5.2.1 Java SE提供的国际化支持

1. Locale
2. ResourceBundle

##### 5.2.2 MessageSource与ApplicationContext

1. 可用的MessageSource实现
2. MessageSourceAware和MessageSource的 注入

#### 5.3 容器内部事件发布

##### 5.3.1 自定义事件发布

- 给出自定义事件类型
- 实现针对自定义事件类的事件监听器接口
- 组合事件类和监听器，发布事件
- 具体时点上自定义事件的发布
- 自定义事件监听器的管理

##### 5.3.2 Spring的容器内事件发布类结构分析

- ApplicationEvent
- ApplicationListener
- ApplicationContext

##### 5.3.3 Spring容器内事件发布的应用

1. MethodExecutionEvent的改装
2. MethodExecutionEventListener
3. MethodExecutionEventPublisher改造
4. 注册到ApplicationContext容器

#### 5.4 多配置模块加载的简化

#### 5.5 小结

### 第6章 Spring IOC容器之扩展篇

#### 6.1 Spring2.5的基于注解的依赖注入

##### 6.1.1 注解版的自动绑定(@Autowired)

1. 从自动绑定(autowire)到@Autowired
2. @Qualifier的陪伴

##### 6.1.2 @Autowired之外的选择-使用JSR250标注依赖注入关系

##### 6.1.3 将革命进行得更彻底一些(classpath-scanning功能介绍)

#### 6.2 Spring3.0展望

#### 6.3 小结

## 第三部分 Spring AOP框架

### 第7章 一起来看AOP

#### 7.1 AOP的尴尬

#### 7.2 AOP走向现实

##### 7.2.1 静态AOP时代

##### 7.2.2 动态AOP时代

#### 7.3 Java平台上的AOP实现机制

##### 7.3.1 动态代理

##### 7.3.2 动态字节码增强

##### 7.3.3 Java代码生成

##### 7.3.4 自定义类加载器

##### 7.3.5 AOL扩展

#### 7.4 AOP国家的公平

##### 7.4.1 Joinpoint

以下是一些较为常见的Joinpoint类型

- 方法调用(Method Call)
- 方法调用执行(Method Call execution)
- 构造方法调用(Constructor Call)
- 构造方法执行(Constructor Call Execution)
- 字段设置(Field Set)
- 字段获取(Field Get)
- 异常处理执行(Exception Handler Execution)
- 类初始化(Class intialization)

##### 7.4.2 Pointcut

1. Pointcut的表达方式
   - 直接指定Joinpoint所在方法名称
   - 正则表达式
   - 使用特定的Pointcut表述语言
2. Pointcut运算

7.4.3 Advice

1. Before Advice
2. After Advice
   - After returning Advice
   - After throwing Advice
   - After Advice
3. Around Advice
4. Introduction

##### 7.4.4 Aspect

##### 7.4.5 织入和织入器

##### 7.4.6 目标对象

#### 7.5 小结

### 第8章 Spring AOP概述及其实现机制

#### 8.1 Spring AOP概述

#### 8.2 Spring AOP的实现机制

##### 8.2.1 设计模式之代理模式

##### 8.2.2 动态代理

##### 8.2.3 动态字节码生成

#### 8.3 小结

### 第9章 Spring AOP一世

#### 9.1 Spring AOP中的Joinpoint

#### 9.2 Spring AOP中的Pointcut

##### 9.2.1 常见的Pointcut

1. NameMatchMethodPointcut
2. jdkRegexMethodPointcut和Per15RegexpMethodPointcut
3. AnnotationMatchingPointcut
4. ComposablePointcut
5. ControlFlowPointcut

##### 9.2.2 扩展Pointcut(Customize Pointcut)

1. 自定义StaticMethodMatcherPointcut
2. 自定义DynamicMethodMatcherPointcut

##### 9.2.3 IoC容器中的Pointcut

#### 9.3 Spring AOP中的Advice

##### 9.3.1 per-class类型的Advice

1. Before Advice
2. ThrowsAdvice
3. AfterReturningAdvice
4. Around Advice

##### 9.3.2 per-instance类型的Advice

#### 9.4 Spring AOP中的Aspect

##### 9.4.1 PointcutAdvisor家族

1. DefaultPointcutAdvisor
2. NameMatchMethodPointcutAdvisor
3. RegexpMethodPointcutAdvisor
4. DefaultBeanFactoryPointcutAdvisor

##### 9.4.2 IntroductionAdvisor分支

##### 9.4.3 Ordered的作用

#### 9.5 Spring AOP中的织入

![image-20210105100713139](images/image-20210105100713139.png)

##### 9.5.1 如何与ProxyFactory打交道

1. 基于接口的代理

2. 基于类的代理

   ![image-20210105104809818](images/image-20210105104809818.png)

3. Introduction的织入

##### 9.5.2 看清ProxyFactory的本质

##### 9.5.3 容器中的织入器-ProxyFactoryBean

1. ProxyFactoryBean的本质
2. ProxyFactoryBean的使用

##### 9.5.4 加快织入的自动化进程

1. 自动代理得以实现的原理
2. 可用的AutoProxyCreator
   - BeanNameAutoProxyCreator
   - DefaultAdvisorAutoProxyCreator
3. 扩展AutoProxyCreator

#### 9.6 TargetSource

### 第10章 Spring AOP 二世

### 第11章 AOP应用案例

### 第12章 Spring AOP之扩展篇



尚硅谷面试题第一季

1.++在前先运算再赋值，++在后先复制再运算；自增在变量，运算在栈中，栈中运算完，赋值变量中；

====================================================================================



# 重构_改善既有代码的设计(20210202-20210308)

## 第2章	重构

### 2.1 何谓重构

重构：对软件内部结构的一种调整，目的是在不改变软件可观察行为的前提下，提高其可理解性，降低其修改成本；

### 2.2 为何重构

重构是个工具，可以(并且应该)用于一下几个目的：

- 重构改进软件设计

  改进设计的一个重要方向就是消除重复代码，这个动作的重要性在于方便未来的修改；如果消除重复代码，你就可以确定所有事物和行为在代码中表述一次，这正是优秀设计的根本；

- 重构使软件更容易理解

- 重构帮助找到bug

- 重构提高编码速度

### 2.3 何时重构

- 三次法则

  第一次做某件事时只管去做，第二次做类似的事会产生反感，但无论如何还是可以去做，第三次再做类似的事，你就应该重构；事不过三，三则重构；

- 添加功能时重构

- 修补错误时重构

- 复审代码时重构

我们希望程序：

1. 容易阅读；
2. 所有逻辑都只在唯一地方指定；
3. 新的改动不会危及现有行为；
4. 尽可能简单表达条件逻辑；

### 2.4 怎么对经理说

计算机科学是这样一门科学：它相信所有问题都可以通过增加一个间接层来解决；

### 2.5 重构的难题

- 数据库

- 修改接口

  如何重构手法改变了已发布接口，你必须同时维护新旧两个接口，直到所有用户都有时间对这个变化做出反应；请尽量这么做：让旧接口调用新接口，当你要修改某个函数名称时，请留下旧函数，让它调用新函数；千万不要复制函数实现，那会让你陷入重复代码的泥淖中难以自拔。

- 难以通过重构手法完成的设计改动

- 何时不该重构

### 2.6 重构与设计(*有点意思*)

重构肩负一项特殊使命：它和设计彼此互补；

有一种观点认为：重构可以取代预先设计，这意思是你根本不必做任何设计，只管按照最初想法开始编码，让代码有效运行，然后再将它重构成型；

如果你选择重构，问题的重点就转变了，你任然做预先设计，但是不必一定找出正确的解决方案，此刻的你只需要得到一个足够合理的解决方案就够了，你很肯定地知道，在实现这个初始解决方案的时候，你对问题的理解也会逐渐加深，你可能会察觉最佳解决方案和你当初设想的有些不同，只要有重构这把利器在手，就不成问题，因为重构让日后的修改成本不在高昂；

教训：哪怕你完全了解系统，也请实际度量它的性能，不要臆测，臆测会让你学到一些东西，但十有八九你是错的。

### 2.7 重构与性能

除了对性能有严格要求的实时系统，其他任何情况下“编写快速软件”的秘密就是：首先写出可调的软件，然后调整它以求获得足够速度；

### 2.8 重构起源何处

## 第3章 代码的坏味道

### 3.1 Duplicated Code(重复代码)

- 同一个类的两个函数含有相同的表达式，这是你需要做的就是采用Extract Method提炼出重复的代码，然后让这两个地点都调用被提炼出来的那一段代码；
- 两个互为兄弟的子类内含相同表达式，要避免这种情况，只需对两个类都是用Extract Method，然后再对被提炼出来的代码使用Pull Up Method，将它推入超类内；
- 如果两个毫不相关的类出现Duplicated Code，你应该考虑对其中一个使用Extract Class，将重复代码提炼到一个独立类中，然后在另一个类内使用这个新类；

### 3.2 Long Method(过长函数)

- 最终的效果是：你应该更积极地分解函数，我们遵循这样一条原则：每当感觉需要以注释来说明点什么的时候，我们就把需要说明的东西写进一个独立函数中，并以其用户(而非实现手法)命名；我们可以对一组甚至短短一行代码做这种事，哪怕替换后的函数调用动作比函数本身还长，只要函数名称能够解释其用途，我们也该毫不犹豫地那么做，关键不在函数的长度，而在于函数"做什么"和"如何做"之间的语义距离；
- 确定提炼那一段代码，一个很好的技巧是：寻找注释，他们通常能指出代码用途和实现手法之前的语义距离，如果代码前方有一行注释，就是在提醒你：可以将这段代码替换成一个函数，而且可以在注释的基础上给这个函数命名，就算只有一行代码，如果它需要以注释来说明，那也值得将它提炼到独立函数去；
- 条件表达式和循环常常也是提炼的信号；

### 3.3 Large Class(过大的类)

### 3.4 Long Parameter List(过长参数列)

### 3.5 Divergent Change(发散式变化)

如果某个类经常因为不同的原因在不同的方向上发生变化，那么此时将这个对象变成连个会更好，这么一来每个对象就可以只因一种变化而需要修改；

### 3.6 Shotgun Surgery(霰弹式修改)

### 3.7 Feature Envy(依恋情结)

一个函数往往会用到几个类的功能，那么它究竟该被置于何处，我们的原则是：判断哪个类拥有最多被此函数使用的数据，然后就把这个函数和那些数据摆在一起；

### 3.8 Data Clumps(数据泥团)

一个好的评断办法是：删除众多数据中的一项，这么做，其他数据有没有因而失去意义，如果它们不再有意义，这就是个明确信号：你应该为它们产生一个新对象；

### 3.9 Primitive Obsession(基本类型偏执)

### 3.10 Switch Statements(switch 惊悚现身)

### 3.11 Parallel Inheritance Hierarchies(平行继承体系)

### 3.12 Lazy Class(冗赘类)

### 3.13 Speculative Generality(夸夸其谈未来性)

### 3.14 Temporary fIeld(令人迷惑的暂时字段)

### 3.15 Message Chains(过度耦合的消息链)

### 3.16 Middle Man(中间人)

### 3.17 Inappropriate Intimacy(狎昵关系)

### 3.18 Alternative Classes With Different Interfaces(异曲同工的类) 

### 3.19 Incomplete library Class(不完美的库类)

### 3.20 Data Class(纯稚的数据类)

### 3.21 Refused Bequest(被拒绝的遗赠)

### 3.22 Comments(过多而注释)

## 第4章  构筑测试体系

### 4.1 自测试代码的价值

实际上，撰写测试代码的最有用时机是在开始编程之前，当你需要添加特性的时候，先写相应测试代码，听起来离经叛道，其实不然，编写测试代码其实就是在问自己：添加这个功能需要做些什么，编写测试代码还能使你把注意力集中于接口而非实现(这永远是件好事)，预先写好的测试嗲吗也为你的工作安上一个明确的结束标志：一旦测试代码正常运行，工作就可以结束了；

### 4.2 JUnit测试框架

- 单元测试和功能测试：单元测试是高度局部化的东西，每个测试类都隶属于单一包，它能够测试其他包的接口，除此之外它将假设其他包一切正常；功能测试就完全不同，它们用来保证软件能够正常运行，它们从客户的角度保障质量，并不关心程序员的生产力；

### 4.3 添加更多的测试

## 第5章 重构列表

第5-12章构成了一份重构列表草案。

### 5.1 重构的记录格式

![image-20210204231524025](images/image-20210204231524025.png)![image-20210204231545691](images/image-20210204231545691.png)

### 5.2 寻找引用点

### 5.3 这些重构手法有多成熟

## 第6章 重新组织函数

### 6.1 Extract Method(提炼函数)

有几个原因造成我喜欢简短而命名良好的函数：

- 如果每个函数的粒度都很小，那么函数被复用的机会就更大；
- 这会使高层函数读起来更像一系列注释；
- 如果函数都是细粒度，那么函数的覆写也会更容易写；

一个函数多长才算合适，关键在于函数名称和函数本体之间的语义距离；如果提炼可以强化代码的清晰度，那就去做，就算函数名称比提炼出来的代码还长也无所谓；

### 6.2 Inline Method(内联函数)

### 6.3 Inline Temp(内联临时变量)

你有一个临时变量，只被一个简单表达式赋值一次，而它妨碍了其他重构手法，将所有对改变量的引用动作，替换为对它赋值的那个表达式自身；

### 6.4 Replace Temp with Query(以查询取代临时变量)

你的程序以一个临时变量保存某一表达式的运算结果，将这个表达式提炼到一个独立函数中，将这个临时变量的所有引用点替换为对新函数的调用，此后，新函数就可被其他函数使用；

### 6.5 Introduce Explaining Variable(引入解释性变量)

你有一个复杂的表达式，将该复杂表达式(或其中一部分)的结果放进一个临时变量，以此变量名称来解释表达式用途；

### 6.6 Split Temporary Variable(分解临时变量)

你的程序有某个临时变量被赋值超过一次，它既不是循环变量，也不被用于收集计算结果，针对每次赋值，创造一个独立、对应的临时变量；

### 6.7 Remove Assignments to Parameters(移除对参数的赋值)

代码对一个参数进行赋值，以一个临时变量取代该参数的位置；

### 6.8 Replace Method with Method Object(以函数对象取代函数)***

你有一个大型函数，其中对局部变量的使用使你无法采用Extract Method，将这个函数放进一个单独对象中，如此一来局部变量就成了对象内的字段，然后你可以在同一个对象中将这个大型函数分解为多个小型函数；

![image-20210209095413304](images/image-20210209095413304.png)

### 6.9 Substitule Algorithm(替换算法)

你想要把某个算法替换为另一个更清晰的算法，将函数本体替换为另一个算法；

## 第7章 在对象之间搬移特性

### 7.1 Move Method(搬移函数)

你的程序中，有个函数与其所驻类之外的另一个类进行更多交流，调用后者，或被后者调用，在该函数最常引用的类中建立一个有着类似行为的新函数，将旧函数变成一个单纯的委托函数，或是将函数完全移除；

当需要使用源类的特性时，有4种选择：

1. 将这个特性也移到目标类；
2. 建立或使用一个从目标类到源类的引用；
3. 将源对象当作参数传给目标函数；
4. 如果所需特性是个变量，将它当作参数传给目标函数；

### 7.2 Move Field(搬移字段)

你的程序中，某个字段被其所驻类之外的另一个类更多地用到，在目标类新建一个字段，修改源字段的所有用户，令它们改为新字段；

### 7.3 Extract Class(提炼类)

某个类做了应该由两个类做的事，建立一个新类，将相关的字段和函数从旧类搬移到新类；

### 7.4 Inline Class(将类内联化)

某个类没有做太多事情，将这个类的所有特性搬移到另一个类中，然后移除原类；

### 7.5 Hide Delegate(隐藏"委托关系")

客户通过一个委托类来调用另一个对象，在服务类上建立客户所需的所有函数，用以隐藏委托关系；

### 7.6 Remove Middle Man(移除中间人)

某个类做了过多的简单委托动作，让客户直接调用受托类；

### 7.7 Introduce Foreign Method(引入外加函数)

你需要为提供服务的类增加一个函数，但你无法修改这个类，在客户类中建立一个函数，并以第一参数的形式传入一个服务类实例；

### 7.8 Introduce Local Extension(引入本地扩展)

你需要为服务类提供 一些额外函数，但你无法修改这个类，建立一个新类，使它包含这些额外函数，让这个扩展品成为源类的子类或包装类；

## 第8章 重新组织数据

魔法数，也就是带有特殊含义的数字；

### 8.1 Self Encapsulate Field(自封装字段)

你直接访问一个字段，但与字段之间的耦合关系逐渐变得笨拙，为这个字段建立取值/设值函数，并且只以这些函数来访问字段；

### 8.2 Replace Data Value Object(以对象取代数据值)

你有一个数据项，需要与其他数据和行为一起使用才有意义，将数据项变成对象；

### 8.3 Change Value to Reference(将值对象该为引用对象)

你从一个类衍生出很多彼此相等的实例，希望将它们替换为同一个对象，将这个对象变成引用对象；

### 8.4 Change Reference to Value(将引用对象改为值对象)

你有一个引用对象，很小且不可变，而且不易管理，将它变成一个值对象；

值对象有一个非常重要的特性：它们应该是不可变的；要把一个引用对象变成值对象，关键动作是：检查它是否不可变；

### 8.5 Replace Array with Object(以对象取代数组)

你有一个数组，其中的元素各自代表不同的东西，以对象替换数组，对于数组中的每个元素，以一个字段来表示；

### 8.6 Duplicate Observed Data(复制"被监视数据")

你有一些领域数据置身于GUI控件中，而领域函数需要访问这些数据，将该数据复制到一个领域对象中，建立一个Observer模式，用以同步领域对象和GUI对象内的重复数据；

### 8.7 Change Unidirectional Assoociation to Bidirectionnal(将单向关联改为双向关联)

两个类都需要使用对方特性，但其间只有一条单向连接，添加一个反向指针，并使修改函数能够同时更新两条连接；

### 8.8 Change Bidirectional Association to Unidirectional(将双向关联改为单向关联)

两个类之间有双向关联，但其中一个类如今不需要另一个类的特性，去除不必要的关联；

### 8.9 Replace Magic Number  with Symbolic Constant(以字面常量取代魔法数)

你有一个字面数值，带有特别含义，创造一个常量，根据其意义为它命名，并将上述的字面数值替换为这个常量；

### 8.10 Encapsulate Field(封装字段)

你的类中存在一个public字段，将它申明为private，并提供相应的访问函数；

### 8.11 Encapsulate Collection(封装集合)

有个函数返回一个集合，让这个杭州返回该集合的一个只读副本，并在这个类中提供添加/移除集合元素的函数；

### 8.12 Replace Record with Data Class(以数据类取代记录)

你需要面对传统编程环境中的记录结构，为该记录创建一个"哑"数据对象；

### 8.13 Replace Type Code with Class(以类型取代类型码)

类之中有一个数值类型码，但它并不影响类的行为，以一个新的类替换该数值类型码；

### 8.14 Replace Type Code with Subclasses(以子类取代类型码)

你有一个不可变的类型码，它会影响类的行为，以子类取代这个类型码；

### 8.15 Replace Type Code with State/Strategy(以State/Strategy取代类型码)

你有一个类型码，它会影响类的行为，但你无法通过继承手法消除它，以状态对象取代类型码；

### 8.16 Replace Subclass with Fileds(以字段取代子类)

你的各个子类的唯一差别只在"返回常量数据"的函数身上，修改这些函数，使它们返回超类中的某个(新增)字段，然后销毁子类；

## 第9章 简化条件表达式

### 9.1 Decompose Condition(分解条件表达式)

你有一个复杂的条件(if-then-else)语句，从if、then、else三个段落中分别提炼出独立函数；

### 9.2 Consolidate Conditional Expression(合并条件表达收)

你有一系列条件测试，都得到相同结果，将这些测试合并为一个条件表达式，并将这个条件表达式提炼成为一个独立函数；

### 9.3 Consolidate Duplicate Conditional Fragments(合并重复的条件片段)

在条件表达式的每个分支上有着相同的一段代码，将这段重复代码搬移到条件表达式之外；

### 9.4 Remove Control Flag(移除控制标记)

在一系列布尔表达式中，某个变量带有"控制标记"(control flag)的作用，以break语句或return语句取代控制标记；

### 9.5 Replace Nested Conditional with Guard Clauses(以卫语句取代嵌套条件表达式)

函数中的条件逻辑使人难以看清正常的执行路径，使用卫语句表现所有特殊情况；

Replace Nested Conditional with Guard Clauses的精髓就是：给某一条分支以提别的重视，告诉阅读者："这种情况很罕见，如果它真的发生了，请做一些必要的整理工作，然后退出"；

### 9.6 Replace Conditional with Polymorphism(以多态取代条件表达式)

你手上有个条件表达式，它根据对象类型的不同而选择不同的行为，将这个条件表达式的每个分支放进一个子类内的覆写函数中，然后将原始函数声明为抽象函数；

### 9.7 Introduce Null Object(引入null对象)

你需要再三检查对象是否为null，将null值替换为null对象；

### 9.8 Introduce Assertion(引入断言)

某一段代码需要对程序状态做出某种假设，以断言明确表现这种假设；

## 第10章 简化函数调用

### 10.1 Rename Method(函数改名)

函数的名称未能揭示函数的用途，修改函数名称；

函数的名称应该准确表达它的用途，给函数命名有一个好办法：首先考虑应该给这个函数写上一句怎样的注释，然后想办法将注释变成函数名称；

### 10.2 Add Parameter(添加参数)

某个函数需要从调用端得到更多信息，为此函数添加一个对象参数，让该对象带进函数所需信息；

### 10.3 Remove Parameter(移除参数)

函数本体不再需要某个参数，将改参数去除；

### 10.4 Separate Query from Modifier(将查询函数和修改函数分离)

某个函数既返回对象状态值，又修改对象状态，建立两个不同的函数，其中一个负责查询，另一个负责修改；

下面是一条好规则：任何有返回值的函数，都不应该有看得到的副作用；

### 10.5 Parameterize Menthod(令函数携带参数)

若干函数做了类似的工作，但在函数本体中却包含了不同的值，建立单一函数，以参数表达那些不同的值；

### 10.6 Replace Parameter with Explicit Methods(以明确函数取代参数)

你有一个函数，其中完全取决于参数值而采取不同行为，针对该参数的每一个可能值，建立一个独立函数；

### 10.7 Preserve Whole Object(保持对象完整)

你从某个对象取出若干值，将它们作为某一次函数调用时的参数，改为传递整个对象；

### 10.8 Replace Parameter with Methods(以函数取代参数)

对象调用某个函数，并将所得结果作为参数，传递给另一个函数，而接受该参数的函数本身也能够调用前一个函数，让参数接受者去除该项参数，并直接调用前一个函数；

如果函数可以通过其他途径获得参数值，那么它就不应该通过参数取得该值；

缩减参数列的办法之一就是：看看参数接收端是否可以通过与调用端相同的计算来取得参数值；

### 10.9 Introduce Parameter Object(引入参数对象)

某些参数总是很自然地同时出现，以一个对象取代这些参数；

Java的函数参数都是按值传递的，不可变类正好能够模仿Java参数的工作方式；

### 10.10 Remove Setting Method(移除设置函数)

类中的某个字段应该在对象创建时被设值，然后就不再改变，去除该字段的所有设值函数；

如果你为某个字段提供了设值函数，这就暗示这个字段可以被改变，如果你不希望在对象创建之后还有机会被改变，那就不要为它提供设值函数(同时将该字段设为final)；

### 10.11 Hide Method(隐藏函数)

有一个函数，从来没有被其他任何类用到，将这个函数修改为private；

### 10.12 Replace Constructor with Pactory Method(以工厂函数取代构造函数)

你希望在创建对象时不仅仅是做简单的建构动作，将构造函数替换为工厂函数；

### 10.13 Encapsulate Downcast(封装向下转型)

某个函数返回的对象，需要由函数调用者执行向下转型(downcast)，将向下转型动作移到函数中；

### 10.14 Replace Error Code with Exception(以异常取代错误码)

某个函数返回一个特定的代码，用以表示某种错误情况，改为异常；

### 10.15 Replace Exception with Test(以测试取代异常)

面对一个调用者可以预先检查的条件，你抛出了一个异常，修改调用者，使它在调用函数之前先做检查；

"异常"只应该被用于异常的、罕见的行为，也就是那些产生意料之外的错误的行为，而不应该成为条件检查的替代品，如果可以合理期望调用者在调用函数之前先检查某个条件，那么就应该提供一个测试，而调用者应该使用它；

## 第11章 处理概括关系

### 11.1 Pull Up Field(字段上移)

两个子类拥有相同的字段，将该字段移至超类；

### 11.2 Pull Up Method(函数上移)

有些函数，在各个子类中产生完全相同的结果，将该函数移至超类；

### 11.3 Pull Up Constructor Body(构造函数本体上移)

你在各个子类中拥有一些构造函数，他们的本体几乎完全一致，在超类中新建一个构造函数，并在子类构造函数中调用它；

### 11.4 Push Down Method(函数下移)

超类中的某个函数只与部分(而非全部)子类有关，将这个函数移到相关的那些子类去；

### 11.5 Push Down Field(字段下移)

超类中的某个字段只被部分(而非全部)子类用到，将这个字段移到需要它的那些子类去；

### 11.6 Extract Subclass(提炼子类)

类中的某些特性只被某些(而非全部)实例用到，新建一个子类，将上面所说的那一部分特性移到子类中；

### 11.7 Extract Superclass(提炼超类)

两个类有相似特性，为这两个类建立一个超类，将相同特性移至超类；

重复代码的某种形式就是：两个类以相同的方式做类似的事情，或者以不同的方式做类似的事情，对象提供了一种简化这种情况的机制，那就是继承，但是在建立这些具有共通性的类之前，往往无法发现这种的共通性，因此经常会在具有共通性的类出现之后，在开始建立其间的继承结构；

### 11.8 Extract Interface(提炼接口)

若干客户使用类接口中的同一子集，或者两个类的接口有部分相同，将相同的子集提炼到一个独立接口中；

### 11.9 Collapse Hierarchy(折叠继承体系)

超类和子类之间无太大区别，将它们合为一体；

### 11.10 Form Template Method(塑造模板函数)

你有一些子类，其中相应的某些函数以相同顺序执行类似的操作，但各个操作的细节上有所不同，将这些操作分别放进独立函数中，并保持它们都有相同的签名，于是原函数也就变得相同了，然后将原函数上移至超类；

### 11.11 Replace Inheritance with Delegation(以委托取代继承)

某个子类只使用超类接口中的一部分，或是根本不需要继承而来的数据，在子类中新建一个字段用以保存超类，调整子类函数，令它改而委托超类，然后去除两者之间的继承关系；

### 11.12 Replace Delegation with Inheritance(以继承取代委托)

你在两个类之间使用委托关系，并经常为整个接口编写很多极简单的委托函数，让委托类继承受托类；

## 第12章 大型重构

![image-20210305093919004](images/image-20210305093919004.png)

### 12.1 Tease Apart Inheritance(梳理并分解继承体系)

某个继承体系同时承担两项责任，建立两个继承体系，并通过委托关系让其中一个可以调用另一个；

要指出继承体系是否承担了两项不同的任务并不困难：如果继承体系中的某一特定层级上的所有类，其子类名称都已相同的形容词开始，那么这个体系很可能就是承担着两项不同的责任；

### 12.2 Convert Procedural Design to Objects(将过程化设计转化为对象设计)

你手上有一些传统过程化风格的代码，将数据记录变成对象，将大块的行为分为小块，并将行为移入相关对象之中；

### 12.3 Separate Domain from Presentation(将领域和表述/显示分离)

某些GUI类之中包含了领域逻辑，将领域逻辑分离出来，为它们建立独立的领域类；

### 12.4 Extract Hierarchy(提炼继承体系)

你有某个类做了太多工作，其中一部分工作是以大量条件表达式完成的，建立继承体系，以一个子类表示一种特殊情况；

## 第13章 重构，复用与实现

### 13.1 现实的校验

### 13.2 为什么开发者不愿意重构他们的程序

应对并处理变化，是软件开发的根本复杂性之一；

![image-20210307110959447](images/image-20210307110959447.png)

一个常见的重构原因，同时也是本书关注焦点，是调整程序结构以使(短期内)添加新功能更容易；

### 13.3 再论实现的检验

### 13.4 重构的资源和参考资料

### 13.5 从重构联想到软件复用和技术传播

### 13.6 小结

### 13.7 参考文献

## 第14章 重构工具

### 14.1 使用工具进行重构

### 14.2 重构工具的技术标准

- 程序数据库
- 解析树
- 准确性

### 14.3 重构工具的实用标准

- 速度
- 撤销
- 与其他工具集成

### 14.4 小结

## 第15章 总结

![image-20210308101705680](images/image-20210308101705680.png)



=====================<<重构改善既有代码的设计>>=====================

# 代码整洁之道(20210308-20210401)

## 第1章 整洁代码

### 1.1 要有代码

### 1.2 糟糕的代码

### 1.3 混乱的代码

#### 1.3.1 华丽新设计

#### 1.3.2 态度

#### 1.3.3 谜题

#### 1.3.4 整洁代码的艺术

#### 1.3.5 什么是整洁代码

"我喜欢优雅和高效的代码，代码逻辑应当直截了当，叫缺陷难以隐藏，尽量减少依赖关系，使之便于维护，依据某种分层战略完善错误处理代码，性能调至最优，省得引诱别人做没规矩的优化，搞出一堆混乱来，整洁的代码只做好一件事"；

糟糕的代码想做太多事，它意图混乱、目的含混，整洁的代码力求集中；每个函数、每个类和每个模块都全神贯注于一事，完全不受四周细节的干扰和污染；

### 1.4 思想流派

### 1.5 我们是作者

### 1.6 童子军军规

### 1.7 前传于原则

### 1.8 小结

### 1.9 文献

## 第2章 有意义的命名

### 2.1 介绍

### 2.2 名副其实

### 2.3 避免误导

### 2.4 做有意义的区分

要区分名称，就要以读者能鉴别不同之处的方式来区分；

### 2.5 使用读得出来的名称

### 2.6 使用可可搜索的名称

长名称胜于短名称，搜得到的名称胜于用自造编代码写就的名称；

### 2.7 避免使用编码

#### 2.7.1 匈牙利语标记法

如今HN和其他类型编码形式都纯属多余，它们增加了修改变量、函数或类的名称或类型的难度，它们增加了阅读代码的难度，它们制造了让编码系统误导读者的可能性；

#### 2.7.2 成员前缀

#### 2.7.3 接口和实现

### 2.8 避免思维映射

### 2.9 类名

### 2.10 方法名

### 2.11 别扮可爱

言到意到，意到言到；

### 2.12 每个概念对应一个词

### 2.13 别用双关语

避免将同一单词用于不同的目的，同一术语用于不同概念，基本上就是双关语了；

### 2.14 使用解决方案领域名称

记住，只有程序员才会读你的代码，所以，尽量用那些计算机科学(Computer Science，CS)术语、算法名、模式名、数学术语吧；

取个技术性的名称，通常是最靠谱的做法；

### 2.15 使用源自所涉问题领域的名称

如果不能用程序员熟悉的术语来给手头的工作命名，就采用从所涉问题领域而来的名称吧，至少，负责维护代码的程序员就能去请教领域专家了；

优秀的程序员和设计师，其工作之一就是分离解决方案领域和问题领域的概念，与所涉问题领域更为贴近的代码，应当采用源自问题领域的名称；

### 2.16 添加有意义的语境

很少有名称是能自我说明的-多数都不能，反之，你需要用有良好命名的类、函数或名称空间来放置名称，给读者提供语境，如果没有这么做，给名称添加前缀就是最后一招了；

### 2.17 不要添加没用的语境

只要短名称足够清楚，就要比长名称好，别给名称添加不必要的语境；

### 2.18 最后的话

## 第3章 函数

### 3.1 短小

- 代码块和缩进

### 3.2 只做一件事

函数应该做一件事，做好这件事，只做这一件事；

如果函数只是做了该函数名下同一抽象层上的步骤，则函数还是只做了一件事，编写函数毕竟是为了把大一些的概念(换言之，函数的名称)拆分为另一抽象层上的一系列步骤；

所以，要判断函数是否不止做了一件事，还有一个办法，就是看是否能再拆出一个函数，该函数不仅只是单纯地重新诠释其实现；

- 函数中的区段

  只做一件事的函数无法被合理地切分为多个区段；

### 3.3 每个函数一个抽象层级

要确保函数只做一件事，函数中的语句都要在同一抽象层级上；

- 自顶向下读代码：向下规则

  我们想要让代码拥有自顶向下的阅读顺序，我们想要让每个函数后面都跟着位于下一抽象层级的函数，这样一来，在查看函数列表时，就能循抽象层级向下阅读了，把这叫做向下规则；

### 3.4 switch语句

### 3.5 使用描述性的名称

别害怕长名称，长而具有描述性的名称，要比短而令人费解的名称好，长而具有描述性的名称，要比描述性的长注释好；使用某种命名约定，让函数名称中的多个单词容易阅读，然后使用这些单词给函数取个能说清其功能的名称；

### 3.6 函数参数

最理想的参数数量是零(零参数寒素)，其次是一(单参数函数)，再次是二(双参数函数)，应尽量避免三(三参数函数)，有足够特殊的理由才能用三个以上参数(多参数函数)；

#### 3.6.1 一元函数的普遍形式

#### 3.6.2 标识参数

标识参数丑陋不堪，向函数传入布尔值简直就是骇人听闻的做法，这样做，方法签名立刻变得复杂起来，大声宣布本函数不止做一件事；

#### 3.6.3 二元函数

#### 3.6.4 三元函数

#### 3.6.5 参数对象

#### 3.6.6 参数列表

#### 3.6.7 动词与关键词

### 3.7 无副作用

- 输出参数：普遍而言，应避免使用输出参数，如果函数必须要修改某种状态，就修改所属对象的状态吧；

### 3.8 分隔指令与询问

函数要么做什么事，要么回答什么事，但二者不可兼得，函数应该修改某对象的状态，或是返回该对象的有关信息；两样都干常会导致混乱；

### 3.9 使用异常替代返回错误码

#### 3.9.1 抽离Try/Catch代码块

Try/Catch代码块丑陋不堪，它们搞乱了代码结构，把错误处理与正常流程混为一谈，最好把try和catch代码块的主体部分抽离出来，另外形成函数；

#### 3.9.2 错误处理就是一件事

参数应该只做一件事，错误处理就是一件事；

#### 3.9.3 Error.Java依赖磁铁

使用异常替代错误码，新异常就可以从异常类派生出来，无需重新编译或重新部署；

### 3.10 别重复自己

重复可能是软件中一切邪恶的根源，很多原则与实践规则都是为了控制与消除重复而创建；

### 3.11 结构化编程

### 3.12 如何写出这样的函数

写代码和写别的东西很像，在写论文或文章时，你先想什么就写什么，然后再打磨它，初稿也许粗陋无序，你就斟酌推敲，直至达到你心目中的样子；

我写函数时，一开始都冗长而复杂，有太多缩进和嵌套循环，有过长的参数列表，名称是随意取的，也会有重复的代码，不过我会配上一套单元测试，覆盖每行丑陋的代码，

然后我打磨这些代码，分解函数、修改名称、消除重复，我缩短和重新安置方法，有时我还拆散类，同时保持测试通过；

最后，遵循本章列出的规则，我组装好这些函数；

### 3.13 小结

编程艺术是且一直就是语言设计的艺术；

![image-20210315225855162](images/image-20210315225855162.png)![image-20210315225906849](images/image-20210315225906849.png)

### 3.14 SetupTeardownIncluder程序

### 3.15 文献

## 第4章 注释

什么也比不上放置良好的注释来得有用，什么也不会比烂七八糟的注释更有本事搞乱一个模块，什么也不会比陈旧、提供错误信息的注释更有破坏性；

注释存在的时间越久，就离其所描述的代码越远，越来越变得全然错误，原因很简单，程序员不能坚持维护注释；

### 4.1 注释不能美化糟糕的代码

### 4.2 用代码来阐述

### 4.2 好注释

#### 4.3.1 法律信息

#### 4.3.2 提供信息的注释

#### 4.3.3 对意图的解释

#### 4.3.4 阐释

#### 4.3.5 警示

#### 4.3.6 TODO注释

TODO是一种程序员认为应该做，但由于某些原因目前还没做的工作；

#### 4.3.7 放大

#### 4.3.8 公共API中的Javadoc

### 4.4 坏注释

#### 4.4.1 喃喃自语

#### 4.4.2 多余的注释

#### 4.4.3 误导性注释

#### 4.4.4 循规式注释

#### 4.4.5 日志式注释

#### 4.4.6 废话注释

#### 4.4.7 可怕的废话

#### 4.4.8 能用函数或变量时别用注释

#### 4.4.9 位置标记

#### 4.4.10 括号后面的注释

#### 4.4.11 归属于署名

#### 4.4.12 注释掉的代码

#### 4.4.13 HTML注释

#### 4.4.14 非本地信息

#### 4.4.15 信息过多

#### 4.4.16 不明显的联系

#### 4.4.17 函数头

#### 4.4.18 非公共代码中的Javadoc

#### 4.4.19 范例

### 4.5 文献

## 第5章 格式

### 5.1 格式的目的

### 5.2 垂直格式

#### 5.2.1 向报纸学习

#### 5.2.2 概念间垂直方向上的区隔

#### 5.2.3 垂直方向上的靠近

#### 5.2.4 垂直距离

关系密切的概念应该互相靠近；

变量申明，变量申明应该尽可能靠近其使用位置；

实体变量应该在类的顶部申明；

相关函数，若某个函数调用了另外一个，就应该把它们放到一起，而且调用者应该尽可能放在被调用者上面；

概念相关，概念相关的代码应该放到一起，相关性越强，彼此之前的距离就该越短；

#### 5.2.5 垂直顺序

一般而言我们向自上向下展示函数调用依赖顺序，也就是说，被调用的函数应该放在执行调用的函数下面，这样就建立了一种自顶向下贯穿代码模块的良好信息流；

### 5.3 横向格式

#### 5.3.1 水平方向上的区隔与靠近

#### 5.3.2 水平对齐

#### 5.3.3 缩进

#### 5.3.4 空范围

### 5.4 团队规则

记住，好的软件系统是由一系列读起来不错的代码文件组成的；

### 5.5 鲍勃大叔的格式规则

## 第6章 对象和数据结构

将变量设置为私有(private)有一个理由：我们不想其他人依赖这些变量，我们还想在心血来潮时能自由修改其类型或实现；

### 6.1 数据抽象

### 6.2 数据、对象的反对称性

对象把数据隐藏于抽象之后，暴露操作数据的函数；数据结构暴露其数据，没有提供有意义的函数；留意这两种定义的本质，它们是对立的，这种差异貌似微小，但却有深远的含义；

对象与数据结构之前的二分原理：

过程式代码(使用数据结构的代码)便于在不改动既有数据结构的前提下添加新函数，面向对象代码便于在不改动既有函数的前提下添加新类；

反过来也讲得通：过程式代码难以添加新数据结构，因为必须修改所有函数，面向对象代码难以添加新函数，因为必须修改所有类；

在任何一个复杂系统中，都会有需要添加新数据类型而不是新函数的时候，这时，对象和面向对象就比较合适；另一方面，也会有想要添加新函数而不是数据类型的时候，在这种情况下，过程式代码和数据结构更合适；

### 6.3 德墨忒耳律

著名的德墨忒耳律认为，模块不应了解它所操作对象的内部情形；

#### 6.3.1 火车失事

#### 6.3.2 混杂

#### 6.3.3 隐藏结构

### 6.4 数据传送对象

最为精炼的数据结构，是一个只有公共变量、没有函数的类，这种数据结构有时被称为数据传送对象，或DTO(Data Transfer Objects)；

### 6.5 小结

对象暴露行为，隐藏数据，便于添加新对象类型而无需修改既有行为，同时也难以在既有对象中添加新行为。数据结构暴露数据，没有明显的行为，便于向既有数据结构添加新行为，同时也难以向既有函数添加新数据结构；

### 6.6 文献

## 第7章 错误处理

### 7.1 使用异常而非返回码

### 7.2 先写Try-Catch-Finally语句

### 7.3 使用可不控异常(运行时异常)

在java中可以捕获的异常(Exception类的子类)分为可控式异常和运行时异常两种类型；可控式异常就是checkedException，运行时异常就是runtimeException；

加入某个位于最低层级的函数被修改为抛出一个异常，如果该异常是可控的，则函数签名就要添加throw子句，这意味着每个调用该函数的函数都要修改，捕获新异常，或在其签名中添加合适的throw子句，一次类推，最终得到的就是一个从软件最低端贯穿到最高端的修改链，封装被打破了，因此在抛出路径中的每个函数都要去了解下一层的异常细节。既然异常旨在让你能在较远处处理错误，可控异常以这种方式破坏封装简直就是一种耻辱；

### 7.4 给出异常发生的环境说明

你抛出的每个异常，都应当提供足够的环境说明，以便判断错误的来源和处所，在Java中，你可以从任何异常得到堆栈踪迹(stack trace)，然而，堆栈踪迹却无法告诉你该失败操作的初衷；

应创建信息充分的错误信息，并和异常一起传递出去，在消息中，包括失败的操作和失败的类型。如果你的应用程序有日志系统，传递足够的信息给catch块，并记录下来；

### 7.5 依调用者需要定义异常类

### 7.6 定义常规流程

### 7.7 别返回null值

### 7.8 别传递null值

在方法中返回null值是糟糕的做法，但将null值传递给其他方法就更糟糕了。除非API要求你向它传递null值，否则就要尽可能避免传递null值；

在大多数编程语言中，没有良好的方法能对付由调用者意外传入的null值，事已如此，恰当的做法就是禁止传入null值，这样，你在编程的时候，就会时时记住参数列表中的null值意味着处问题了，从而大量避免这种无心之失；

### 7.9 小结

整洁代码是可读的，但也要强固，可读与强固并不冲突；

### 7.10 文献

## 第8章 边界

### 8.1 使用第三方代码

### 8.2 浏览和学习边界

### 8.4 学习性测试的好处不只是免费

无论你是否需要学习性测试来学习，总要有一系列与生产代码中调用方式一致的输出测试来支持整洁的边界；不使用这些边界测试来减轻迁移的劳力，我们可能会超出应用的时限，长久地绑在旧版本上面；

### 8.5 使用尚不存在的代码

### 8.6 整洁的边界

### 8.7 文献

## 第9章 单元测试

### 9.1 TDD三定律

- 定律一：在编写不能通过的单元测试前，不可编写生产代码；
- 定律二：只可编写刚好无法通过的单元测试，不能编译也算不通过；
- 定律三：只可编写刚好足以通过当前失败测试的生产代码；

测试代码的要素：可读性；

编写测试用例的模式，或者现有的测试框架提供的测试形式是，构造-操作-检测(BUILD-OPERATE-CHECK)模式，分为三个环节：

1. 构建测试数据；
2. 操作或处理测试数据(即数据进入真实代码走一遭)；
3. 校验真实代码的输出结果是否与预期的一致；

测试的5条(FIRST)准则：快速(Fast)、独立(Independent)、可重复(Repeatable)、自我验证(Self-Validating)、及时(Timely)；

### 9.2 保持测试整洁

测试代码和生产代码一样重要，它可不是二等共鸣；它需要被思考、被设计和被照料，它该像生产代码一般保持整洁；

- 测试带来一切好处：覆盖了生产代码的自动化单元测试程序组能尽可能地保持设计和架构的整洁；测试带来的一切好处，因此测试使改动变得可能；

### 9.3 整洁的测试

整洁测试的要素：可读性；在单元测试中，可读性甚至比在生产代码中还重要，测试如何做到可读，和其他代码中一样：明切、简洁，还有足够的表达力，在测试中，你要以尽可能少的文字表达大量的内容；

编写测试用例的模式，或者现有的测试框架提供的测试形式是，构造-操作-检测(BUILD-OPERATE-CHECK)模式，分为三个环节：

1. 构建测试数据；
2. 操作或处理测试数据(即数据进入真实代码走一遭)；
3. 校验真实代码的输出结果是否与预期的一致；

#### 9.3.1 面向特定领域的测试语言

#### 9.3.2 双重标准

有些事你大概永远不会在生产环境中做，而在测试环境中做却完全没问题，通常这关乎内存或CPU效率问题，不过却永远不会与整洁有关，这就是双重标准；

### 9.4 每个测试一个断言

- 每个测试一个概念：更好一些的规则或许是每个测试函数中只测试一个概念；

### 9.5 F.I.R.ST

快速(Fast)

独立(Independent)

可重复(Repeatable)

自我验证(Self-Validating)：测试应该有布尔值输出；无论是通过或失败，你不应该查看日志文件来确认测试是否通过，你不应该手工对比两个不同文本文件来确认测试是否通过，如果测试不能自足验证，对失败的判断就会变得依赖主观，而运行测试也需要更长的手工操作时间；

及时(Timely)：测试应及时编写；单元测试应该恰好在使其通过的生产代码之前编写，如果在编写生产代码之后编写测试，你会发现生产代码难以测试，你可能会认为某些生产代码本身难以测试，你可能不会去设计可测试的代码；

### 9.6 小结

对于项目的健康度，测试和上产代码同等重要，或许测试更为重要，因为它保证和增强了生产代码的可扩展性、可维护性和可复用性；

### 9.7 文献

## 第10章 类

### 10.1 类的组织

遵循标准的Java规定，类应该从一组变量列表开始，如果有公共静态常量，应该先出现，然后是私有的静态变量，以及私有实体变量，很少会有公共变量；

公共函数应跟在变量列表之后，我们喜欢把由某个公共函数调用的私有工具函数紧随在该公共函数后面，这符合了自动向下原则；

- 封装

### 10.2 类应该短小

关于类的的第一条规则式类应该短小，第二规则是还要更短小；

对于函数，我们通过计算代码行数衡量大小，对于类，我们采用不同的衡量方法，计算权责(responsibility)；

#### 10.2.1 单一权责原则

单一权责原则(SRP)认为，类或者模块应有且只有一条加以修改的理由；该原则既给出了权责的定义，又是关于类的长度的指导方针；类只应有一个 权限-只有一条修改的理由；

让软件能工作和让软件保持整洁，是两种截然不同的工作；我们中的大多数人脑力有限，只能更对地把精力放在让代码能工作上，而不是放在保持代码有组织和整洁上；这全然正确，分而治之，其在编程行为中的重要程度等同于在程序中的重要程度；

问题是太多人在程序能工作时就以为万事大吉了。我们没能把思维转向有关代码组织和整洁的部分，我们直接转向下一个问题，而不是回头将臃肿的类切分为只有单一权责的去耦式单元；

每个达到一定规模的系统都会包括大量逻辑和负责性，管理这种复杂性的首要目标就是加以组织，以便开发者知道带哪儿能找到东西，并且在某个特定时间只需要理解直接有关的复杂性。反之，拥有巨大、多目的类的系统，总是让我们在目前并不需要了解的一大堆东西重艰难跋涉；

再强调一下：系统应该由很多短小的类而不是少量巨大的类组成，每个小类封装一个权责，只有一个修改的原因，并与少数其他类一起协同达成期望的系统行为；

#### 10.2.2 内聚

类应该只有少量实体变量，类中的每个方法都应该操作一个或多个这种变量，通常而言，方法操作的变量越多，就越黏聚到类上，如果一个类的每个变量都被每个方法所使用，则该类具有最大的内聚性；

一般来说，创建这种极大化内聚类是既不可取也不可能的；另一个方面，

#### 10.2.3 保持内聚性就会得到很多短小的类

将大函数拆为小函数，往往也是将类拆分为多个小类的时机，程序会更加有自知，也会拥有更为透明的结构；

### 10.3 为了修改而组织

我们希望将系统打造成在添加或修改特性时尽可能少惹麻烦的架子，在理想系统中，我们通过扩展系统而非修改现有代码来添加新特性；

- 隔离修改：需求会改变，所以代码也会改变；具体类包含实现，而抽象类则只呈现概念，依赖于具体细节的客户类，当细节改变时，就会有风险；我们可以借助接口和抽象类来隔离这些细节带来的影响；

  通过降低连接度，我们的类就遵循了另一条类设计原则，依赖倒置原则(dependency Inversion Principle，DIP)，本质而言，DIP认为类应当依赖于抽象而不是依赖于具体细节；

### 10.4 文献

## 第11章 系统

### 11.1 如何建造一个城市

### 11.2 将系统的构造与使用分开

软件系统应将启始过程和启始过程之后的运行时逻辑分离开，在启始过程中构建应用对象，也会存在互相缠结的依赖关系；

将关注的方面分离开，是软件技艺中最古来也最重要的设计技巧；

#### 11.2.1 分解main

将构造与使用分开的方法之一是将全部构造过程搬迁到main或被称之为main的模块中，设计系统的其余部分时，假设所有对象都已正确构造和设置；

#### 12.2.2 工厂

#### 12.2.3 依赖注入

有一种强大的机制可以实现分离构造与使用，那就是依赖注入(Dependency Injection，DI)，控制反转(Inversion of Controller，IOC)在依赖管理中的一种应用手段，控制反转将第二权责从对象中拿出来，转移到另一个专注于此的对象中，从而遵循了单一权责原则；在依赖管理情景中，对象不应负责实体化对自身的依赖，反之，它应当将这份权责分给其他"有权力"的机制，从而实现控制的反转；因此初始设置是一种全局问题，这种授权机制通常要么是mian例程，要么是有特定目的的容器；

### 13.3 扩容

"一开始就做对系统"纯属神话，反之，我们应该只去实现今天的用户故事，然后重构，明天再扩展系统、实现新的用户故事；这就是迭代和增量敏捷的精髓所在；测试驱动开发、重构以及它们打造出的整洁代码，在代码层面保证了这个过程的实现；

- 横贯式关注面

### 11.4 Java代理

代码量和复杂度是代码的两大弱点；

### 11.5 纯Java AOP框架

### 11.6 AspectJ的方面

### 11.7 测试驱动系统架构

最佳的系统架构由模块化的关注面领域组成，每个关注面均用纯Java(或其他语言)对象实现，不同的领域之间用最不具有侵害性的方面或类方面工具整合起来，这种架构能测试驱动，就像代码一样；

### 11.8 优化策略

延迟决策至最后一刻也是好手段，这不是懒惰或不负责，它让我们能够基于最有可能的信息做出选择；提前决策是一种预备知识不足的决策，如果决策太早，就会缺少太多客户反馈、关于项目的思考和实施经验；

### 11.9 明智使用添加了可论证价值的标准

### 11.10 系统需要领域特定语言

领域特定语言允许所有抽象层级和应用程序中的所有领域，从高级策略到底层细节，使用POJO来表达；

### 11.11 小结

系统也应该是整洁的，侵害性架构会湮灭领域逻辑，冲击敏捷能力；当领域逻辑收到困扰，质量也就堪忧，因此缺陷更易隐藏，用户故事更难实现；当敏捷能力受到损害时，生产力也会降低，TDD的好处遗失殆尽；

在所有的抽象层级上，意图都应该清晰可辨；

### 11.12 文献

## 第12章 跌进

### 12.1 通过跌进设计达到整洁目的

据Kent所述，只要遵循以下规则，设计就能变得"简单"：

- 运行所有测试；
- 不可重复；
- 表达了程序员的意图；
- 尽可能减少类和方法的数量；
- 以上规则按其重要程度排列；

### 12.2 简单设计规则1：运行所有测试

设计必须制造出如预期一般工作的系统，这时首要因素；

全面测试并持续通过所有测试的系统，就是可测试的系统，不可测试的系统同样不可验证，不可验证的系统，绝不应部署；

紧耦合的代码难以编写测试；

遵循有关编写测试并持续运行测试的简单、明确的规则，系统就会更贴近OO低耦合度、高内聚度的目标；编写测试引致更好的设计；

### 12.3 简单设计规则2-4：重构

有了测试，就能保持代码和类的整洁，方法就是递增式地重构代码，添加了几行代码后，就要暂停，琢磨一下变化了的设计；设计退步了吗？如果是，就要整理它，并且运行测试，保证没有破坏任何东西；测试消除了对清理代码就会破坏代码的恐惧；

在重构过程中，可以应用有关优秀软件设计的一切知识；提高内聚性，降低耦合度，切分关注面，模块化系统性关注面，缩小函数和类的尺寸，选用更好的名称，如此等等；这也是应用简单设计后三条规则的地方：消除重复，保证表达力；尽可能减少类和方法的数量；

### 12.4 可不重复

重复是拥有良好设计系统的大敌；它代表着额外的工作、额外风险和额外且不必要的复杂度；重复有多种表现，极其雷同的代码行当然是重复，类似的代码往往可以调整得更相似，这样就能更容易地进行重构；重复也有实现上的重复等其他一些形态；

要向创建整洁的系统，需要有消除重复的意愿，即便对于短短几行也是如此；

"小规模复用"可大量降低系统复杂性，要向实现大规模复用，必须理解如何实现小规模复用；

模板方法模式是一种移除高层级重复的通用技巧；

### 12.5 表达力

软件项目的主要成本在于长期维护；为了在修改时尽量降低出现缺陷的可能性，很有必要理解系统是做什么的；当系统变得越来越复杂，开着就需要越来越多的时间来理解它，而且也极有可能误解；所以，代码应当清晰地表达其作者的意图，作者把代码写的越清晰，其他人花在理解代码上的时间也就越少，从而减少缺陷，缩减维护成本；

可以通过选用号名称来表达；

也可以通过保持函数和类尺寸短小来表达；短小的类和函数通常易于命名，易于编写，易于理解；

还可以通过采用标准命名法来表达；例如，设计模式很大程度上就关乎沟通和表达，通过在实现这些模式的类的名称中采用标准模式名；

编写良好的单元测试也具有表达力；测试的主要目的之一就是通过实例起到文档的作用，读到测试的人应该很快理解某个类是做什么的；

不过，做到表达力的作重要方式确实尝试；有太多时候，我们写出能工作的代码，就转移到下一个问题上，没有下足功夫调整代码，让后来者易于阅读；

所以，多少尊重一下你的手艺吧；花一点点时间在每个函数和类上，选用较好的名称，将大函数切分为小函数，时时照拂自己创建的东西，用心是珍贵的资源；

### 12.6 尽可能少的类和方法

即便是消除重复、代码表达力和SRP等最基础的概念也会被过度使用，为了保持类和函数短小，我们可能会造出太多的细小类和方法，所以这条规则业主张函数和类的数量更少；

### 12.7 小结

### 12.8 文献

## 第13章 并发编程

对象是过程的抽象，线程是调度的抽象；

### 13.1 为什么要并发

并发是一种解耦策略；它帮助我们把做什么(目的)和何时(时机)做分解开；在单线程应用中，目的与时机紧密耦合，很多时候只要查看堆栈追踪即可断定应用程序的状态；

解耦目的与时机能明显地改进应用程序的吞吐量和结构；

### 13.2 挑战

### 13.3 并发编程原则

#### 13.3.1 单一权责原则

单一权责原则(SPR)认为，方法、类、组件应当只有一个修改的理由；并发设计自身足够复杂到成为修改的理由，所以也该从其他代码中分离出来；不幸的是，并发实现细节常常直接嵌入到其他生产代码中，下面是要考虑的一些问题：

- 并发相关代码有自己的开发、修改和调优生命周期；
- 开发相关代码有自己要对付的挑战，和并发相关的代码不同，而且往往更为困难；
- 即便米有周边应用程序增加的负担，写的不好的并发代码可能的出错方式数量也已经足具挑战性；

建议：分离并发相关代码与其他代码；

#### 13.3.2 推论：限制数据作用域

两个线程修改共享对象的同一字段时，可能相互干扰，导致未预期的行为；解决方案之一是采用synchronized关键字在代码中保护一块使用共享对象的临界区(critical section)；限制临界区的数量很重要；

建议：谨记数据封装，严格限制对可能被共享的数据的访问；

#### 13.3.3 推论：使用数据复本

避免共享数据的好方法之一就是一开始就避免共享数据；

#### 13.3.4 推论：线程应尽可能地独立

让每个线程在自己的世界中存在，不与其他线程共享数据；每个线程处理一个客户端请求，从不共享的源头接纳所有请求数据，存储为本地变量，这样一来，每个线程都像是世界中唯一线程，没有同步需要；

建议：尝试将数据分解到可被独立线程(可能在不同处理器上)操作的独立子集；

### 13.4 了解Java库

- 使用类库提供的线程安全集群；
- 使用executor框架(executor framework)执行无关任务；
- 尽可能使用非锁定解决方案；
- 有几个类并不是线程安全的；

### 13.5 了解执行模型

限定资源：并发环境中有着固定尺寸或数量的资源，例如数据库链接和固定寸尺读/写缓存等；

互斥：每一时刻仅有一个线程能访问共享数据或共享资源；

线程饥饿：一个或一组线程在很长时间或永久被禁止；

死锁：两个或多个线程互相等待执行结束，每个线程都拥有其他线程需要的资源，得不到其他线程拥有的资源，就无法终止；

活锁：执行次序一致的线程，每个都想要起步，但发现其他线程已经"在路上"，由于竞步的原因，线程会持续尝试起步，但在很长时间内却无法如愿，甚至永远无法启动；

#### 13.5.1 生产者-消费者模型

生产者和消费者之间的队列是一种限定资源；

#### 13.5.2 读者-作者模型

#### 13.5.3 宴席哲学家

用线程代替哲学家，用资源代替叉子，就变成了很多企业级应用中进程竞争资源的情形；如果没有用心设计，这种竞争形势就会遭遇死锁、活锁、吞吐量和效率降低等问题；

你可能遇到的并发问题，大多数都是这三个问题的变种，请研究并使用这些算法，这样，遇到并发问题时你就能有解决问题的准备了；

建议：学习这些基础算法，理解其解决方案；

### 13.6 警惕同步方法之间的依赖

建议：避免使用一个共享对象的多个方法；

有时必须使用一个对象的多个方法，在这种情况发生时，有3种写对代码的手段；

- 基于客户端的锁定：客户端代码在调用第一个方法前锁定服务端，确保锁的范围覆盖了调用最后一个方法的代码；
- 基于服务端的锁定：在服务端内创建锁定服务端的方法，调用所有方法，然后解锁，让客户端代码调用新方法；
- 适配服务端：创建执行锁定的中间层，这是一种基于服务端的锁定的例子，但不修改原始服务端代码；

### 13.7 保持同步区域微小

建议：尽可能减小同步区域；

### 13.8 很难编写正确的关闭代码

建议：尽早考虑关闭问题，尽早令其工作正常；这会话费比你预期更多的时间，检视既有算法，因为这可能会比想象中难很多；

### 13.9 测试线程代码

证明代码的正确性不切实际；测试并不能确保正确性；然而，好的测试却能尽量降低风险；这对于所有单线程解决方法都是对的，当有两个或多个线程使用同一代码段和共享数据，事情就变得非常复杂；

建议：编写有潜力暴露问题的测试，在不同的编程配置、系统配置和负载条件下频繁运行；如果测试失败，跟踪错误，别因为后来测试通过了后来的运行就忽略失败；

有一大堆问题要考虑，下面是一些精炼的建议：

- 将伪失败看作可能的线程问题；
- 先使非线程代码可工作
- 编写可插拔的线程代码；
- 编写可调整德线程代码；
- 运行多余处理器数量的线程；
- 在不同平台上运行；
- 调整代码并强迫错误发生；

#### 13.9.1 将伪失败看作可能的线程问题

建议：不要将系统错误归咎于偶尔事件；

#### 13.9.2 先使非线程代码可工作

建议：不要同时追踪非线程缺陷和线程缺陷，确保代码在线程之外可工作；

#### 13.9.3 编写可插拔的线程代码

建议：编写可插拔的线程代码，这样就能在不同的配置环境下运行；

#### 13.9.4 编写可调整的线程代码

#### 13.9.5 运行多于处理器数量的线程

系统在切换任务时会发生一些事，为了促使任务交换的发生，运行多于处理器或处理器核心数量的线程，任务交换越频繁，越有可能找到错过临界区域或导致死锁的代码；

#### 13.9.6 在不同的平台行运行

被测试的代码已知是不正确的，这正强调了不同操作系统有着不同线程策略的事实，不同的线程策略影响了代码的执行，在不同的环境中，多线程的行为也不一样，应该在所有可能部署的环境中运行测试；

建议：尽早并经常地在所有目标平台上运行线程代码；

#### 13.9.7 装置试错代码

可以装置代码，增加Object.wait()、Object.sleep()、Object.yield()和Object.priority()等方法的调用，改变代码执行顺序；

这些方法都会影响执行顺序，从而增加了侦测到缺陷的可能性，有问题的代码，最好尽早、尽可能多地通不过测试；

有两种装置代码的方法：硬编码和自动化；

#### 13.9.8 硬编码

你可以手工向代码插入wait()、sleep()、yield()和priority()的调用；

#### 13.9.9 自动化

可以使用Aspect-Oriented Framework、CGLIB或ASM之类工具通过编程来装置代码；

建议：使用异动策略搜出错误；

### 13.10 小结

并发代码很难写正确，加入多线程和共享数据后，简单的代码也会变成噩梦；要编写并发代码，就得严格地编写整洁的代码，否则将面临微细和不频繁发生的失败；

第一要诀是遵循单一权责原则，将系统切分为分离了线程相关代码和线程无关代码的POJO；确保在测试线程相关代码时只是在测试，没有做其他事情；线程相关代码应该保持短小和目的集中；

了解并发问题的可能原因；对共享数据的多线程操作，或使用了公共资源池；类似平静关闭或停止循环之类边界情况一起棘手；

学习类库，了解基本算法；理解类库提供的与基础算法类似的解决问题的特性；

学习如何找到必须锁定的代码区并锁定之；不要锁定不必锁定的代码；避免从锁定区域中调用其他锁定区域；这需要深刻理解某物是否已共享；尽可能减少共享对象和共享范围；修改对象的设计，向客户代码提供共享数据，而不是迫使客户代码管理共享状态；

问题会跳出来，那种在早期没跳出来的那问题往往是偶发的；这种所谓偶发问题，通常仅在高负载下出现或者偶然出现；所以，你要能在不同平台上、以不同配置持续重复运行线程代码；跟随TDD三要则而来的可测试性意味着某种程度的可插拔性，从而提供了在大量不同配置下运行代码的必要支持；

如果花点时间装置代码，就能极大地提升发生错误代码的机会，可以手工做，也可以使用某种自动化技术；尽早这么做；在将线程代码投入生产环境前，就要尽可能多地运行它；

只要采用了整洁的做法，做对的可能性就有翻天覆地的提高；

### 13.11 文献

## 第14章 逐步改进

### 14.1 Args的实现

如果说我们从过去几十年里面学到什么东西的话，那就是编程是一种技艺甚于科学的东西，要编写整洁的代码，必须先写肮脏代码，然后再整理它；

多数新手程序员(就像多数小学生一样)没有特别认真地遵循这个建议，他们相信，首要任务时写出能工作的程序，只要程序"能工作"，就转移到下一个任务上，而那个"能工作"的程序就留在了最后那个所谓"能工作"的状态，对数老手程序员都知道，这是一种自毁行为；

### 14.2 Args：草稿

#### 14.2.1 所以我暂停了

#### 14.2.2 渐进

### 14.3 字符串参数

优秀的软件设计，大都关乎分隔-创建合适的空间放置不同种类的代码，对关注面的分隔让代码更易于理解和维护；

### 14.4 小结

解决之道就是保持代码持续整洁和简单，永不让腐坏有机会开始；

## 第15章 JUnit内幕

### 15.1 JUnit框架

### 15.2 小结

## 第16章 重构SerialDate

### 16.1 首先，让它能工作

### 16.2 让它做对

### 16.3 小结

### 16.4 文献

## 第17章 味道与启发

### 17.1 注释

1. 不恰当的信息：让注释传达本该更好地在源代码控制系统、问题追踪系统或任何其他记录系统中保存的信息，是不恰当的；注释只应该描述有关代码和设计的技术性信息；
2. 废弃的注释：过时、无关或不正确的注释就是废弃的注释；注释会很快过时，最好别编写被废弃的注释，如果发现废弃的注释，最好尽快更新或删除掉；废弃的注释会远离它们曾经描述的代码，编程代码中无关和误导的浮岛；
3. 冗余注释：如果注释描述的是某种充分自我描述了的东西，那么注释就是多余的；注释应该谈及代码自身没提到的东西；
4. 糟糕的注释：值得编写的注释，也值得好好写，如果要编写一条注释，就花时间保证写出最好的注释；字斟句酌，使用正确的语法和拼写；别闲扯，别画蛇添足，保持简洁；
5. 注释掉的代码：看到注释掉的代码，就删除它；别担心，源代码控制系统还会记得它；如果有人真的需要，可以签出较前的版本；别被它搞到死去活来；

### 17.2 环境

1. 需要多步才能实现的构建：构建系统应该是单步的小操作；
2. 需要多步才能做到的测试：你应当能够发出单个指令就可以运行全部单元测试；能够运行全部测试是如此基础和重要，应该快速、轻易和直截了当地做到；

### 17.3 函数

1. 过多的参数：函数的参数量应该少；没参数最好，一个次之，两个、三个再次之；三个以上的参数非常值得质疑，应坚决避免；
2. 输出参数：输出参数违反直觉；读者期望参数用于输入而非输出；如果函数非要修改什么东西的状态不可，就修改它所在对象的状态好了；
3. 标识参数：布尔值参数大声宣告函数做了不止一件事，它们令人迷惑，应该消灭掉；
4. 死函数：永不被调用的方法应该丢弃；保留死代码纯属浪费；别害怕删除函数；记住，源代码控制系统还会记得它；

### 17.4 一般性问题

1. 一个源文件中存在多种语言：理想的源文件包括且只包括一种语言；现实上，我们可能会不得不使用多于一种语言；但应该尽力减少源文件中额外语言的数量和范围；
2. 明显的行为未被实现：遵循"最小惊异原则"(The Principle of Least Superise)，函数或类应该实现其他程序员有理由期待的行为；如果明显的行为未被实现，读者和用户就不能再依靠他们对函数名称的直觉；我们不再信任原作者，不得不阅读代码细节；
3. 不正确的边界行为：没什么可以替代敬小慎微；每种边界条件、每种极端情形、每个异常都代表了某种可能搞乱优雅而直白的算法的东西；别依赖直觉；追索每种边界条件，并编写测试；
4. 忽视安全：忽视安全相当危险；
5. 重复：每次看到重复代码，都代表遗漏了抽象；重复的代码可能成为子程序或干脆是另一个类；将重复代码叠放进类似的抽象，增加了你的设计语言的词汇量；其他程序员可以用到你创建的抽象设施；编码变得越来越快，错误越来越少，因为你提升了抽象层级；
6. 在错误的抽象层级上的代码：
7. 基类依赖于派生类：将概念分解到基类和派生类的最普通的原因是较高层级基类概念可以不依赖于较低层级派生类概念；
8. 信息过多：设计良好的模块有着非常小的接口；优秀的软件开发人员学会限制类或模块中暴露的接口数量；类中的方法越小越好；函数知道的变量越少越好；类拥有的实体变量越少越好；隐藏你的数据，隐藏你的工具函数，隐藏你的常量和你的临时变量；不要创建拥有大量方法或大量实体变量的类；不要为子类创建大量受保护变量和函数；尽力保持接口紧凑；通过限制信息来控制耦合度；
9. 死代码：死代码就是不执行的代码；
10. 垂直分隔：变量和函数应该在靠近别使用的地方定义；本地变量应该正好在其首次被使用的位置上面声明，垂直距离要短；本地变量不该在其被使用之处几百行以外声明；私有函数应该刚好在其首次被使用的位置下面定义；
11. 前后不一致：从一而终，这可以追溯到最小惊异原则，小心选择约定，一旦选中，就小心持续遵循；
12. 混淆视听：没有用到的变量，从不调用的函数，没有信息量的注释，等等，这些都是应该移除的废物，保持源文件整洁，良好地组织，不被搞乱；
13. 人为耦合：不互相依赖的东西不该耦合；一般来说，人为耦合是指两个没有直接目的之间的模块的耦合，其根源是将变量、常量或函数不恰当地放在临时方便的位置；这是种漫不经心的偷懒行为；
14. 特性依恋：类的方法只应对其所属类中的变量和函数感兴趣，不该垂青其他类中的变量和函数，当方法通过某个其他对象的访问器和修改器来操作该对象内部数据，则它就依恋于该对象所属的范围；它期待自己在那个类里面，这样就能直接访问它操作的变量；
15. 选择算子参数：使用多个函数，通常优于向单个函数传递某些代码来选择函数行为；
16. 晦涩的意图：代码要尽可能具有表达力；
17. 位置错误的权责：软件开发者做出的最重要决定之一就是在那里放代码；最小惊异原则在这里起作用了；代码应该放在读者自然而然期待它所在的地方；
18. 不恰当的静态方法：通常应该倾向于选用非静态方法，如果有疑问，就是用非静态函数，如果的确需要静态函数，确保没机会打算让它有多态行为；
19. 使用解释性变量：让程序可读的最有力方法之一就是将计算过程打散成用有意义的单词命名的变量中放置的中间值；解释性变量多比少好；只要把计算过程打散成一系列良好命名的中间值，不透明的模块就会变得透明，这很值得注意；
20. 函数名称应该表达其行为：如果你必须查看函数的实现(或文档)才知道它是做什么的，就该换个更好的函数名，或者重新安排功能代码，放到有较好名称的函数中；
21. 理解算法：
22. 把逻辑依赖改为物理依赖：如果某个模块依赖于另一个模块，依赖就该是物理上的而不是逻辑上的，依赖者模块不应对被依赖者模块有假定(换言之，逻辑依赖)；它应当明确地询问后者全部信息；
23. 用多态提地If/Else或Switch/Case：我使用所谓"单个switch"规则：对于给定的选择类型，不应有多于一个switch语句，在那个switch语句中的多个case，必须创建多态对象，取代系统中其他类似swtich语句；
24. 遵循标准约定：每个团队都应该遵循基于通用行业规范的一套编码标准；编码标准应指定诸如在何处声明实体变量，如何命名类，方法和变量，在何处放置括号，等等；团队不应用文档描述这些约定，因为代码本身提供了范例；
25. 用命名常量替代魔法数：术语"魔术数"不仅是说数字，它泛指任何不能自我描述的符号；
26. 准确：代码中的含糊和不准确要么是意见不同的结果，要么源于懒惰，无论原因是什么，都要消除；
27. 结构甚于约定：坚守结构甚于约定的设计决策，命名约定很好，但却次于强制性的结构；
28. 封装条件：如果没有if或while语句的上下文，布尔逻辑就难以理解，应该把解释了条件意图的函数抽离出来；
29. 避免否定性条件：否定式要比肯定式难明白一些，所以，尽可能将条件表示为肯定形式；
30. 函数只该做一件事：
31. 掩蔽时序耦合：
32. 别随意：
33. 封装边界条件：
34. 函数应该只在一个抽象层级上：函数中的语句应该在同一抽象层级上，该层级应该是函数名所示操作的下一层，这可能是最难理解和遵循的启发；
35. 在较高层级放置可配置数据：如果你有个已知并该在较高抽象层级的默认常量或配置项，不要将它埋藏到较低层级的函数中，把它作为较高层级函数调用低层级函数时的一个参数；
36. 避免传递浏览：通常我们不想让某个模块了解太多其协作者的信息，模块只了解其直接协作者，不了解整个系统的浏览图；正确的做法是让直接协作者提供所需的全部服务，不必逛遍系统的对象全图，搜寻我们要调用的方法；

### 17.5 Java

1. 通过使用通配符避免过长的导入清单：指定导入包是种硬依赖，而通过通配符导入则不是；如果你具体指定导入某个类，该类必须存在，但如果你用通配符导入某个包，则不需要存在具体的类；导入语句只是在搜寻名称时把这个包列入查找路径，所以，这种导入并未构成真正的依赖，也就让那我们的模块较少耦合；通配符导入有时会导致名称冲突和歧义；两个同名但位于不同包中的类需要指名导入，或至少在使用时指定名称；这种情形的确讨厌，不过很罕见，所以使用通配符导入通常仍优于指定名称导入；
2. 不要继承常量：
3. 常量VS枚举：

### 17.6 名称

1. 采用描述性名称：不要太快取名，确认名称具有描述性；记住，事物的意义随着软件的演化而变化，所以，要经常性地重新估量名称是否恰当；
2. 名称应与抽象层级相符：不要取沟通实现的名称，取反映类或函数抽象层级的名称；
3. 尽可能使用标准命名法：如果名称基于既存约定或用法，就比较易于理解；
4. 无歧义的名称：选用不会混淆函数或变量意义的名称；
5. 为较大作用范围选用较长名称：名称的长度应与作用范围的广泛度相关，对于较小的作用范围，可以用很短的名称，而对于较大作用范围就该用较长的名称；
6. 避免编码：不应在名称中包括类型或作用范围的信息；
7. 名称应该说明副作用：名称应该说明函数、变量或类的一切信息，不要用名称掩蔽副作用，不要用简单的动词来描述做了不止一个简单动作的函数；

### 17.7 测试

1. 测试不足：一套测试应该测到宿友可能失败的东西，只要还有没被测试过的条件，或是没有被验证过的计算，测试就还不够；
2. 使用覆盖率工具：覆盖率工具能汇报你测试策略中的缺口，使用覆盖率工具能更容易地找到测试不足的模块、类和函数；
3. 别略过小测试：小测试易于编写，其文档上的价值高于编写成本；
4. 被忽略的测试就是对不正确事物的疑问：
5. 测试边界条件：
6. 全面测试相近的缺陷：缺陷趋向于扎堆，在某个函数中发现一个缺陷时，最好全面测试那个函数，你可能会发现缺陷不止一个；
7. 测试失败的模式有启发性：
8. 测试覆盖率的模式有启发性：
9. 测试应该快速：慢速的测试是不会被运行的测试，时间一紧，较慢的测试就会被摘掉，所以，竭尽所能让测试够快；

### 17.8 小结

该清单确实给出了一套价值体系，这套价值体系才该是目标，也是本书的主题所在，整洁代码并非遵循一套规范写就；

### 17.9 文献

## 附录A 并发编程II

### 1.客户端/服务器的例子

#### 1.1 服务器

#### 1.2 添加线程代码

#### 1.3 观察服务器端

#### 1.4 小结

本例介绍的并发编程，演示了一种提高系统吞吐量的方法，以及一种通过测试框架验证吞吐量的方法；将全部并发代码放到少数类中，是应用单一权责原则的范例；对于并发编程，因其复杂性，这一点尤其重要；

### 2.执行的可能路径

#### 2.1 路径数量

#### 2.2 深入挖掘

在更进一步之前，有三个重要的定义：

- 框架：每个方法调用都需要一个框架，该框架包括返回地址、传入方法的参数、以及方法中定义的本地变量；这时定义一个调用堆栈的标准技术，现代编程语言用来实现基本函数/方法调用和递归调用；
- 本地变量：方法作用范围内定义的每个变量；所有非静态方法至少有一个变量this，代表当前对象，即接受导致方法调用的(当前线程内)大多数最新消息的对象；
- 运算对象栈：Java虚拟机中的很多指令都有参数；运算对象栈是放置参数的地方，堆栈是标准的后入先出(LIFO)数据结构；

#### 2.3 小结

### 3.了解类库

#### 3.1 Executor框架

#### 3.2 非锁定的解决方案

#### 3.3 非线程安全类

注意，有些群集类拥有一些线程安全的方法，不过，涉及调用多个方法的操作都不是线程安全的；

### 4.方法之间的依赖可能破坏并发代码

出现错误时，有3种做法：

- 容忍错误
- 修改客户代码解决问题：基于客户代码的锁定
- 修改服务端代码解决问题，同时也修改了客户代码：基于服务端的锁定

#### 4.1 容忍错误

#### 4.2 基于客户代码的锁定

基于客户代码的锁定是不可靠的；

#### 4.3 基于服务端的锁定

### 5.提升吞吐量

#### 5.1 单线程条件下的吞吐量

#### 5.2 多线程条件下的吞吐量

### 6.死锁

要真正地解决死锁问题，我们需要理解死锁的原因，死锁的发生需要4个条件：

- 互斥；
- 上锁及等待；
- 无抢先机制；
- 循环等待；

#### 6.1 互斥

当多个线程需要使用同一资源，且这些资源满足下列条件时，互斥就会发生：

- 无法在同一时间为多个线程所用；
- 数量上有限制；

这种资源的常见例子是数据库连接、打开后用于写入的文件、记录锁或是信号量；

#### 6.2 上锁及等待

当某个线程获取一个资源，在获取到其他全部所需资源并完成其工作之前，不会释放这个资源；

#### 6.3 无抢先机制

线程无法从其他线程处夺取资源，一个线程持有资源时，其他线程获得这个资源的唯一手段就是等待该线程释放资源；

#### 6.4 循环等待

这也称为"死命拥抱"；

这4中条件都是死锁所必需的，只要其中一个不满足，死锁就不会发生；

#### 6.5 不互斥

避免死锁的一种策略是规避互斥条件，你可以：

- 使用允许同时使用的资源；
- 增加资源数量，使其等于或大于竞争线程的数量；
- 在获取资源之前，检查是否可用；

#### 6.6 不上锁及等待

如果拒绝等待，就能消除死锁；在获得资源之前检查资源，如果遇到某个繁忙资源，就释放所有资源，重新来过；

这种手段带来几个潜在问题：

- 线程饥饿：某个线程一直无法获得它所需的资源(它可能需要某种很少能同时获得的资源组合)；
- 活锁：几个线程可能会前后相连地要求获得某个资源，然后再释放一个资源，如此循环；这在单纯的CPU任务排列算法中尤其有可能出现(想想嵌入式设备或单纯的手写线程平衡算法)；

二者都能导致较差的吞吐量；第一个的结果是CPU利用率低，第二个的结果是较高但无用的CPU利用率；

尽管这种策略听起来没效率，但也好过没有，至少，如果其他方案不凑效，这种手段几乎总可以用上；

#### 6.7 满足抢先机制

避免死锁的另一策略是允许线程从其他线程上夺取资源；这通常利用一种简单的请求机制来实现；当线程发现资源繁忙，就要求其拥有者释放资源；如果拥有者还在等待其他资源，就释放全部资源并重新来过；

这和上一种手段相似，但好处是允许线程等待资源；这减少了线程重新启动的次数；不过，管理所有请求可要花点心思；

#### 6.8 不做循环等待

这时避免死锁的最常用手段，多余多数系统，它只要求一个为各方认可的约定；

更普遍地，如果所有线程都认同一种资源获取次序，并按照这种次序获取资源，死锁就不会发生；就像其他策略一样，这也会有问题：

- 获取资源的次序可能与使用资源的次序不匹配；一开始获取的资源可能在最后才会用到；这可能导致资源不需要地被长时间锁定；
- 有时无法强求资源获取顺序；如果第二个资源的ID来自对第一个资源操作的结果，获取次序也无从谈起；

有很多避免死锁的方法；有些会导致饥饿，另外一些会导致对CPU能力的大量耗费和降低响应率；

将解决方案中与线程相关的部分分隔出来，再加以调整和试验，是获得判断最佳策略所需的洞见的正道；

### 7.测试多线程代码

### 8.测试线程代码的工具支持

### 9.小结

在本章中，我们谈到并发更新，还有清理及避免同步的规程；我们谈到线程如何提升与I/0有关的系统的吞吐量，展示了获得这种提升的整洁技术；我们谈到死锁及干净地避免死锁的规程；最后，我们谈到通过装置代码暴露并发问题的策略；

### 10.教程：完整代码范例

==================================================================

# JAVA核心知识点整理(20210401-)

## 1.JVM

基本概念：JVM是可运行Java代码的假想计算机，包括一套字节码指令集、一组寄存器、一个栈、一个垃圾回收，堆和一个存储方法域；JVM是运行在操作系统之上的，它与硬件没有直接的交互；

我们都知道Java源文件，通过编译器，能够生产相应的.Class文件，也就是字节码文件，而字节码文件又通过Java虚拟机中的解释器，编译成特定机器上的机器码；

每一种平台的解释器是不同的，但是实现的虚拟机是相同的，这也就是Java为什么能够跨平台的原因了，当一个程序从开始运行，这时虚拟机就开始实例化了，多个线程启动就会存在多个虚拟机实例；程序退出或者关闭，则虚拟机实例消亡，多个虚拟机实例之间数据不能共享；

![image-20210401110513265](images/image-20210401110513265.png)

### 1.1 线程

这里所说的线程指程序执行过程中的一个线程实体；JVM允许一个应用并发执行多个线程；Hotspot JVM中的Java线程与原生操作系统线程有直接的映射关系；当线程本地存储、缓冲区分配、同步对象、栈、程序计数器等准备好以后，就会创建一个操作系统原生线程；Java线程结束，原生线程随之被回收；操作系统负责调度所有线程，并把它们分配到任何可用的CPU上；当原生线程初始化完毕，就会调用Java线程的run()方法；当线程结束时，会释放原生线程和Java线程的所有资源；

### 1.2 JVM内存区域

![image-20210401135642250](images/image-20210401135642250.png)

JVM内存区域主要分为线程私有区域(程序计数器、虚拟机栈、本地方法区)、线程共享区域(JAVA堆、方法区)、直接内存；

线程私有数据区域声明周期与线程相同，依赖用户线程的启动/结束而创建/销毁(在Hotspot JVM内，每个线程都与操作系统的本地线程直接映射，因此这部分内存区域的存/否跟随本地线程的生/死对应)；

线程共享区域随虚拟机的启动/关闭而创建/销毁；

直接内存并不是JVM运行时数据区的一部分，但也会被频繁的使用：在JDK1.4引入的NIO提供了基于Channel与Buffer的IO方式，它可以使用Native函数库直接分配堆外内存，然后使用DirectByteBuffer对象作为这块内存的引用进行操作，这样就避免了在Java堆和Native堆中来回复制数据，因此在一些场景中可以显著提高性能；

![image-20210401140803689](images/image-20210401140803689.png)

#### 1.2.1 程序计数器

一块较小的内存空间，是当前线程所执行的字节码的行号指示器，每条线程都要有一个独立的程序计数器，这类内存也称为"线程私有"的内存；

正在执行的java方法的话，计数器记录的是虚拟机字节码指令的地址(当前指令的地址)；如果还是Native方法，则为空；

这个内存区域是唯一一个在虚拟机中没有规定OutOfMemoryError情况的区域；

#### 1.2.2 虚拟机栈(线程私有)

是描述java方法执行的内存模型，每个方法在执行的同时都会创建一个栈帧(Stack Frame)，用于存储局部变量表、操作数栈、动态链接、方法出口等信息；每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机中入栈到出栈的过程；

栈帧(Frame)是用来存储数据和部分过程结果的数据结构，同时也被用来处理动态链接(Dynamic Linking)、方法返回值和异常分派(Dispatch Exception)；栈帧随着方法调用而创建，随着方法结束而销毁-无论方法是正常完成还是异常完成(抛出了在方法内未被捕获的异常)都算作方法结束；

![image-20210401144843978](images/image-20210401144843978.png)

#### 1.2.3 本地方法区(线程私有)

本地方法区和Java Stack作用类似，区别是虚拟机栈为执行Java方法服务，而本地方法栈则为Native方法服务，如果一个VM实现使用C-linkage模型来支持Native调用，那么该栈将会是一个C栈，但Hotspot VM直接就把本地方法栈和虚拟机栈合二为一；

#### 1.2.4 堆(Heap-线程共享)-运行时数据区

是被线程共享的一块内存区域，创建的对象和数组都保存在Java堆内存中，也是垃圾收集器进行垃圾收集的最重要的内存区域；优于现代VM采用分代收集算法，因此Java堆从GC的角度还可以细分为：新生代(Eden区、From Survivor区和To Survivor区)和老年代；

#### 1.2.5 方法区/永久代(线程共享)

即我们常说的永久代(Permanent Genetation)，用于存储被JVM加载的类信息、常量、静态变量、即时编译器编译后的代码等数据；Hotspot VM把GC分代收集扩展至方法区，即使用Java堆的永久代来实现区，这样Hotspot的垃圾收集器就可以像管理Java堆一样管理这部分内存，而不必为方法区开发专门的内存管理器(永久代的内存回收的主要目标是针对常量池的回收和类型的卸载，因此收益一般很小)；

#### 1.2.6 运行时常量池

运行时常量池(Runtime Constant Pool)是方法区的一部分，Class文佳中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池(Constant Pool Table)，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中；Java虚拟机堆Class文件的每一部分(自然也包括常量池)的格式都有严格的规定，每一个字节用于存储那种数据都必须符合规范上的要求，这样才会被虚拟机认可、装载和执行；

### 1.3 JVM运行时内存

Java堆从GC的角度还可以细分为：新生代(Eden区、From Sruvivor区和To Survivor区)和老年代；

![image-20210401222059354](images/image-20210401222059354.png)

#### 1.3.1 新生代

是用来存放新生的对象，一般占据堆的1/3空间；优于频繁创建对象，所以新生代会频繁触发MinorGC进行垃圾回收；新生代又分为Eden区、From Sruvivor和To Survivor三个区；

##### 1.3.1.1 Eden区

Java新对象的出生地(如果新创建的对象占用内存很大，则直接分配到老年代)；当Eden区内存不够的时候就会触发MinorGC，对新生代区进行一次垃圾回收；

##### 1.3.1.2 ServivorFrom

上一次GC的幸存者，作为这一次GC的被扫描者；

##### 1.3.1.3 ServivorTo

保留了一次MinorGC过程中的幸存者；

##### 1.3.1.4 MinorGC的过程(复制-清空-互换)

MinorGC采用复制算法；

1. eden、servivorFrom复制到ServovorTo，年龄+1：首先，把Eden和ServivorFrom区域中存活的对象复制到servivorTo区域(如果有对象的年龄以及达到了老年的标准，则复制到老年代区)，同时把这些对象的年龄+1(如果ServivorTo不够位置了就放到老年区)；
2. 清空eden、servovorFrom：然后，清空Eden和ServivorFrom中的对象；
3. ServivorTo和ServivorFrom互换：最后，ServivorTo和ServivorFrom互换，原ServivorTo成为下一次GC的ServivorFrom区；

#### 1.3.2 老年代

主要存放应用程序中生命周期长的内存对象；

老年代的对象比较稳定，所以MajorGC不会频繁执行；在进行MajorGC前一般都先进行了一次MinorGC，使得有新生代的对象晋升入老年代，导致空间不够用时才触发；当无法找到足够的连续空间分配给新创建的较大对象时也会提前触发一次MajorGC进行垃圾回收腾出空间；

MajorGC采用标记清除算法：首先扫描一次所有老年代，标记出存活的对象，然后回收没有标记的对象；MajorGC的耗时比较长，因此要扫描再回收；MajorGC会产生内存碎片，为了减少内存损耗，我们一般需要进行合并或者标记出来方便下次直接分配；当老年代也满了装不下的时候，就会抛出OOM(Out Of Memory)异常；

#### 1.3.3 永久代

指内存的永久保存区域，主要存放Class和Meta(元数据)的信息，Class在被加载的时候被放入永久区域，它和存放实例的区域不同，GC不会在主程序运行期对永久区域进行清理；所以这也导致了永久代的区域会随着加载的Class的增多而膨胀，最终抛出OOM异常；

##### 1.3.3.1 JAVA8与元数据

在Java8中，永久代已经被移除，被一个称为"元数据区"(元空间)的区域所取代；元空间的本质和永久代类似，元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存；因此，默认情况下，元空间的大小仅受本地内存限制；类的元数据放入native menory，字符串池和类的静态变量放入java堆中，这样可以加载多少类的元数据就不再由MaxPermSize控制，而由系统的实际可用空间来控制；

### 1.4 垃圾回收与算法

![image-20210402090322016](images/image-20210402090322016.png)

#### 1.4.1 如何确定垃圾

##### 1.4.1.1 引用计数法

在Java中，引用和对象是有关联的，如果要操作对象则必须用引用进行；因此，很显然一个简单的办法是通过引用计数来判断一个对象是否可以回收；简单说，即一个对象如果没有任何与之关联的引用，即它们的引用计数为0，则说明对象不太可能再被用到，那么这个对象就是可回收对象；

##### 1.4.1.2 可达性分析

为了解决引用计数法的循环引用问题，Java使用了可达性分析的方法；通过一系列的"GC roots"对象作为起点搜索；如果在"GC roots"和一个对象之间没有可达路径，则称对象是不可达的；要注意的是，不可达对象不等价于可回收对象，不可达对象变为可回收对象至少要经过两次标记过程；两次标记后仍然是可回收对象，则将面临回收；

#### 1.4.2 标记清除算法(Mark-Sweep)

![image-20210402092208162](images/image-20210402092208162.png)

#### 1.4.3 复制算法(copying)

![image-20210402092346719](images/image-20210402092346719.png)![image-20210402092403008](images/image-20210402092403008.png)

#### 1.4.4 标记整理算法(Mark-Compact)

![image-20210402093219783](images/image-20210402093219783.png)

#### 2.4.5 分代收集算法

分代收集法是目前大部分JVM所采用的方法，其核心思想是根据对象存活的不同生命周期将内存划分为不同的域，一般情况下将GC堆划分为老生代(Tenured/Old Generation)和新生代(Young Generation)；老生代的特点是每次垃圾回收时只有少量对象需要被回收，新生代的特点是每次垃圾回收时都有大量垃圾需要被回收，因此可以根据不同区域选择不同的算法；

##### 2.4.5.1 新生代与复制算法

![image-20210402094102916](images/image-20210402094102916.png)

##### 2.4.5.2 老年代与标记复制算法

![image-20210402094203861](images/image-20210402094203861.png)

### 1.5 JAVA四种引用类型

#### 2.5.1 强引用

在Java中最常见的就是强引用，把一个对象赋给一个引用变量，这个引用变量就是一个强引用；当一个对象被强引用变量引用时，它处于可达状态，它是不可能被垃圾回收机制回收的，即使该对象以后永远不会被应到JVM也不会回收；因此强引用时造成Java内存泄漏的主要原因之一；

#### 2.5.2 软引用

软引用需要用SoftReference类来实现，对于只有软引用的对象来说，当系统内存足够时它不会被回收，当系统内存空间不足时它会被回收；软引用通常用来对内存敏感的程序中；

#### 2.5.3 弱引用

弱引用需要用WeakReference类来实现，它比软引用的生存期更短，对于只有弱引用的对象来说，只要垃圾回收机制一运行，不管JVM的内存空间是否足够，总会回收该对象占用的内存；

#### 2.5.4 虚引用

虚引用需要PhantomReference类来实现，它不能单独使用，必须和引用队列联合使用；虚引用的主要作用是跟踪对象被垃圾回收的状态；

### 1.6 GC分代收集算法VS分区收集算法

#### 1.6.1 分代收集算法

当前主流VM垃圾收集都采用"分代收集"(Generational Collection)算法，这种算法会根据对象存活周期的不同将内存划分为几块，入JVM中的新生代、老年代、永久代，这样就可以根据各年代特点分别采用最恰当的GC算法；

##### 1.6.1.1 在新生代-复制算法

每次垃圾收集都能发现大批对象已死，只有少量存活，因此选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集；

##### 1.6.1.2 在老年代-标记整理算法

因为对象存活率高、没有额外空间对它进行分配担保，就必须采用"标记-清理"或"标记-整理"算法来进行回收，不必进行内存复制，且直接腾出空间内存；

#### 1.6.2 分区收集算法

分区算法则将整个怼空间划分为连续的不同小区间，每个小区间独立使用，独立回收，这样做的好处是可以控制一次回收多少个小区间，根据目标停顿时间，每次合理回收若干个小区间(而不是整个堆)，从而减少一次GC所产生的停顿；

### 1.7 GC垃圾收集器

![image-20210402111410727](images/image-20210402111410727.png)

#### 1.7.1 Serial垃圾收集器(单线程、复制算法)

![image-20210402112828710](images/image-20210402112828710.png)

#### 1.7.2 ParNew垃圾收集器(Serial+多线程)

![image-20210402112941954](images/image-20210402112941954.png)

#### 1.7.3 Parallel Scavenge收集器(多线程复制算法、高效)

![image-20210402143248799](images/image-20210402143248799.png)

#### 1.7.4 Serial Old收集器(单线程标记整理算法)

![image-20210402150922259](images/image-20210402150922259.png)![image-20210402150937396](images/image-20210402150937396.png)

#### 1.7.5 Parallel Old收集器(多线程标记整理算法)

![image-20210404093536396](images/image-20210404093536396.png)

#### 1.7.6 CMS收集器(多线程标记清除算法)

![image-20210404093653560](images/image-20210404093653560.png)![image-20210404093730622](images/image-20210404093730622.png)

#### 1.7.7 G1收集器

![image-20210404094043534](images/image-20210404094043534.png)

### 1.8 JAVA/NIO

#### 1.8.1 阻塞IO模型

最传统的一种IO模型，即在读写数据过程中会发生阻塞现象；当用户线程发出IO请求后，内核会去查看数据是否就绪，如果没有就绪就会等待数据就绪，而用户线程就会处于阻塞状态，用户线程交出CPU；当线程就绪之后，内核会将数据拷贝到用户线程，并返回结果给用户线程，用户线程才解除block状态；典型的阻塞IO模型的例子为：data=socket.read()；如果数据没有就绪，就会一直阻塞在read方法；

#### 1.8.2 非阻塞IO模型

![image-20210404094759543](images/image-20210404094759543.png)

#### 1.8.3 多路复用IO模型

多路复用IO模型是目前使用得比较多的模型；Java NIO实际上就是多路复用IO；在多路复用IO模型中，会有一个线程不断去轮询多个socket的状态，只有当socket真正有读写事件时，才真正调用实际的IO读写操作；因为在多路复用IO模型中，只需要使用一个线程就可以管理多个socket，系统不需要建立新的进程或者线程，也不必维护这些线程和进程，并且只有在真正有socket读写事件进行时，才会使用IO资源，所以它大大减少了资源占用；在Java NIO中，是通过selector.select()去查询每个通道是否有到达事件，如果没有事件，则一直阻塞在那里，因此这种方式会导致用户线程阻塞；多路复用IO模式，通过一个线程就可以管理多个socket，只有当socket真正有读写事件发生才会占用资源来进行实际的读写操作；因此，多路复用IO比较适合连接数比较多的情况；

另外多路复用IO为何比阻塞IO模型的效率高是因为在非阻塞IO中，不断地询问socket状态时通过用户线程去进行的，而在多路复用IO中，轮询每个socket状态是内核在进行的，这个效率要比用户线程要高的多；

不过要注意的是，多路复用IO模型是通过轮询的方式来检测是否有事件到达，并且对到达的事件逐一进行响应；因此对于多路复用IO模型来说，一旦事件响应体很大，那么就会导致后续的事件迟迟打不到处理，并且会影响新的事件轮询；

#### 1.8.4 信号驱动IO模型

在信号驱动IO模型中，当用户线程发起一个IO请求操作，会给对应的socket注册一个信号函数，然后用户线程会继续执行，当内存数据就绪时会发送一个信号给用户线程，用户线程接收到信号之后，便在信号函数中调用IO读写操作来进行实际的IO请求操作；

#### 1.8.5 异步IO模型

![image-20210404101938259](images/image-20210404101938259.png)

#### 1.8.6 JAVA IO包

![image-20210404102240346](images/image-20210404102240346.png)

#### 1.8.7 JAVA NIO

NIO主要有三大核心部分：Channel(通道)、Buffer(缓冲区)、Selector(选择区)；传统IO基于字节流和字符流进行操作，而NIO基于Channel和Buffer进行操作，数据总是从通道读取到缓冲区，或者从缓冲区写入到通道中；Selector用于监听多个通道的事件(比如：连接打开，数据到达)；因此，单个线程可以监听多个数据通道；

NION和传统IO之间第一个最大的区别是，IO是面向流的，NIO是面向缓冲区的；

![image-20210404103018080](images/image-20210404103018080.png)

##### 1.8.7.1 NIO的缓冲区

JAVA IO面向流意味着每次从流中读一个或多个字节，直至读取所有字节，它们没有被缓存在任何地方；此外，它不能前后移动流中的数据；如果需要前后移动从流中读取的数据，需要先将它缓存到一个缓冲区；NIO的缓冲导向方法不同；数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动；这增加了处理过程的灵活性；但是，还需要检查时候该缓冲区中包含所有需要处理的数据；而且，需确保当更多的数据读入缓冲区时，不要覆盖缓冲区里尚未处理的数据；

##### 1.8.7.2 NIO的非阻塞

![image-20210404104206852](images/image-20210404104206852.png)

![image-20210404104309242](images/image-20210404104309242.png)

#### 1.8.8 Channel

![image-20210404104423314](images/image-20210404104423314.png)

#### 1.8.9 Buffer

![image-20210404104724778](images/image-20210404104724778.png)

#### 1.8.10 Selector

![image-20210404104938623](images/image-20210404104938623.png)

### 1.9 JVM类加载机制

#### 1.9.1 JVM类加载过程

![image-20210404111653733](images/image-20210404111653733.png)

##### 1.9.1.1 加载

加载是类加载过程中一个阶段，这个阶段会在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的入口；注意这里不一定非得要从一个Class文件获取，这里即可以从ZIP包中读取(比如从jar包和war包中读取)，也可以在运行时计算生成(动态代理)，也可以由其他文件生成(比如将JSP文件转换成对应的Class文件)；

##### 1.9.1.2 验证

这一阶段的主要目的是为了确保Class文件的字节流中包含的信息是否符合当前虚拟机的要求，并且不会危害虚拟机自身的安全；

##### 1.9.1.3 准备

![image-20210404113355763](images/image-20210404113355763.png)

##### 1.9.1.4 解析

![image-20210404113631942](images/image-20210404113631942.png)

##### 1.9.1.5 符号引用

符号引用与虚拟机实现的布局无关，引用的目标并不一定要已经加载到内存中；各种虚拟机实现的内存布局可以各不相同，但是他们能接受的符号引用必须是一致的，因为符号引用的字面量形式明确定义在Java虚拟机规范的Calss文件格式中；

##### 1.9.1.6 直接引用

直接引用可以是指向目标的指针，相对偏移量或是一个能间接定位到目标的句柄；如果有了直接引用，那引用的目标必定已经在内存中存在；

##### 1.9.1.7 初始化

初始化阶段是类加载的最后一个阶段，前面的类加载阶段之后，除了在加载阶段可以自定义加载器以外，其他操作都由JVM主导；到了初始阶段，才开始真正执行类中定义的Java程序代码；

##### 1.9.1.8 类构造器 <client>

![image-20210404114612411](images/image-20210404114612411.png)

#### 1.9.2 类加载器

##### 1.9.2.1 启动类加载器(Bootstrap ClassLoader)

负责加载JAVA_HOME\lib目录中的，或通过-Xbootclasspath参数指定路径中的，且被虚拟机认可(按文件名识别，如rt.jar)的类；

##### 1.9.2.2 扩展类加载器(Extension ClassLoader)

负责加载JAVA_HOME\lib\ext目录中，或通过java.ext.dirs系统变量指定路径中的类库；

##### 1.9.2.3 应用程序类加载器(Application ClassLoader)

负责加载用户路径(classpath)上的类库；

JVM通过双亲委托模型进行类的加载，当然我们也可以通过继承java.lang.ClassLoader实现自定义的类加载器；

![image-20210406091849721](images/image-20210406091849721.png)

#### 1.9.3 双亲委托

当一个类收到了类加载请求，它首先不会尝试自己去加载这个类，二十把这个请求委派给父类去完成，每一个层级类加载器都是如此，因此所有的加载请求都应该传送到启动类加载其中，只有当父类加载器反馈自己无法完成这个请求的时候(在它的加载路径下没有找到所需加载的Class)，子类加载器才会尝试自己去加载；

采用双亲委派的一个好处是比如加载位于rt.jar包中的类java.lang.Object，不管是哪个加载器加载这个类，最终都是委托给顶层的启动类加载器进行加载，这样就保证了使用不能的类加载器最终得到的都是同样一个Object对象；

![image-20210406092811672](images/image-20210406092811672.png)

#### 1.9.4 OSGI(动态模型系统)

OSGI(Open Service Gateway Initiative)，是面向Java的动态模型系统，是Java动态化模块化系统的一系列规范；

##### 1.9.4.1 动态改变构造

OSGI服务平台提供在多种网络设备上无需重启的动态改变构造的功能，为了最小化耦合度和促使这些耦合度可管理，OSGI技术提供一种面向服务的框架，它能使这些组件动态地发现对方；

##### 1.9.4.2 模块化编程与热插拔

OSGI旨在为实现Java程序的模块化编程提供基础条件，基于OSGI的程序可能可以实现模块级的热插拔功能，当程序升级更新时，可以只停用、重新安装然后启动程序的其中一部分，这对企业级程序开发来说是非常具有诱惑力的特性；

OSGI描绘了一个很美好的模块化开发目标，而且定义了实现这个目标的所需要服务于框架，同时也有成熟的框架进行实现支持；但并非所有的应用都适合采用OSGI作为基础架构，它在提供强大功能同时，也引入了额外的复杂度，因为它不遵守了类加载的双亲委托模型；

## 2.JAVA集合

### 2.1 接口继承关系和实现

![image-20210406095835706](images/image-20210406095835706.png)

![image-20210406095930064](images/image-20210406095930064.png)

### 2.2 List

![image-20210406100213856](images/image-20210406100213856.png)

#### 2.2.1 ArrayList(数组)

ArrayList是最常用的List实现类，内部是通过数组实现的，它允许对元素进行快速随机访问；数组的缺点是每个元素之间不能有间隔，当数组大小不满足时需要增加存储能力，就要将已经有数组的数据复制到新的存储空间中；当ArrayList的中间位置插入或者删除元素时，需要对数组进行复制、移动、代码比较高；因此，它适合随机查找和遍历，不适合插入和删除；

#### 2.2.2 Vector(数组实现、线程同步)

Vector与ArrayList一样，也是通过数组实现的，不同的是它支持线程同步，即某一时刻只有一个线程能够写Vector，避免多线程同时写而引起的不一致性，但实现同步需要很高的花费，因此，访问它比访问ArrayList慢；

#### 2.2.3 LinkList(链表)

LinkList是用链表结构存储数据的，很适合数据的动态插入和删除，随机访问和遍历速度比较慢；另外，它还提供了List接口中没有定义的方法，专门用于操作表头和表尾元素，可以当作堆栈、队列和双向队列使用；

### 2.3 Set

![image-20210406102141123](images/image-20210406102141123.png)

#### 2.3.1 HashSet(Hash表)

![image-20210406102711061](images/image-20210406102711061.png)![image-20210406102730587](images/image-20210406102730587.png)

#### 2.3.2 TreeSet(二叉树)

![image-20210406103010073](images/image-20210406103010073.png)

#### 2.3.3 LinkHashSet(HashSet+LinkedHashMap)

![image-20210406103108745](images/image-20210406103108745.png)

### 2.4 Map

![image-20210406103202767](images/image-20210406103202767.png)

#### 2.4.1 HashMap(数组+链表+红黑树)

![image-20210406104943115](images/image-20210406104943115.png)

##### 2.4.1.1 JAVA7实现

![image-20210406105118543](images/image-20210406105118543.png)![image-20210406105131231](images/image-20210406105131231.png)

##### 2.4.1.2 JAVA8实现

![image-20210406105313617](images/image-20210406105313617.png)

#### 2.4.2 ConcurrentHashMap

##### 2.4.2.1 Segment段

![image-20210406105930139](images/image-20210406105930139.png)

##### 2.4.2.2 线程安全(Segment继承ReentrantLock加锁)

![image-20210406110012272](images/image-20210406110012272.png)![image-20210406110134931](images/image-20210406110134931.png)

##### 2.4.2.3 并行度(默认16)

![image-20210406110236721](images/image-20210406110236721.png)

##### 2.4.2.4 Java8实现(引入红黑树)

![image-20210406110304557](images/image-20210406110304557.png)

#### 2.4.3 HashTable(线程安全)

![image-20210406112439219](images/image-20210406112439219.png)

#### 2.4.4 TreeMap(可排序)

![image-20210406222115436](images/image-20210406222115436.png)

#### 2.4.5 LinkHashMap(记录插入排序)

![image-20210406222226363](images/image-20210406222226363.png)

## 3.JAVA多线程并发

### 4.1 JAVA并发知识库

![image-20210406223319611](images/image-20210406223319611.png)

### 4.2 JAVA线程实现/创建方式

#### 4.2.1 继承Thread类

![image-20210406223845284](images/image-20210406223845284.png)

#### 4.2.2 实现Runnable接口

![image-20210406224029247](images/image-20210406224029247.png)![image-20210406224046678](images/image-20210406224046678.png)

#### 4.2.3 ExecutorService、Callable<Class>、Future有返回值线程

![image-20210406224152861](images/image-20210406224152861.png)

#### 4.2.4 基于线程池的方式

![image-20210406224301327](images/image-20210406224301327.png)

### 4.3 4种线程池

Java里面线程池的顶级接口是Executor，但是严格意义上讲Executor并不是一个线程池，而只是一个执行线程的工具；真正的线程池接口是ExecutorService；

![image-20210406224721662](images/image-20210406224721662.png)

#### 4.3.1 newCachedThreadPool

创建一个可根据需要创建新线程的线程池，但是在以前构造的线程可用时将重用它们；对于执行很多短期异步任务的程序而言，这些线程池通常可提高程序性能；调用execute将重用以前构造的线程(如果线程可用)；如果现有线程没有可用的，则创建一个新线程并添加到池中；终止并从缓存中移除那些已有60秒未被使用的线程；因此，长时间保持空闲的线程池不会使用任何资源；

#### 4.3.2 newFixedThreadPool

创建一个可重用固定线程数的线程池，以共享的无界队列方式来运行这些线程；在任意点，这大多数nThread线程会处于处理任务的活动状态；如果在所有线程处于活动状态时提交附加任务，则在有可用线程之前，附加任务将在队列中等待；如果在关闭前的执行期间由于失败而导致任何线程终止，那么一个新线程将代替它执行后续的任务(如果需要)；在某个线程被显示地关闭之前，池中的线程将一直存在；

#### 4.3.3 newScheduledThreadPool

![image-20210406225946809](images/image-20210406225946809.png)

#### 4.3.4 newSingleThreadExecutor

![image-20210406230028271](images/image-20210406230028271.png)

### 4.4 线程生命周期(状态)

![image-20210406230953604](images/image-20210406230953604.png)

#### 4.4.1 新建状态(NEW)

![image-20210406231254161](images/image-20210406231254161.png)

#### 4.4.2 就绪状态(RUNNABLE)

![image-20210406231310177](images/image-20210406231310177.png)

#### 4.4.3 运行状态(RUNNING)

![image-20210406231331663](images/image-20210406231331663.png)

#### 4.4.4 阻塞状态(BLOCKED)

![image-20210406231429346](images/image-20210406231429346.png)

#### 4.4.5 线程死亡(DEAD)

![image-20210406231747100](images/image-20210406231747100.png)![image-20210406231801662](images/image-20210406231801662.png)

### 4.5 终止线程4种方式

#### 4.5.1 正常运行结束

程序运行结束，线程自动结束；

#### 4.5.2 使用退出标志退出线程

![image-20210407091232802](images/image-20210407091232802.png)

#### 4.5.3 Interrupt方法结束线程

使用interrupt()方法来中断程序有两种情况：

1. 线程处于阻塞状态：如使用了sleep，同步锁的wait，socket中的receiver，accept等方法时，会使线程处于阻塞状态；当调用线程的interrupt()方法时，会抛出InterruptExcepution异常；阻塞中的那个方法抛出这个异常，通过代码捕获该异常，然后break跳出循环状态，从而让我们有机会结束这个线程的执行；通常很多人认为只要调用interrupt方法线程就会结束，实际上是错的，一定要先捕获IinterruptExcepution异常之后通过break来跳出循环，才能正常结束run方法；

2. 线程未处于阻塞状态：使用isInterrupted()判断线程的中断标志来退出循环；当使用interrupt()方法时，中断标志就会置true，和使用自定义的标志来控制循环是一样的道理；

   ![image-20210407094133130](images/image-20210407094133130.png)



#### 4.5.4 stop方法终止线程(线程不安全)

程序中可以直接使用thread.stop()来强行终止线程，但是stop方法时很危险的，就像突然关闭计算机电源，而不是按照正常程序关机一样，可能会产生不可预料的结果，不安全主要是：thread.stop()调用之后，创建子线程的线程就会抛出ThreadDeatherror的错误，并且会释放子线程所持有的所有锁；一般任何进行加锁的代码块，都是为了保护数据的一致性，如果在调用thread.stop()后导致了该线程所持有的所有锁的突然释放(不可控制)，那么被保护数据就有可能呈现不一致性，其他线程在使用这些被破坏的数据时，有可能导致一些很奇怪的应用程序错误；因此，并不推荐使用stop方法来终止线程；

### 4.6 sleep与wait区别

1. 对于sleep()方法，我们首先要知道该方法时属于Thread类中的；而wait()方法，则是属于Object类中的；
2. sleep()方法导致了程序暂停执行指定的时间，让出CPU给其他线程，但是它的监控状态依然保持着，当指定的时间到了又会恢复到运行状态；
3. 在调用sleep()方法的过程中，线程不会释放对象锁；
4. 而当调用wait()方法的时候，线程会放弃对象锁，进入等待对象的等待锁定池，只有针对此对象调用notify()方法后本线程才进入对象锁定池准备获取独享锁进入运行状态；

### 4.7 start与run区别

1. start()方法来启动线程，真正实现了多线程运行；这时无需等待run方法体代码执行完毕，可以直接继续执行下面的代码；
2. 通过调用Thread类的start()方法来启动一个线程，这时此线程是处于就绪状态，并没有运行；
3. 方法run()称为线程体，它包含了要执行的这个线程的内容，线程就计入了运行状态，开始运行run函数当中的代码；Run方法运行结束，此线程终止，然后CPU再调度其他线程；

### 4.8 JAVA后台线程

![image-20210407101159894](images/image-20210407101159894.png)

### 4.9 JAVA锁

#### 4.9.1 乐观锁

乐观锁是一种乐观思想，即认为读多写少，遇到并发写的可能性低，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，采取在写时才读出当前版本号，然后加锁操作(比较跟上一次的版本号，如果一样则更新)，如果失败则要重复读-比较-写的操作；

java中的乐观锁基本都是通过CAS操所实现的，CAS是一种更新的原子操作，比较当前值跟传入值是否一样，一样则更新，否则失败；

#### 4.9.2 悲观锁

悲观锁就是悲观思想，即认为写多，遇到并发写的可能性高，每次去拿数据的时候都认为别人会修改，所以每次在读写数据的时候都会上锁，这样别人想读写这个数据就会block直到拿到锁；java中的悲观锁就是Synchronized，AQS框架下的锁则是先尝试去获取锁，获取不到，才会转换为悲观锁，入ReentrantLock；

#### 4.9.3 自旋锁

自旋锁原理非常简单，如果持有锁的线程能在很短时间内释放锁资源，那么那些等待竞争锁的线程就不需要做内核态和用户态之间的切换进入阻塞挂起状态，它们只需要等一等(自旋)，等持有锁的线程释放锁后即可立即获取锁，这样就避免用户线程和内核的切换的消耗；

线程自旋是需要消耗CPU的，说白了就是让CPU在做无用功，如果一直获取不到锁，那线程也不能一直占用CPU自旋做无用功，所以需要设定一个自旋等待的最大时间；

如果持有锁的线程执行的时间超过自旋等待的最大时间仍没有释放锁，就会导致其他争用锁的线程在做大等待时间内还是获取不到锁，这时争用线程会停止自旋进入阻塞状态；

**自旋锁的优缺点：**

自旋锁尽可能的减少线程的阻塞，这对于锁的竞争不激烈，且占用锁时间非常短的代码块来说性能能大幅度的提升，因为自旋的消耗会小于线程阻塞挂起再唤醒的操作的消耗，这些操作会导致线程发生两次上下文切换；

但是如果锁的竞争激烈，或者持有锁的线程需要长时间占用锁执行同步块，这时候就不适合使用自旋锁了，因为自旋锁在获取锁前一直都是占用CPU做无用功，同时有大量线程在竞争一个锁，会导致获取锁的时间很长， 线程自旋的消耗大于线程阻塞挂起操作的消耗，其他需要CPU的线程又不能获取到CPU，造成CPU的浪费；所以这种情况下我们要关闭自旋锁；

**自旋锁时间阈值(1.6引入了适应性自旋锁)：**

![image-20210407210628804](images/image-20210407210628804.png)![image-20210407210640731](images/image-20210407210640731.png)

**自旋锁的开启：**
![image-20210407210722795](images/image-20210407210722795.png)

#### 4.9.4 Synchronized同步锁

![image-20210407211029103](images/image-20210407211029103.png)![image-20210407211058299](images/image-20210407211058299.png)![image-20210407211931885](images/image-20210407211931885.png)

#### 4.9.5 ReentrantLock

ReentrantLock继承接口Lock并实现了接口定义的方法，它是一种可重入锁，除了能完成synchronized所能完成的所有工作外，还提供了诸如可响应中断锁、可轮询锁请求、定时锁等避免多线程死锁的方法；

**Lock接口的主要方法：**

![image-20210407213720767](images/image-20210407213720767.png)![image-20210407213740606](images/image-20210407213740606.png)

**非公平锁：**

JVM按随机、就近原则分配锁的机制则称为不公平锁，ReentrantLock在构造函数中提供了是否公平锁的初始化方式，默认为非公平锁；非公平锁实际执行的效率要远远超出公平锁，除非程序有特殊需要，否则最常用非公平锁的分配机制；

**公平锁：**

公平锁指的是锁的分配机制是公平的，通常先对锁提出获取请求的线程会先被分配到锁，ReentrantLock在构造函数中提供了是否公平锁的初始化方式来定义公平锁；

**ReentrantLock与synchronized：**

![image-20210407225903131](images/image-20210407225903131.png)![image-20210407225929855](images/image-20210407225929855.png)![image-20210407230024344](images/image-20210407230024344.png)

**Condition类和Object类锁方法区别：**

![image-20210407230134505](images/image-20210407230134505.png)

**tryLock和lock和lockInterruptibly的区别**：

![image-20210407230303492](images/image-20210407230303492.png)

#### 4.9.6 Semaphore信号量

Semaphore是一种基于计数的信号量；它可以设定一个阈值，基于此，多个线程竞争获取许可信号，做完自己的申请后归还，超过阈值后，线程申请许可信号将会被阻塞；Semaphore可以用来构建一些对象池，资源池之类的，比如数据库连接池；

**实现互斥锁(计数器为1)：**

![image-20210407230827941](images/image-20210407230827941.png)![image-20210407230844803](images/image-20210407230844803.png)

**Semaphore与ReentrantLock：**

![image-20210407231014690](images/image-20210407231014690.png)

#### 4.9.7 AtomicInteger

![image-20210407231122550](images/image-20210407231122550.png)

#### 4.9.8 可重入锁(递归锁)

![image-20210407231406450](images/image-20210407231406450.png)

#### 4.9.9 公平锁与非公平锁

**公平锁(Fair)：**

加锁前检查是否有排队等待的线程，优先排队等待的线程，先来先得；

**非公平锁(Nonfair)：**

加锁时不考虑排队等待问题，直接尝试获取锁，获取不到自动到队尾等待；

1. 非公平锁性能比公平锁高5-10倍，因为公平锁需要在多核的情况下维护一个队列；
2. Java中的synchronized是非公平锁，ReentrantLock默认的lock()方法采用的是非公平锁；

#### 4.9.10 ReadWriteLock读写锁

为了提高性能，Java提供了读写锁，在读的地方使用读锁，在写的地方使用写锁，灵活控制，如果没有写锁的情况下，读是无阻塞的，在一定程度上提高了程序的执行效率；读写锁分为读锁和写锁，多个读锁不互斥，读锁与写锁互斥，这是由JVM自己控制的，你只要上好相应的锁即可；

**读锁：**

如果你的代码只读数据，可以很多人同时读，但不能同时写，那就上读锁；

**写锁：**

如果你的代码修改数据，只能有一个人在写，且不能同时读取，那就上写锁；总之，读的时候上读锁，写的时候上写锁；

Java中读写锁有个接口java.util.concurrent.locks.ReadWriteLock，也有具体的实现ReentrantReadWriteLock；

#### 4.9.11 共享所和独占锁

java并发包提供的加锁模式分为独占锁和共享锁；

**独占锁：**

独占模式下，每次只有一个线程能持有锁，ReentrantLock就是以独占方式实现的互斥锁；独占锁是一种悲观保守的加锁策略，它避免了读/读冲突，如果某个读线程获取锁，那其他读线程都只能等待，这种情况下就限制了不必要的并发性，因为读操作并不会影响数据的一致性；

**共享锁：**

共享锁则允许多个线程同时获取锁，并发访问共享资源，如：ReadWriteLock；共享锁则是一种乐观锁，它放宽了加锁策略，允许多个执行读操作的线程同时访问共享资源；

1. AQS的内部类Node定义了两个常量SHARED和EXCLUSIVE，它们分别标识AQS队列中等待线程的锁获取模式；
2. java的并发包中提供了ReadWriteLock，读-写锁；它允许一个资源可以被多个读操作访问，或者被一个写操作访问，但两者不能同时进行；

#### 4.9.12 重量级锁(Mutex Lock)

Synchronized是通过对象内部的一个叫做监视器锁(monitor)来实现的；但是监视器本质又是依赖于底层的操作系统的Mutex Lock来实现的；而操作系统实现线程之间的切换这就需要从用户态切换到核心态，这个成本非常高，状态之间的切换需要相对比较长的时间，这就是为什么Synchronized效率低的原因；因此，这种依赖于操作系统Mutex Lock所实现的锁我们称之为"重量级锁"；JDK中对Synchronized做的种种优化，其核心都是为了减少这种重量级锁的使用；JDK1.6以后，为了减少获得锁和释放锁所带来的性能消耗，提高性能，引入了"轻量级锁"和"偏向锁"；

#### 4.9.13 轻量级锁

锁的状态总共有四种：无锁状态、偏向锁、轻量级锁和重量级锁；

**锁升级：**

随着锁的竞争，锁可以从偏向锁升级到轻量级锁，再升级的重量级锁(但是锁的升级是单向的，也就是说只能从低到高升级，不会出现锁的降级)；

"轻量级"是相对于使用操作系统互斥量来实现的传统锁而言的；但是，首先需要强调一点的是，轻量级锁并不是用来代替重量级锁的，它的本意是在没有多线程竞争的前提下，减少传统的重量级锁使用产生的性能消耗；在解释轻量级锁的执行过程之前，先明白一点，轻量级锁锁适应的场景是线程交替执行同步块的情况，如果存在同一时间访问同一所得情况，就会导致轻量级锁膨胀为重量级锁；

#### 4.9.14 偏向锁

Hotspt的作者经过以往的研究发现大多数情况下锁不仅不存在多线程竞争，而且总是由同一线程多次获得；偏向锁的目的是在某个线程获得锁之后，消除这个线程重入(CAS)的开销，看起来让这个线程得到了偏护；引入偏向锁是为了在无多线程竞争的情况下减少不必要的轻量级锁执行路径，因为轻量级锁的获取及释放依赖多次CAS原子指令，而偏向锁只需要在置换ThreadID的时候依赖一次CAS原子指令(由于一旦出现多线程竞争的情况就必须撤销偏向锁，所以偏向锁的撤销操作的性能损耗必须小于节省下来的CAS原子指令的性能消耗)；上面说过，轻量级锁是为了在线程交替执行同步块时提高性能，而偏向锁则是在只有一个线程执行同步块时进一步提高性能；

#### 4.9.15 分段锁

分段锁也并非一种实际的锁，二十一种思想ConcurrentHashMap是学习分段锁的最好实践；

#### 4.9.16 锁优化

**减少锁持有时间**：

只用在有线程安全要求的程序上加锁；

**减少锁粒度：**

将大对象(这个对象可能会被很多线程访问)，拆成小对象，大大增加并行度，降低锁竞争；降低了锁的竞争，偏向锁，轻量级锁成功率才会提高；最最典型的减少锁粒度的案例就是ConcurrentHashMap；

**锁分离：**

最常见的锁分离就是读写锁ReadWriteLock，根据功能进行分离成读锁和写锁，这样读读不互斥，读写互斥，写写互斥，即保证了线程安全，有提高了性能，具体也请查看[高并发Java五]JDK并发包1；读写分离思想可以延伸，只要操作不影响，锁就可以分离，比如LinkedBlockingQueue从头部取出，从尾部放数据；

**锁粗化：**

通常情况下，为了保证多线程间的有效并发，会要求每个线程持有锁的时间尽量短，即在使用完公共资源后，应该立即释放锁；但是，凡事都有一个度，如果对同一个锁不停的进行请求、同步和释放，其本身也会消耗系统宝贵的资源，反而不利于性能的优化；

**锁消除：**

锁消除是在编译器级别的事情；在及时编译器时，如果发现不可能被共享的对象，则可以消除这些对象的锁操作，多数是因为程序员编码不规范引起；

### 4.10 线程基本方法

线程相关的基本方法有wait、notify、notifyAll、sleep、join、yield等；

![image-20210408222442465](images/image-20210408222442465.png)

##### 4.10.1 线程等待(wait)

调用该方法的线程进入WAITING状态，只有等待另外的线程的通知或被中断才会返回，需要注意的是调用wait()方法后，会释放对象的锁；因此，wait方法一般用在同步方法或同步代码块中；

##### 4.10.2 线程睡眠(sleep)

sleep导致当前线程休眠，与wait方法不同的是sleep不会释放当前占有的锁，sleep(long)会导致线程进入TIMED-WAITING状态，而wait()方法会导致当前线程进入WAITING状态；

##### 4.10.3 线程让步(yield)

yield会使当前线程让出CPU执行时间片，与其他线程一起重新竞争CPU时间片；一般情况下，优先级高的线程有更大的可能性成功竞争得到CPU时间片，但这又不是绝对的，有的操作系统对线程优先级并不敏感；

##### 4.10.4 线程中断(interrupt)

中断一个线程，其本意是给这个线程一个通知信号，会影响这个线程内部的一个中断标识位；这个线程本身并不会因此而改变状态(入阻塞，终止等)；

![image-20210408223835419](images/image-20210408223835419.png)![image-20210408223849307](images/image-20210408223849307.png)

##### 4.10.5 Join等待其他线程终止

join()方法，等待其他线程终止，在当前线程中调用一个线程的join()方法，则当前线程转为阻塞状态，直到另一个线程结束，当前线程再由阻塞状态变为就绪状态，等待CPU的宠幸；

##### 4.10.6 为什么要用join()方法？

![image-20210408224240857](images/image-20210408224240857.png)

##### 4.10.7 线程唤醒(notify)

![image-20210408224343287](images/image-20210408224343287.png)

##### 4.10.8 其他方法

![image-20210408224404301](images/image-20210408224404301.png)![image-20210408224421684](images/image-20210408224421684.png)

### 4.11 线程上下文切换

巧妙地利用了时间片轮转的方式，CPU给么个任务都服务一定的时间，然后把当前任务的状态保存下来，在加载下一任务的状态后，继续服务下一任务，任务的状态保存及再加载，这段过程就叫做上下文切换；时间片轮转的方式使多个任务在同一颗CPU上执行变成了可能；

![image-20210409092124416](images/image-20210409092124416.png)

#### 4.11.1 进程

(有时候也称做任务)是指一个程序运行的实例；在Linux系统中，线程就是能并行运行并且与它们的父进程(常见它们的进程)共享同一地址空间(一段内存区域)和其他资源的轻量级的进程；

#### 4.11.2 上下文

是指某一时间点CPU寄存器和程序计数器的内容；

#### 4.11.3 寄存器

是CPU内部的数据较少但是速度很快的内存(与之对应的是CPU外部相对较慢的RAM主内存)；寄存器通过对常用值(通常是运算的中间值)的快速访问来提高计算机程序运行的速度；

#### 4.11.4 程序计数器

是一个专用的寄存器，用于表明指令序列中CPU正在执行的位置，存的值为正在执行的指令的位置或者下一个将要执行的指令的位置，具体依赖于特定的系统；

#### 4.11.5 PCB-"切换帧"

上下文切换可以认为是内核(操作系统的核心)在CPU上对于进程(包括线程)进行切换，上下文切换过程中的信息是保存在进程控制块(PCB，process control block)中的；PCB还经常被称为"切换帧"(switchframe)；信息会一直保存到CPU的内存中，知道它们被再次使用；

#### 4.11.6 上下文切换的活动

1. 挂起一个进程，将这个进程在CPU中的状态(上下文)存储于内存中的某处；
2. 在内存中检索下一个进程的上下文并将其在CPU的寄存器中恢复；
3. 跳转到程序计数器所指向的位置(即跳转到进程被中断时的代码行)，以恢复该进程的程序中；

#### 4.11.7 引起线程上下文切换的原因

1. 当前执行任务的时间片用完之后，系统CPU正常调度下一个任务；
2. 当前执行任务碰到IO阻塞，调度器将此任务挂起，继续下一个任务；
3. 多个任务抢占锁资源，当前任务没有抢到锁资源，被调度器挂起，继续下一个任务；
4. 用户代码挂起当前任务，让出CPU时间
5. 硬件中断；

### 4.12 同步锁与死锁

#### 4.12.1 同步锁

当多个线程同时访问同一个数据时，很容易出问题，为了避免这种情况出现，我们要保证线程同步互斥，就是指并发执行的多个线程，在同一时间只允许一个线程访问共享数据；Java中可以使用synchronized关键字来取得一个对象的同步锁；

#### 4.12.2 死锁

何为死锁，就是多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放；

### 4.13 线程池原理

线程池做的工作主要是控制运行的线程的数量，处理过程中将任务放入队列，然后在线程创建后启动这些任务，如果线程数量超过了最大数量，超出数量的线程排队等候，等其他线程执行完毕，再从队列中取出任务来执行；它的主要特点是：线程复用，控制最大并发数；管理线程；

#### 4.13.1 线程复用

每一个Thread的类都有一个start方法；当调用start启动线程时Java虚拟机会调用该类的run方法；那么该类的run()方法中就是调用了Runnable对象的run()方法；我们可以继承重写Thread类，在其start方法中添加不断循环调用传递过来的Runnable对象；这就是线程池的实现原理；循环方法中不断获取Runnable是用Queue实现的，在获取下一个Runnable之前可以是阻塞的；

#### 4.13.2 线程池的组成

一般的线程池主要分为以下4个组成部分：

1. 线程池管理器：用于创建并管理线程池；
2. 工作线程：线程池中的线程；
3. 任务接口：每个任务必须实现的接口，用于工作线程调度其运行；
4. 任务队列：用于存放待处理的任务，提供一种缓冲机制；

Java中的线程池是通过Executor框架实现的，该框架中用到了Executor、Executors、ExecutorService、ThreadPoolExecutor、Callable和Future、FutureTask这几个类；

![image-20210409110744562](images/image-20210409110744562.png)![image-20210409110829033](images/image-20210409110829033.png)

#### 4.13.3 拒绝策略

![image-20210409111042374](images/image-20210409111042374.png)

#### 4.13.4 Java线程池工作过程

![image-20210409140437020](images/image-20210409140437020.png)![image-20210409140748979](images/image-20210409140748979.png)

### 4.14 JAVA阻塞队列原理

阻塞队列，关键字是阻塞，先理解阻塞的含义，在阻塞队列中，线程阻塞有这样的两种情况；

![image-20210409141154784](images/image-20210409141154784.png)

#### 4.14.1 阻塞队列的主要方法

![image-20210409142058599](images/image-20210409142058599.png)

**插入操作：**

 ![image-20210412093502531](images/image-20210412093502531.png)![image-20210412093550985](images/image-20210412093550985.png)

**获取数据操作：**

![image-20210412093748109](images/image-20210412093748109.png)

#### 4.14.2 Java中的阻塞队列

![image-20210412093828655](images/image-20210412093828655.png)![image-20210412093907996](images/image-20210412093907996.png)

#### 4.14.3 ArrayBlockingQueue(公平、非公平)

用数组实现的有界阻塞队列；此队列按照先进先出(FIFO)的原则对元素进行排序；默认情况下不保证访问者公平的访问队列，默认情况下不保证访问者公平的访问队列，所谓公平访问队列是指阻塞的所有生产者线程或消费者线程，当队列可用时，可以按照阻塞的先后顺序访问队列，即先阻塞的生产线程，可以先往队列里插入元素，先阻塞的消费者线程，可以先从队列里获取元素；通常情况下为了保证公平性会降低吞吐量；我们可以使用以下代码创建一个公平的阻塞队列：

ArrayBlockingQueue fiarQueue = new ArrayBlockingQueue(100, true)；

#### 4.14.4 LinkedBlockingQueue(两个独立锁提高并发)

基于链表的阻塞队列，用ArrayListBlockingQueue类似，此队列按照先进先出(FIFO)的原则对元素进行排序；而LinkedBlockingQueue之所以能够高效的处理并发数据，因为其对生产者端和消费者端分别采用了独立的锁来控制数据同步，这也意味着在高并发的情况下生产者和消费者可以并发地操作队列中的数据，以此来提高整个队列的并发性能；

LinkedBlockingQueue会默认一个类似无限大小的容量(Integer.MAX_VALUE)；

#### 4.14.5 PriorityBlockingQueue(compareTo排序实现优先)

是一个支持优先级的无界队列；默认情况下元素采取自然顺序升序排列，可以自定义实现ConpareTo()方法为指定元素进行排序规则，或者初始化PriorityBlockingQueue时，指定构造参数Comparator来对元素进行排序；需要注意的是不能保证同优先级元素的顺序；

#### 4.14.6 DelayQueue(缓存失败、定时任务)

是一个支持延时获取元素的无界阻塞队列；队列使用PriorityQueue来实现；队列中的元素必须实现Delayed接口，在创建元素时可以指定多久能从队列中获取当前元素；只有在延迟期满时才能从队列中提取元素；我们可以将DelayQueue运用在一下应用场景：

1. 缓存系统的设计：可以用DelayQueue保存缓存元素的有效期，使用一个线程循环查询DelayQueue，一旦能从DelyaQueue中获取元素时，表示缓存有效期到了；
2. 定时任务调度：使用DelayQueue保存当前将会执行的任务和执行时间，一旦从DelayQueue中获取到任务就开始执行，从比如TimerQueue就是使用DelayQueue实现的；

#### 4.14.7 SynchronousQueue(不存储数据、可用于传递数据)

是一个不存储元素的阻塞队列；每一个put操作必须等待一个take操作，否则不能继续添加元素；SynchronousQueue可以看成一个传球手，负责把生产者线程处理的数据直接传递给消费者线程，队列本身并不存储任何元素，非常适合传递性场景，比如在一个线程中使用的数据，传递给另一个线程使用，SynchronousQueue的吞吐量高于LinkedBlockingQueue和ArrayListBlockingQueue；

#### 4.14.8 LinkedTransferQueue

是一个由链表结构组成的无界阻塞TranserQueue队列；相对于其他阻塞队列，LinkedTransferQueue对了tryTransfer和transfer方法；

1. transfer方法L如果当前有消费者正在等待接受元素(消费者使用take()方法或带时间限制的poll()方法时)，transfer方法可以把生产者传入的元素立刻transfer(传输)给消费者；如果没有消费者在等待接受元素，transfer方法会将元素存放在队列的tail节点，并等到该元素被消费者消费了才返回；
2. tryTransfer方法；则是用来试探下生产者传入的元素是否能直接传递给消费者；如果没有消费者等待接受元素，则返回false；和transfer方法的区别是tryTransfer方法无论消费者是否接收，方法立即返回；而transfer方法是必须等到消费者消费了才返回；

对于带有时间限制的tryTransfer(E e，long timeout， TimeUnit unit)方法，则是试图把生产者传入的元素直接传给消费者，但是如果没有消费者消费改元素则等待指定的时间再返回，如果超时还没消费元素，则返回false，如果在超时时间内消费了元素，则返回true；

#### 4.14.9 LinkedBlockingDeque

![image-20210412104553446](images/image-20210412104553446.png)

### 4.15 CyclicBarrier、CountDownLatch、Semaphore的用法

#### 4.15.1 CountDownLatch(线程计数器)

![image-20210412110731592](images/image-20210412110731592.png)

#### 4.15.2 CyclicBarrier(回环栅栏-等待至barrier状态再全部同时执行)

![image-20210412110927591](images/image-20210412110927591.png)![image-20210412111013970](images/image-20210412111013970.png)

#### 4.15.3 Semaphore(信号量-控制同时访问的线程个数)

![image-20210412111114370](images/image-20210412111114370.png)![image-20210412111142342](images/image-20210412111142342.png)![image-20210412111203894](images/image-20210412111203894.png)![image-20210412111226476](images/image-20210412111226476.png)

### 4.16 volatile关键字的作用(变量可见性、禁止重排序)

![image-20210412112336330](images/image-20210412112336330.png)![image-20210412112402036](images/image-20210412112402036.png)![image-20210412112422225](images/image-20210412112422225.png)

### 4.17 如何在两个线程之间共享数据

Java里面进行多线程通信的主要方式就是共享内存的方式，共享内存主要的关注点有两个：可见性和有序原子性；Java内存模型(JMM)解决了可见性和有序性的问题，而锁解决了原子性的问题，理想情况下我们希望做到"同步"和"互斥"；有一下常规实现方法：

**将数据抽象成一个类，并将数据的操作作为这个类的方法：**

1. 将数据抽象成一个类，并将对这个数据的操作作为这个类的方法，这么设计可以和容易做到同步，只要在方法是哪个加"synchronized"；

![image-20210412164443267](images/image-20210412164443267.png)![image-20210412164431060](images/image-20210412164431060.png)

**Runnable对象作为一个类的内部类**

1. 将Runnable对象作为一个类的内部类，共享数据作为这个类的成员变量，每个线程对共享数据的操作也封装在外部类，以便实现对数据的各个操作的同步和互斥，作为内部类的各个Runnable对象调用外部类的这些方法；

![image-20210412164502591](images/image-20210412164502591.png)![image-20210412164512172](images/image-20210412164512172.png)

### 4.18 ThreadLocal作用(线程本地存储)

ThreadLocal，很多地方叫做线程本地变量，也有些地方叫做线程本地存储，ThreadLocal的作用是提供线程内的局部变量，这种变量在线程的生命周期内起作用，减少同一个线程内多个函数或者组件之间一些公共变量的传递的复杂度；

<img src="images/image-20210412165055656.png" alt="image-20210412165055656" style="zoom:80%;" />![image-20210412165150684](images/image-20210412165150684.png)![image-20210412165218611](images/image-20210412165218611.png)

### 4.19 synchronized和ReentrantLock的区别

#### 4.19.1 两者的共同点

1. 都是用来协调多线程对共享对象、变量的方位；
2. 都是可重入锁，同一线程可以多次获得同一个锁；
3. 都保证了可见性和互斥性；

#### 4.19.2 两者的不同点

![image-20210412170145767](images/image-20210412170145767.png)

### 4.20 ConcurrentHashMap并发

#### 4.20.1 减小锁粒度

减小锁粒度是指缩小锁定对象的范围，从而减少锁冲突的可能性，从而提高系统的并发能力；减少锁粒度是一种削弱线程锁竞争的有效手段，这种技术典型的应用是ConcurrentHashMap(高性能的HashMap)类的实现；对于HashMap而言，最重要的两个方法时get与set方法，如果我们对整个HashMap加锁，可以得到的线程安全的对象，但是加锁粒度太大；Segment的大小也被称为ConcurrentHashMap的并发度；

#### 4.20.2 ConcurrentHashMap分段锁

ConcurrentHashMap，它内部细分了若干个小的HashMap，称之为段(Segment)；默认情况下一个ConcurrentHashMap被进一步细分为16个段，即就是锁的并发度；

如果需要在ConcurrentHashMap中添加一个新的表项，并不是将整个HashMap加锁，二十首先根据hashcode得到该表项应该存放在那个段中，然后对该段加锁，并完成put操作；在多线程环境中，如果多个线程同时进行put操作，只要被加入的表项不存在同一个段中，则线程间可以做到真正的并发；

**ConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成**

ConcurrentHashMap是有Segment数组结构和HashEntry数组结构组成；Segment是一种可重入锁ReentrantLock，在ConcurrentHashMap里扮演锁的角色，HashEntry则用于存储键值对数据；一个ConcurrentHashMap里包含一个Segment数组，Segment的结构和HashMap类似，是一种数组和链表结构，一个Segment里包含一个HashEntry数组，每个HashEntry是一个链表结构的元素，每个Segment守护一个HashEntry数组里的元素，当对HashEntry数组的数据进行修改时，必须首先获得它对应的Segment锁；

![image-20210412224615097](images/image-20210412224615097.png)

### 4.21 Java中用到的线程调度

#### 4.21.1 抢占式调度

抢占式调度指的是每条线程执行的时间、线程的切换都由系统控制，系统控制指的是在系统某种运行机制下，可能每条线程都分同样的执行时间片，也可能是某些线程执行的时间片较长，甚至某些线程得不到执行的时间片；在这种机制下，一个线程的阻塞不会导致整个进程的阻塞；

#### 4.21.2 协同式调度

协同式调度指某一线程执行完后主动通知系统切换到另一个线程上执行，这种模式就像接力赛一样，一个人跑完自己的路程就把接力棒交接给下一个人，下个人继续往下跑；线程的执行时间由线程本身控制，线程切换可以预知，不存在多线程同步问题，但它有一个致命弱点：如果一个线程编写有问题，运行到一半就一直阻塞，那么可能导致整个系统崩溃；

![image-20210412230010250](images/image-20210412230010250.png)

#### 4.21.3 JVM的线程调度实现(抢占式调度)

java使用抢占式调度，Java中线程会按优先级分配CPU时间片运行，且优先级越高越优先执行，但优先级高并不代表能独自占用执行时间片，可能是优先级高得到越多的执行时间片，反之，优先级低的分到的执行时间少但不会分配不到执行时间；

#### 4.21.4 线程让出CPU的情况

1. 当前执行线程主动放弃CPU，JVM暂时放弃CPU操作(基于时间片轮转调度的JVM操作系统不会让线程永久放弃CPU，或者说放弃本次时间片的执行权)，例如调用yield()方法；
2. 当前运行线程因为某些原因进入阻塞状态，例如阻塞在I/O上；
3. 当前运行线程结束，即运行完run()方法里面的任务；

### 4.22 进程调度算法

#### 4.22.1 优先调度算法

1. 先来先服务调度算法(FCFS)

   当在作业调度中采用该算法时，每次调度都是从后备作业队伍中选择一个或多个最先进入该队列的作业，将它们调入内存，为它们分配资源、创建进程，然后放入就绪队列；在进程调度中采用FCFS算法时，则每次调度是从就绪队列中选择一个最先进入该队列的进程，为之分配处理机，使之投入运行；该进程一直运行到完成或发生某事件而阻塞后才放弃处理机，特点是：算法比较简单，可以实现基本上的公平；

2. 短作业(进程)优先调度算法

   短作业优先(SJF)的调度算法时从后备队列中选择一个或若干个估计运行时间最短的作业，将它们调入内存运行；而短进程优先调度算法则是从就绪队列中选出一个估计运行时间最短的进程，将处理机分配给它，使它立即执行并一直执行到完成，或发生某事件而被阻塞放弃处理时机再重新调度；该算法未照顾紧迫型作业；

#### 4.22.2 高优先权优先调度算法

![image-20210414113025884](images/image-20210414113025884.png)![image-20210414113040362](images/image-20210414113040362.png)![image-20210414113109445](images/image-20210414113109445.png)

#### 4.22.3 基于时间片的轮转调度算法

1. 时间片轮转法

   ![image-20210414113228599](images/image-20210414113228599.png)

2. 多级反馈队列调度算法

   ![image-20210414113302455](images/image-20210414113302455.png)

### 4.23 什么是CAS(比较并交换-乐观锁机制-锁自旋)

#### 4.23.1 概念及特性

CAS(Compare And Swap)比较并交换，CAS算法的过程式这样：它包含3个参数CAS(V,E,N)；V表示要更新的变量(内存值)，E表示预期值(旧的)，N表示新值，当且仅当V值等于E值时，才会将V的值设为N，如果V值和E值不同，则说明已经有其他线程做了更新，则当前线程什么都不做；最后，CAS返回当前V的真实值；

CAS操作是抱着乐观的态度进行的(乐观锁)，它总是认为自己可以成功完成操作；当多个线程同时使用CAS操作一个变量时，只有一个会胜出，其余均会失败；失败的线程不会被挂起，仅是被告知失败，并且允许再次尝试，当然也允许失败线程放弃操作；基于这样的原理，CAS操作即使没有锁，也可以发现其他线程对当前线程的干扰，并进行恰当的处理；

#### 4.23.2 原子包Jjava.util.concurrent.atomic(锁自旋)

![image-20210414141649547](images/image-20210414141649547.png)![image-20210414141704331](images/image-20210414141704331.png)![image-20210414141730041](images/image-20210414141730041.png)

#### 4.23.2 ABA问题

![image-20210414142022897](images/image-20210414142022897.png)

### 4.24 什么事AQS(抽象的队列同步器)

AbstractQueuedSynchronizer类入其名，抽象的队列式的同步器，AQS定义了一套多线程访问共享资源的同步器框架，许多同步类实现都依赖于它，如常用的ReentrantLock、Semaphore、CountDownLatch；

![image-20210414142914736](images/image-20210414142914736.png)![image-20210414142938564](images/image-20210414142938564.png)![image-20210414143005146](images/image-20210414143005146.png)![image-20210414143031687](images/image-20210414143031687.png)

## 4.JAVA基础

### 4.1 JAVA异常分类及处理

#### 5.1.1 概念

![image-20210414151043887](images/image-20210414151043887.png)

#### 5.1.2 异常分类

Throwable是Java语言中所有错误或异常的超类；下一层分为Error和Exception；

##### Error

Error类是指java运行时系统的内部错误和资源耗尽错误；应用程序不会抛出该类对象；如果出现了这样的错误，除了告知用户，剩下的就是尽力使程序安全的终止；

##### Exception(RuntimeException、CheckedException)

Exception又有两个分支，一个是运行时异常RuntimeException，一个是CheckedException；

- RuntimeException，如：NullPointException、ClassCastException；一个检查异常CheckedException，如I/0错误导致的IOException、SQLException；RuntimeException是那些可能在Java虚拟机正常运行期间抛出的异常的超类；如果出现RuntimeException，那么一定是程序员的错误；
- 检查异常CheckedException，一般是外部错误，这种异常都发生在编译阶段，Java编译器会强制程序去捕获此类异常，即会出现要求你把这段可能出现异常的程序进行trh catch，该类异常一般包括几个方面；
  1. 试图在文件尾部读取数据；
  2. 试图打开一个错误格式的URL；
  3. 试图根据给定的字符串查找class对象，而这个字符串表示的类并不存在；

#### 5.1.3 异常的处理方式

![image-20210414153501152](images/image-20210414153501152.png)

#### 5.1.4 Throw和throws的区别

![image-20210414155158036](images/image-20210414155158036.png)![image-20210414155238174](images/image-20210414155238174.png)

### 4.2 JAVA反射

#### 4.2.1 动态语言

![image-20210414213520973](images/image-20210414213520973.png)

#### 4.2.2 反射机制概念(运行状态)

![image-20210414213623578](images/image-20210414213623578.png)

在Java中的反射机制是指在运行状态中，对于任意一个类都能够知道这个类所有的属性和方法；并且对于任意一个对象，都能够调用它的任意一个方法；这种动态获取信息以及动态调用对象方法的功能称为Java语言的反射机制；

#### 4.2.3 反射的应用场合

##### 编译时类型和运行时类型

![image-20210414214042333](images/image-20210414214042333.png)

##### 编译时类型无法获取具体方法

程序在运行时还可能接收到外部传入的对象，该对象的编译时类型为Object，但是程序有时需要调用该对象的运行时类型的方法；为了解决这些问题，程序需要在运行时发现对象和类的真实信息；然而，如果编译时根本无法预知该对象和类属于那些类，程序只能依靠运行时信息来发现该对象和类的真是信息，此时就必须使用到反射了；

#### 4.2.4 Java反射API

![image-20210414214907031](images/image-20210414214907031.png)

#### 4.2.5 反射使用步骤(获取Class对象、调用对象方法)

1. 获取想要操作的类的Class对象，他是反射的核心，通过Class对象我们可以任意调用类的方法；
2. 调用Class类中的方法，即就是反射的使用阶段；
3. 使用反射API来操作这些信息；

#### 4.2.6 获取Class对象的3种方法

![image-20210414215252877](images/image-20210414215252877.png)![image-20210414215537857](images/image-20210414215537857.png)

#### 4.2.7 创建对象的两种方法

![image-20210414220054909](images/image-20210414220054909.png)![image-20210414220108751](images/image-20210414220108751.png)

### 4.3 JAVA注解

#### 4.3.1 概念

Annotation(注解)是Java提供的一种对元程序中元素关联信息和元数据(metadata)的途径和方法；Annotation是一个接口，程序可以通过反射来获取指定程序中元素的Annotation对象，然后通过过该Annotation对象来获取注解中的元数据信息；

#### 4.3.2 4种标准元注解

元注解的作用是负责注释其他注释，Java5.0定义了4个标准的meta-annotation类型，它们被用来给其他annotation类型作说明；

1. @Target修饰的对象范围

   ![image-20210414224031978](images/image-20210414224031978.png)

2. @Retention定义被保留的时间长短

   ![image-20210414224137872](images/image-20210414224137872.png)

3. @Documented描述-javadoc

   ![image-20210414224203095](images/image-20210414224203095.png)

4. @Inherited阐述了某个被标注的类

   ![image-20210414224248781](images/image-20210414224248781.png)

![image-20210414224401192](images/image-20210414224401192.png)





#### 4.3.3 注解处理器

![image-20210414224722219](images/image-20210414224722219.png)![image-20210414224917157](images/image-20210414224917157.png)![image-20210414224932979](images/image-20210414224932979.png)![image-20210414224950251](images/image-20210414224950251.png)

### 4.4 JAVA内部类

#### 4.4.1 静态内部类

![image-20210415090900553](images/image-20210415090900553.png)

#### 4.4.2 成员内部类

![image-20210415091124149](images/image-20210415091124149.png)

#### 4.4.3 局部内部类(定义在方法中的类)

![image-20210415091209565](images/image-20210415091209565.png)

#### 4.4.4 匿名内部类(要继承一个父类或者实现一个接口、直接使用new来生成一个对象的引用)

![image-20210415091544128](images/image-20210415091544128.png)![image-20210415091647801](images/image-20210415091647801.png)

### 4.5 JAVA泛型

泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测非法的类型；泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数；比如我们要写一个排序方法，能够对整型数组、字符串数组甚至其他任何类型的数字进行排序，我们就可以使用Java泛型；

#### 4.5.1 泛型方法(<E>)

![image-20210415092639090](images/image-20210415092639090.png)

#### 4.5.2 泛型类<T>

![image-20210415092747168](images/image-20210415092747168.png)

#### 4.5.3 类型通配符？

![image-20210415092824783](images/image-20210415092824783.png)

#### 4.5.4 类型擦除

![image-20210415092913784](images/image-20210415092913784.png)

### 4.6 JAVA序列化

1. 保持(持久化)对象及其状态到内存或者磁盘

   ![image-20210415093417172](images/image-20210415093417172.png)

2. 序列化对象以字节数组保持-静态成员不保存

   ![image-20210415093511154](images/image-20210415093511154.png)

3. 序列化用于远程对象传输

   ![image-20210415093547213](images/image-20210415093547213.png)

4. Serializable实现序列化

   ![image-20210415093614435](images/image-20210415093614435.png)

5. ObjectOutputStream和ObjectInputStream对对象进行序列化及反序列化

   ![image-20210415093632137](images/image-20210415093632137.png)

6. writeObject和readObject自定义序列化策略

   ![image-20210415093645832](images/image-20210415093645832.png)

7. 序列化ID

   ![image-20210415093707859](images/image-20210415093707859.png)

8. 序列化并不保存静态变量

9. 序列化子父类说明

   ![image-20210415093734417](images/image-20210415093734417.png)

10. Transient关键字阻止该变量被序列化到文件中

    ![image-20210415093752718](images/image-20210415093752718.png)

### 4.7 JAVA复制

将一个对象的引用复制给另外一个对象，一共有三种方式；第一种方式是直接赋值，第二种方式使浅拷贝，第三种是深拷贝；所以大家知道了，这三种概念实际上都是为了拷贝对象；

#### 4.7.1 直接赋值复制

![image-20210415101631726](images/image-20210415101631726.png)

#### 4.7.2 浅复制(复制引用但不复制引用的对象)

![image-20210415101710685](images/image-20210415101710685.png)

#### 4.7.3 深复制(复制对象和其应用对象)

![image-20210415101844735](images/image-20210415101844735.png)![image-20210415101859318](images/image-20210415101859318.png)

#### 4.7.4 序列化(深clone-中实现)

在java语言里深复制一个对象，常常可以先使对象实现Serializable接口，然后把对象(实际上只是对象的一个拷贝)写到一个流里，再从流里读出来，便可以重建对象；

## 5.Spring原理

### 5.1 Spring特点

#### 5.1.1 轻量级

#### 5.1.2 控制反转

#### 5.1.3 面向切面

#### 5.1.4 容器

#### 5.1.5 框架集合

![image-20210415102844442](images/image-20210415102844442.png)

### 5.2 Spring核心组件

![image-20210415103945971](images/image-20210415103945971.png)

### 5.3 Spring常用模块

![image-20210415104347753](images/image-20210415104347753.png)

### 5.4 Spring主要包

![image-20210415104501915](images/image-20210415104501915.png)![image-20210415104536087](images/image-20210415104536087.png)

### 5.5 Spring常用注解

bean注入与装配的方式有很多种，可以通过xml、get、set方式，构造函数或者注解等；简单易用的方式就是使用Spring的注解了，Spring提供了大量的注解方式；

![image-20210415104808056](images/image-20210415104808056.png)

### 5.6 Spring第三方结合

![image-20210415104857305](images/image-20210415104857305.png)

### 5.7 Spring IOC原理

#### 5.7.1 概念

Spring通过一个配置文件描述Bean及Bean之间的依赖关系，利用Java语言的反射功能实例化Bean并建立Bean之间的依赖关系；Spring的IOC容器在完成这些底层工作的基础上，还提供了Bean实例缓存、生命周期管理、Bean实例代理、事件发布、资源装载等高级服务；

#### 5.7.2 Spring容器高层视图

![image-20210415111546293](images/image-20210415111546293.png)

#### 5.7.3 IOC容器实现

- BeanFactory-框架基础设施

  ![image-20210415111813705](images/image-20210415111813705.png)![image-20210415111824671](images/image-20210415111824671.png)![image-20210415112303946](images/image-20210415112303946.png)![image-20210415112338251](images/image-20210415112338251.png)![image-20210415112418956](images/image-20210415112418956.png)

- ApplicationContext面向开发应用

  ![image-20210415112553112](images/image-20210415112553112.png)

  ![image-20210415112539667](images/image-20210415112539667.png)![image-20210415112654493](images/image-20210415112654493.png)

- WebApplication体系架构

  ![image-20210415112805856](images/image-20210415112805856.png)

#### 5.7.4 Spring Bean作用域

Spring3中为Bean定义了5种作用域，分别为singleton(单例)、prototype(原型)、request、session和golbal session，5种作用域说明如下：

1. singleton：单例模式(多线程下不安全)

   ![image-20210415213334557](images/image-20210415213334557.png)

2. prototype：原型模式每次使用时创建

   ![image-20210415213400555](images/image-20210415213400555.png)

3. Request：一次request一个实例

   ![image-20210415213434671](images/image-20210415213434671.png)

4. session

   ![image-20210415213506018](images/image-20210415213506018.png)

5. global Session

   ![image-20210415213520751](images/image-20210415213520751.png)

#### 5.7.5 Spring Bean生命周期

1. 实例化：实例化一个Bean，也就是我们常说的new；

2. IOC依赖注入：按照Spring上下文对实例化的Bean进行配置，也就是IOC注入；

3. setBeanName实现：如果这个Bean已经实现了BeanNameAware接口，会调用它实现的setBeanName(String)方法，此处传递的就是Spring配置文件中Bean的id值；

4. BeanFactoryAware实现：如果这个Bean已经实现了BeanFactoryAware接口，会调用它实现的setBeanFactory，setBeanFactory(BeanFactory)传递的是Spring工厂自身(可以用这个方式来获取其他Bean，只需在Spring配置文件中配置一个普通的Bean就可以)；

5. ApplicationContextAware实现：如果这个Bean已经实现了ApplicationContextAware接口，会调用setApplicationContextAware(ApplicationContext)方法，传入Spring上下文(同样这个方式也可以实现步骤4的内容，但比4更好，因为ApplicationContext是BeanFactory的子接口，有更多的实现方法)；

6. postProcessBeforeInitialization接口实现-初始化预处理

   ![image-20210415214654039](images/image-20210415214654039.png)

7. init-method

   ![image-20210415214710192](images/image-20210415214710192.png)

8. postProcessAfterInitialization

   ![image-20210415214733691](images/image-20210415214733691.png)

9. Destory过期自动清理阶段

   ![image-20210415214748407](images/image-20210415214748407.png)

10. destory-method自配置清理

    ![image-20210415214801333](images/image-20210415214801333.png)![image-20210415214820664](images/image-20210415214820664.png)

![image-20210415214843144](images/image-20210415214843144.png)

#### 5.7.6 Spring依赖注入四种方式

1. 构造器注入

   ![image-20210416090614069](images/image-20210416090614069.png)

2. setter方法注入

   ![image-20210416090626382](images/image-20210416090626382.png)

3. 静态工厂注入

   ![image-20210416090648976](images/image-20210416090648976.png)

4. 实例工厂

   ![image-20210416090727024](images/image-20210416090727024.png)![image-20210416090751011](images/image-20210416090751011.png)

#### 5.7.7 5种不同方式的自动装配

![image-20210416091027923](images/image-20210416091027923.png)

### 5.8 Spring AOP原理

#### 5.8.1 概念

"横切"的技术，剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，并将其命名为"Aspect"，即切面；所谓"切面"，简单说就是那些与业务无关，却为业务模块所共用调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块之间的耦合度，并有利于未来的可操作性和可维护性；

使用"横切"技术，AOP把软件系统分为两个部分：核心关注点和横切关注点；业务处理的主要流程是核心关注点，与之关系不大的部分时横切关注点；横切关注点的一个特点是，它们经常发生在核心关注点的多出，而各处基本相似，比如权限认证、日志、事务；AOP的作用在于分离系统中的各种关注点，间核心关注点和横切关注点分离开来；

![image-20210416101723692](images/image-20210416101723692.png)

#### 5.8.2 AOP核心概念

![image-20210416101832567](images/image-20210416101832567.png)![image-20210416102207366](images/image-20210416102207366.png)

![image-20210416102236882](images/image-20210416102236882.png)

#### 5.8.3 AOP两种代理方式

Spring提供了两种方式来生成代理对象：JDKProxy和Cglib；具体使用那种方式生成由AopProxyFactory根据AdvisedSupport对象的配置来决定；默认的策略是如果目标类是接口，则使用JDK动态代理技术，否则使用Cglib来生成代理；

1. JDK动态接口代理

   JDK动态代理主要涉及到java.lang.reflect包中的两个类：Proxy和InvocationHandler；InvocationHandler是一个接口，通过实现该接口定义横切逻辑，并通过反射机制调用目标类的代码，动态将横切逻辑和业务逻辑编制在一起；Proxy利用InvocationHandler动态创建一个符合某一接口的实例，生成目标类的代理对象；

2. CGLib动态代理

   CGLib全称为Code Generation Library，是一个强大的高性能、高质量的代码生成类库，可以在运行期扩展Java类与实现Java接口，CGLib封装了asm，可以再运行期动态生成新的class；和JDK动态代理相比较：JDK创建代理有一个限制，就是只能为接口创建代理实例，而对于没有通过接口定义业务方法的类，则可以通过CGLib创建动态代理；

#### 5.8.4 实现原理

![image-20210416105729961](images/image-20210416105729961.png)![image-20210416105748393](images/image-20210416105748393.png)

### 5.9 Spring MVC原理

#### 5.9.1 MVC流程

Spring的模型-试图-控制区(MVC)框架是围绕一个DispatcherServlet来设计的，这个Servlet会把请求分发给各个处理器，并支持可配置的处理器映射、视图渲染、本地化、时区与主题渲染等，甚至还能支持文件上传；

![image-20210416112020326](images/image-20210416112020326.png)![image-20210416112101031](images/image-20210416112101031.png)

#### 5.9.2 MVC常用注解

![image-20210416112136913](images/image-20210416112136913.png)

### 5.10 Spring Boot原理

![image-20210416143511230](images/image-20210416143511230.png)

1. 创建独立的Spring应用程序
2. 嵌入的Tomcat，无需部署WAR文件
3. 简化maven配置
4. 自动配置Spring
5. 提供生产就绪型功能，如指标、健康检查和外部配置
6. 绝对咩有代码生成和对XML没有要求配置

### 5.11 JPA原理

#### 5.11.1 事务

事务是计算机应用中不可或缺的组件模型，它保证了用户操作的原子性(Atomicity)、一致性(Consistency)、隔离性(Isolation)和持久性(Durability)；

#### 5.11.2 本地事务

紧密依赖于底层资源管理器(例如数据库连接)，事务处理局限在当前事务资源内；此种事务处理方式不存在对应用服务器的依赖，因而部署灵活却无法支持多数据源的分布式事物；在数据库连接中使用本地事务示例如下：

![image-20210416144444547](images/image-20210416144444547.png)![image-20210416144455787](images/image-20210416144455787.png)

#### 5.11.3 分布式事务

Java事务编程接口(JTA：Java Transaction API)和Java事务服务(JTS：Java Transaction Service)为J2EE平台提供了分布式事务服务；分布式事务(Distrubuted Transaction)包括事务管理器(Transaction Manager)和一个或多个支持XA协议的资源管理器(Resource Manager)；我们可以将资源管理器看做任意类型的持久化数据存储；事务管理器承担着所有事务参与单元的协调与控制；

![image-20210416154341350](images/image-20210416154341350.png)![image-20210416154351128](images/image-20210416154351128.png)

#### 5.11.4 两阶段提交

两阶段提交主要保证了分布式事务的原子性：即所有结点要么全部做要么全不做，所谓的两阶段是指：第一阶段：准备阶段；第二阶段：提交阶段；

![image-20210416155805229](images/image-20210416155805229.png)

1. 准备阶段

   事务协调者(事务管理器)给每个参与者(资源管理器)发送Prepare消息，每个参与者要么直接返回失败(如权限验证失败)，要么在本地执行事务，写本地的redo和undo日志，但不提交，到达一种"万事俱备，只欠东风"的状态；

2. 提交阶段

   如果协调者收到了参与者的失败消息或者超时，直接给每个参与者发送回滚(Rollback)消息；否则，发送提交(Commit)消息；参与者根据协调者的指令执行提交或者回滚操作，释放所有事务处理过程中使用的锁资源(注意：必须在最后阶段释放锁资源)；

将提交分成两阶段进行的目的很明确，就是尽可能晚地提交事务，让事务在提交前尽可能地完成所有能完成的工作；

### 5.12 Mybatis缓存

Mybatis中有一级缓存和二级缓存，默认情况下一级缓存是开启的，而且是不能关闭的；一级缓存是指SqlSession级别的缓存，当有同一个SqlSession中进行相同的SQL语句查询时，第二次以后的查询不会从数据库查询，而是直接从缓存中获取，一级缓存最多缓存1024条SQL；二级缓存是指可以跨SqlSession的缓存；是mapper级别的缓存，对于mapper级别的缓存不同的sqlsession是可以共享的；

![image-20210418092743663](images/image-20210418092743663.png)

#### 5.12.1 Mybatis的一级缓存原理(sqlsession级别)

![image-20210418092907108](images/image-20210418092907108.png)

#### 5.12.2 二级缓存原理(mapper级别)

![image-20210418093006977](images/image-20210418093006977.png)![image-20210418093048817](images/image-20210418093048817.png)

### 5.13 Tomcat架构

![image-20210418093139234](images/image-20210418093139234.png)

## 6.微服务

### 6.1 服务注册发现

服务注册就是维护一个登记簿，它管理系统内所有的服务地址；当新的服务启动后，它会向登记薄交代自己的地址信息；服务的依赖方直接向登记薄要Service Provider地址就行了；当下用于服务注册的工具非常多Zookeeper、Consul、Etcd，还有Netflix家的eureka等；服务注册有两种形式：客户端注册和第三方注册；

#### 6.1.1 客服端注册(zookeeper)

![image-20210418094123371](images/image-20210418094123371.png)

#### 6.1.2 第三方注册(独立的服务Registrar)

![image-20210418094333200](images/image-20210418094333200.png)![image-20210418094345848](images/image-20210418094345848.png)

#### 6.1.3 客服端发现

![image-20210418094559194](images/image-20210418094559194.png)

#### 6.1.4 服务端发现

![image-20210418094651432](images/image-20210418094651432.png)

#### 6.1.5 Consul

#### 6.1.6 Eureka

#### 6.1.7 SmartStack

#### 6.1.8 Etcd

### 6.2 API网关

API Gateway是一个服务器，也可以说是进入系统的唯一节点；这跟面向对象设计模型中的Facade模式很像；API Gateway封装内部系统的架构，并且提供API给各个客户端；它还可能有其他功能，如授权；监控、负载均衡、缓存、请求分片和管理、静态相应处理等；下图展示了一个适应当前架构的API Gateway；

![image-20210418095312252](images/image-20210418095312252.png)

#### 6.2.1 请求转发

服务转发主要是对客服端的请求安装微服务的负载转发到不同的服务上；

#### 6.2.2 相应合并

把业务上需要调用多个服务接口才能完成的工作合并成一次调用对外统一提供的服务；

#### 6.2.3 协议转换

重点是支持SOAP，JMS，Rest间的转移转换；

#### 6.2.4 数据转换

重点是支持XML和Json之间的报文格式转换能力(可选)；

#### 6.2.5 安全认证

1. 基于Token的客服端访问控制和安全策略；
2. 传输数据和报文加密，到服务端解密，需要在客户端有独立的SDK代理包；
3. 基于Https的传输加密，客户端和服务端数字证书支持；
4. 基于OAuth2.0的服务安全认证(授权码、客户端、密码模式等)；

### 6.3 配置中心

配置中心一般用作系统的参数配置，它需要满足如下几个要求：高效获取、实时感知、分布式访问；

#### 6.3.1 zookeeper配置中心

实现的架构图如下所示，采取数据加载到内存方式解决高效获取的问题，借助zookeeper的节点监听机制来实现实时感知；

![image-20210418101358255](images/image-20210418101358255.png)

#### 6.3.2 配置中心数据分类

![image-20210418101431444](images/image-20210418101431444.png)

### 6.4 事件调度(kafka)

消息服务和事件的统一调度，常用kafka，activemq等；

### 6.5 服务跟踪(starter-sleuth)

![image-20210418102041990](images/image-20210418102041990.png)![image-20210418102058945](images/image-20210418102058945.png)

### 6.6 服务熔断(Hystrix)

在微服务架构总通常会有多个服务层调用，基本服务的故障可能会导致级联故障，进而造成整个系统不可用的情况，这种现象被称为服务雪崩效应；服务雪崩效应是一种因"服务提供者"的不可用导致"服务消费者"的不可用，并将不可用逐渐放大的过程；

熔断器的原理很简单，如同电力过载保护器；它可以实现快速失败，如果它在一段时间内侦测到很多类似的错误，会强迫其以后的多个调用快速失败，不在访问远程服务器，从而防止应用程序不断地尝试执行可能会失败的操作，使得应用程序继续执行而不用等待修正错误，或者浪费CPU时间去等到长时间的超时产生；熔断器也可以使应用程序能够诊断错误是否已经修正，如果已经修正，应用程序会再次尝试调用操作；

![image-20210418102915325](images/image-20210418102915325.png)

#### 6.6.1 Hystrix断路器机制

断路器很好理解，当Hsytrix Command请求后端服务失败数量超过一定比例(默认50%)，断路器会切换到开路状态(Open)，这时所有请求会直接失败而不会发送到后端服务；断路器保持在开路状态一段时间后(默认5秒)，自动切换到半开路状态(HALF-OPEN)；这时会判断下一次请求的返回情况，如果请求成功，断路器切回闭路状态(CLOSED)，否则重新切换到开路状态，Hystrix的断路器就像我们家庭电路中的保险丝，一旦后端服务不可用，断路器会直接切断请求链，避免发送大量无效请求影响系统吞吐量，并且断路器有自我检测并恢复的能力；

### 6.7 API管理

SwaggerAPI管理功能；

## 7.Netty与RPC

### 7.1 Netty原理

Netty是一个高性能、异步事件驱动的NIO框架，基于JAVA NIO提供的API实现；它提供了对TCP、UDP和文件传输的支持，作为一个异步NIO框架，Netty的所有IO操作都是异步非阻塞的，通过Future-Listener机制，用户可以方便的主动获取或者通过通知机制获得IO操作结果；

### 7.2 Netty高性能

#### 7.2.1 多路复用通讯方式

![image-20210418112115078](images/image-20210418112115078.png)![image-20210418112142353](images/image-20210418112142353.png)

Netty的IO线程NioEventLoop由于聚合了多路复用器Selector，可以同时并发处理成百上千个客户端Channel，由于读写操作都是非阻塞的，这就可以充分提升IO线程的运行效率，避免由于频繁IO阻塞导致的线程挂起；

#### 7.2.2 异步通讯NIO

由于Netty采用了异步通信模式，一个IO线程可以并发处理N个客户端连接和读写操作，这从根本上解决了传统同步阻塞IO一连接一线程模型，架构的性能、弹性伸缩能力和可靠性都得到了极大的提升；

#### 7.2.3 零拷贝(DIRECT BUFFERS使用堆外直接内存)

1. Netty的接收和发送ByteBuffer采用DIRECT BUFFERS，使用堆外直接内存进行Socket读写，不需要进行字节缓冲区的二次拷贝；如果使用传统的堆内存(HEAP BUFFERS)进行Socket读写，JVM会将堆内存Buffer拷贝一份到直接内存中，然后才写入Socket；相比于堆外直接内存，消息在发送过程中多了一次缓冲区的内存拷贝；
2. Netty提供了组合Buffer对象，可以聚合多个ByteBuffer对象，用户可以像操作一个Buffer那样方便的对组合Buffer进行操作，避免了传统通过内存拷贝的方式将几个小Buffer合并成一个大的Buffer；
3. Netty的文件传输采用transferT方法，它可以直接将文件缓冲区的数据发送给目标Channel，避免了传统通过循环write方式导致的内存拷贝问题；

#### 7.2.4 内存池(基于内存池的缓冲区重用机制)

随着JVM虚拟机和JIT即时编译技术的发展，对象的分配和回收是个非常轻量级的工作；但是对于缓冲区Buffer，情况却稍有不同，特别是对于堆外直接内存的分配和回收，是一件耗时的操作；为了尽量重用缓冲区，Netty提供了基于内存池的缓冲区重用机制；

7.2.5 高效的Reactor线程模型

7.2.6 无锁设计、线程绑定

#### 7.2.7 高性能的序列化框架

### 7.3 Netty RPC实现

### 7.4 RMI实现方式

### 7.5 Protoclol Buffer

### 7.6 Thrift