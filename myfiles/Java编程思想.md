[TOC]

# 第9章 接口

​	1.接口和内部类为我们提供了一种将接口与实现分离的更加结构化的方法。

## 9.1 抽象类和抽象方法

​	1.可以创建一个没有任何抽象方法的抽象类。

## 9.2 接口

​	1.interface关键字前面添加public关键字（但仅限于该接口在与其同名的文件中被定义）。如果不添加public关键字，则它只具有包访问权限，这样它就只能在同一个包内可用。接口也可以包含域，但是这些域隐式地是static和final的。

## 9.3 完全解耦

## 9.4 Java中的多重继承

​	1.使用接口的核心原因：为了能够向上转型为多个基类型（以及由此而带来的灵活性）。然而，使用接口的第二个原因却是与使用抽象类相同：防止客户端程序员创建该类的对象，并确保这仅仅是建立一个接口。

## 9.5 通过集成来扩展接口

​	1.java接口可以多继承。interface C extends A, B {}是可以的。一个类可以实现多个接口：class D implements A,B,C{}。但是一个类只能继承一个类,不能继承多个类：class B extends A{}。在继承类的同时,也可以实现接口：class E extends D implements A,B,C{}。

### 9.5.1 组合接口时的名字冲突

## 9.6 适配接口

## 9.7 接口中的域

​	1.接口中的任何域默认都是public、static和final的。

### 9.7.1 初始化接口中的域

## 9.8 嵌套接口

## 9.9 接口与工厂

## 9.10 总结

​	1.恰当的原则应该是有限选择类而不是接口，从类开始，如果接口的必需性变得非常明确，那么就进行重构，接口时一种重要的工具，但是它们容易被滥用。

# 第10章 内部类

## 10.1 创建内部类

## 10.2 链接到外部类

## 10.3 使用.this与.new

​	1.在拥有外部类对象之前是不可能创建内部对象的。这是因为内部类对象会暗暗地连接到创建它的外部对象上。

## 10.4 内部类与向上转型

## 10.5 在方法和作用域内的内部类

​	1. 可以在一个方法里面或者任意的作用域内定义内部类，这么做有两个理由：一，如前所示，实现了某类型的接口，于是可以创建并返回对其的引用；二，要解决一个复杂的问题，想创建一个类来辅助你的解决方案，但是又不希望这个类是公共可用的。

## 10.6 匿名内部类

​	1. 匿名内部类与正规的继承相比有些受限，因为匿名内部类既可以扩展类，也可以实现接口，但是不能两者兼备，而且如果是实现接口，也只能实现一个接口。

### 10.6.1 再访工厂方法

​	请记住在第9章最后给出的建议：优先使用类而不是接口。如果你的设计中需要某个接口，你必须了解它。否则，不到迫不得已，不要将其放到你的设计中。

## 10.7 嵌套类

​	如果不需要内部类对象与外围类对象之间有联系，那么可以将内部类声明为static，这通常称为嵌套类，想要理解static应用于内部类时的含义，就必须记住，普通的内部类对象隐式地保存了一个引用，指向创建它的外围类对象，然而，当内部类是static的时，就不是这样了。嵌套类意味着：

- 要创建嵌套类的对象，并不需要其外围类的对象。
- 不能从嵌套类的对象中访问非静态的外围类对象。

### 10.7.1 接口内部的类

​	放到接口中的任何类都自动地是public和static的，因为类是static的，只是将嵌套类置于接口的命名空间内，这并不违反接口的规范。

### 10.7.2 从多层嵌套类中访问外部类的成员

## 10.8 为什么需要内部类

​	一般来说，内部类继承自某个类或者实现某个接口，内部类的代码操作创建它的外部类的对象，所以可以认为内部类提供了某种进入其外部类的窗口。

​	使用内部类最吸引人的原因是：每个内部类都能独立地继承自一个（接口的）实现，所以无论外围类是否已经继承了某个（接口的）实现，对于内部类都没有影响。如果没有内部类提供的、可以继承多个具体的或抽象的类的能力，一些设计问题就很难解决。从这个角度看，内部类使得多重继承的解决方案变得完整。接口解决了部分问题，而内部类有效地实现了“多重继承”。也就是说，内部类允许继承多个非接口类型（类或抽象类）。

​	如果使用内部类，还可以获得其他一些特性：

+ 内部类可以有多个实例，每个实例都有自己的状态信息，并且与其外围类对象的信息相互独立。
+ 在单个外围类中，可以让多个内部类以不同的方式实现同一个接口，或继承同一个类。
+ 创建内部类对象的时刻并不依赖于外围类对象的创建。
+ 内部类并没有令人迷惑的“is-a”关系，它就是一个独立的实体。

### 10.8.1 闭包与回调

​	闭包是一个可调用的对象，它记录了一些信息，这些信息来自于创建它的作用域。

​	回调的价值在于它的灵活性，可以在运行时动态地决定需要调用什么方法。

### 10.8.2 内部类与控制框架

​	应用程序框架就是被设计用以解决某类特定问题的一个类或一组类。

## 10.9 内部类的继承

## 10.10 内部类可以被覆盖吗

## 10.11 局部内部类

​	局部内部类不能有访问说明符，因为它不是外围类的一部分，但是它可以访问当前代码块内的常量，以及此外围类的所有成员。

## 10.12 内部类标识符

​	这些类文件的命名有严格的规格：外围类的名字，加上“$”，再加上内部类的名字。如果内部类时匿名的，编译器会简单地产生一个数字作为其标识符，如果内部类时嵌套在别的内部类之中，只需要直接将它们的名字加在其外围类标识符与美元标识符的后面

## 10.13 总结

# 第11章 持有对象

## 11.1 泛型和类型安全的容器

## 11.2 基本概念

## 11.3 添加一组元素

## 11.4 容器的打印

## 11.5 List

## 11.6 迭代器

### 11.6.1 Listlterator

## 11.7 LinkedList

## 11.8 stack

## 11.9 Set

## 11.10 Map

## 11.11 Queue

### 11.11.1 PriorityQueue(优先级队列)

​	先进先出描述了最典型的队列规则，队列规则是指在给定一组队列中的元素的情况下，确定下一个弹出队列的元素的规则，先进先出声明的是下一个元素应该是等待时间最长的元素。

## 11.12 Collection和Iterator

## 11.13 Foreach与迭代器

### 11.13.1 适配器方法惯用法

## 11.14 小结

# 第12章 通过异常处理错误

​	Java中的异常处理的目的在于通过使用少于目前数量的代码来简化大型、可靠的程序的生成，并且通过这种方式可以使你更加自信：你的应用中没有未处理的错误。

## 12.1 概念

## 12.2 基本异常

​	当异常抛出后，有几件事会随之发生。首先，同Java中其他对象的创建一样，将使用new在堆上创建异常对象，然后，当前的执行路径(它不能继续下去了)被终止，并且从当前环境中弹出对异常对象的引用，此时，异常处理机制接管程序，并开始寻找一个恰当的地方来继续执行程序。这个恰当的地方就是异常处理程序，它的任务是将程序从错误状态中恢复，以使程序能要么换一种方式运行，要么继续运行下去。

​	异常使得我们可以将每件事都当作一个事务来考虑，而异常可以看护着这些事务的底线。"...事务的基本保障是我们所需的在分布式计算红的异常处理。事务是计算机汇总的合同法，如果出了什么问题，我们只需要放弃整个计算。"我们还可以将异常看作是一种内建的恢复(undo)系统，因为我们在程序中可以拥有各种不同的恢复点。如果程序的某部分失败了，异常将“恢复”到程序中某个已知的稳定点上。

​	异常最重要的方面之一就是如果发生问题，它们将不允许程序沿着其正常的路径继续走下去。异常允许我们强制程序停止运行，并告诉我们出现了什么问题，或者(理想状态下)强制程序处理问题，并返回到稳定状态。

### 12.2.1 异常参数

​	能够抛出任何类型的Throwable对象，它是异常类型的根类。通常，对于不同类型的错误，要抛出对应的异常，错误信息可以保存在异常对象内部或者异常类的名称来暗示，上一层环境通过这些信息来决定如何处理异常(通常，异常对象中仅有的信息就是异常类型，除此之外不包含任何有意义的内容。)。

## 12.3 捕获异常

### 12.3.1 try块

### 12.3.2 异常处理程序

## 12.4 创建自定义异常

### 12.4.1 异常与记录日志

## 12.5 异常说明

​	Java鼓励人们把方法可能会抛出的异常告知使用此方法的客户端程序员，这是种优雅的做法，它使得调用者能确切知道写什么样的代码可以捕获所有潜在的异常。

​	代码必须与异常说明保持一致，如果方法里的代码产生了异常却没有进行处理，编译器会发现这个问题并提醒你：要么处理这个异常，要么就在异常说明中表明此方法产生异常，通过这种自顶向下强制执行的异常说明机制，Java在编译时就可以保证一定水平的异常正确性。

## 12.6 捕获所有异常

### 12.6.1 栈轨迹

### 12.6.2 重新抛出异常

### 12.6.3 异常链

## 12.7 Java标准异常

​	Throwable这个Java类被用来表示任何可以作为异常被抛出的类，Throwable对象可分为两种类型(指从Throwable继承而得到的类型)：Error用来表示编译时和系统错误(除特殊情况外，一般不用关心)；Exception是可以被抛出的基本类型，在Java类库、用户方法以及运行时故障中都可能抛出Exception型异常。所以Java程序员关心的基类型通常是Exception。

### 12.7.1 特例:RuntimeException

​	请务必记住：只能在代码中忽略RuntimeException(及其子类)类型的异常，其他类型异常的处理都是由编译器强制实施的，究其原因，RuntimeException代表的是编程错误。

## 12.8 使用finally进行清理

### 12.8.1 finally用来做什么

### 12.8.2 在return中使用finally

### 12.8.3 遗憾：异常丢失

## 12.9 异常的限制

​	当覆盖方法的时候，只能抛出在其基类方法的异常说明里列出的那些异常。

## 12.10 构造器

## 12.11 异常匹配

​	抛出异常的时候，异常处理系统按照代码的书写顺序找出“最近”的处理程序，找到匹配的处理程序之后，它就认为异常将得到处理，然后就不再继续查找。

## 12.12 其他可选方式

​	异常处理的一个重要原则是"只有在你知道如何处理的情况下才捕获异常"。实际上，异常处理的一个重要目标就是把错误的代码同错误发生的地点相分离。

### 12.12.1 历史

### 12.12.2 观点

​	好的程序设计语言能帮助程序员写出好程序，但无论哪种语言都避免不了程序员用它写出了坏程序。

### 12.12.3 把异常传递给控制台

### 12.12.4 把"被检查的异常"转换为"不检查的异常"

## 12.13 异常使用指南

## 12.14 总结

# 第13章 字符串

## 13.1 不可变String

## 13.2 重载"+"与StringBuilder

## 13.3 无意识的递归

## 13.4 String上的操作

## 13.5 格式化输出

### 13.5.1 printf()

### 13.5.2 System.out.format()

### 13.5.3 Formatter类

### 13.5.4 格式化说明符

### 13.5.5 Formatter转换

### 13.5.6 String.format()

## 13.6 正则表达式

### 13.6.1 基础

### 13.6.2 创建正则表达式

### 13.6.3 量词

​	贪婪型

​	勉强型

​	占有型

### 13.6.4 Pattern和Matcher

### 13.6.5 split()

### 13.6.6 替换操作

### 13.6.7 reset()

### 13.6.8 正则表达式与Java I/O

## 13.7 扫描输入

### 13.7.1 Scanner定界符

### 13.7.2 用正则表达式描述

## 13.8 StringTokenizer

## 13.9 总结

# 第14章 类型信息

## 14.1 为什么需要RTTI

​	RTTI名字的含义：在运行时，识别一个对象的类型。

## 14.2 Class对象

​	事实上，Class对象就是用来创建类的所有的“常规”对象的。类是程序的一部分，每个类都有一个Class对象。

### 14.2.1 类字面常量

​	为了使用类而做的准备工作实际包含三个步骤：加载、链接、初始化。

​	加载：这是由类加载器执行的，该步骤将查找字节码（通常在classpath所指定的路径中查找，但这并非是必需的），并从这些字节码中创建一个Class对象 。

​	链接：在链接阶段将验证类中的字节码，为静态域分配存储空间，并且如果有必需的话，将解析这个类创建的对其他类的所有引用。

​	初始化：如果该类具有超类，则对其初始化，执行静态初始化器和静态初始化块。

### 14.2.2 泛化的Class引用

### 14.2.3 新的转型语法

## 14.3 类型转换前先做检查

### 14.3.1 使用类字面常量

### 14.3.2 动态的instanceof

### 14.3.3 递归计数

## 14.4 注册工厂

## 14.5 instanceof与Class的等价性

## 14.6 反射：运行时的类信息

​	重要的是，要认识到反射机制并没有什么神奇之处。当通过反射与一个未知类型的对象打交道时，JVM只是简单地检查这个对象，看它属于哪个特定的类(就像RTTI那样)。在用它做其他事情之前必须先加载哪个类的Class对象。因此，哪个类的.class文件对于JVM来说必须是可获取的：要么在本地机器上，要么可以通过网络取得。所有RTTI和反射之间真正的区别只在于，对RTTTI来说，编译器在编译时打开和检查.calss文件。(换句话说，我们可以用"普通"方式调用对象的所有方法)而对于反射机制来说，.class文件在编译时是可不获取的，所以是在运行时打开和检查.class文件。

### 14.6.1 类方法提取器

## 14.7 动态代理

## 14.8 空对象

### 14.8.1 模拟对象与桩

## 14.9 接口与类型信息

## 14.10 总结

​	不要太早地关注程序的效率问题，这是个诱人的陷阱，最好首先让程序运作起来，然后再考虑它的速度。

# 第15章 泛型

## 15.1 与C++的比较

## 15.2 简单泛型

​	这就是Java泛型的核心概念：告诉编译器想使用什么类型，然后编译器帮你处理一切细节。

### 15.2.1 一个元组件类库

### 15.2.2 一个堆栈类

### 15.2.3 RandomList

## 15.3 泛型接口

## 15.4 泛型方法

​	以下是一个基本的指导原则：无论何时，只要你能做到，你就应该尽量使用泛型方法，也就是说，如果使用泛型方法可以取代将整个类泛型化，那么就应该只使用泛型方法，因为它可以使事务更清晰明白。另外，对于一个static的方法而言，无法访问泛型类的类型参数，所以，如果static方法需要使用泛型能力，就必须使其成为泛型方法。

### 15.4.1 杠杆利用类型参数推断

### 15.4.2 可变参数与泛型方法

### 15.4.3 利用Generator的泛型方法

### 15.4.4 一个通用的Generator

### 15.4.5 简化元组的使用

### 15.4.6  一个Set实用工具

## 15.5 匿名内部类

## 15.6 构建复杂模型

## 15.7 擦除的神秘之处

​	在泛型代码内部，无法获得任何有关泛型参数类型的信息。

​	Java泛型是使用擦除来实现的，这意味着当你在使用泛型时，任何具体的类型信息都被擦出了，你唯一知道的就是你在使用一个对象。

### 15.7.1 C++的方式

### 15.7.2 迁移兼容性

​	泛型类型只有在静态类型检查期间才出现，在此之后，程序中的所有泛型类型都将被擦除，替换为它们的非泛型上界。例如，诸如List<T>这样的类型注解将被擦除为List，而普通的类型变量在未指定边界的情况下将被擦除为Object。

​	因此Java泛型不仅必须支持向后兼容性，即现有的代码和类文件仍旧合法，并且继续保持其之前的含义，而且还要支持迁移兼容性，使得类库按照它们自己的步调变成泛型的，并且当某个类库变成泛型时，不会破坏依赖于它的代码和应用程序。在决定这就是目标之后，Java设计者们和从事此问题相关工作的各个团队决策认为擦除是唯一可行的解决方法。通过允许非泛型代码与泛型代码共存，擦除使得这种向着泛型的迁移成为可能。

### 15.7.3 擦除的问题

​	事实并非如此，无论何时，当你在编写这个类的代码时，必须提醒自己：不，它只是一个Object。

### 15.7.4 边界处的动作

## 15.8 擦除的补偿

### 15.8.1 创建类型实例

### 15.8.2 泛型数组

## 15.9 边界

## 15.10 通配符

### 15.10.1 编译器有多聪明

### 15.10.2 逆变

​	超类型通配符：<? super T>

### 15.10.3 无界通配符

​	无界通配符<?>

​	List实际上表示“持有任何Object类型的原生List”，而List<?>表示“具有某种特定类型的非原生List，只是我们不知道那种类型是什么。“

### 15.10.4 捕获转换

## 15.11 问题

### 15.11.1 任何基本类型都不能作为类型参数

​	解决之道是使用基本类型的包装器类以及Java SE 5的自动包装机制。

### 15.11.2 实现参数化接口

### 15.11.3 转型和警告

### 15.11.4 重载

### 15.11.5 基类劫持了接口

## 15.12 自限定的类型

### 15.12.1 古怪的循环泛型

### 15.12.2 自限定

### 15.12.3 参数协变

## 15.13 动态类型安全

## 15.14 异常

## 15.15 混型

​	混型的价值之一是它们可以将特性和行为一致地应用于多个类之上。

### 15.15.1 C++的混型

### 15.15.2 与接口混合

### 15.15.3 使用装饰器模式

## 15.16 潜在类型机制

​	潜在的类型机制是一种代码组织和复用机制。

## 15.17 对缺乏潜在类型机制的补偿

### 15.17.1 反射

### 15.17.2 将一个方法应用于序列

### 15.17.3 当你并未碰巧拥有正确的接口时

### 15.17.4 用适配器仿真潜在类型机制

## 15.18 将函数对象用作策略

## 15.19 总结：转型真的如次之糟吗？

# 第16章数组

## 16.1 数组为什么特殊

​	数组域其他种类的容器之间的区别有三方面：效率、类型和保存基本类型的能力。在Java中，数组是一种效率最高的存储和随机访问对象引用序列的方式。

## 16.2 数组是第一级对象

​	无论使用哪种类型的数组，数组标识符其实只是一个引用，指向在堆中创建的一个真实对象，这个对象用以保存指向其他对象的引用。

## 16.3 返回一个数组

## 16.4 多维数组

## 16.5 数组与泛型

## 16.6 创建测试数据

### 16.6.1 Arrays.fill()

### 16.6.2 数据生成器

### 16.6.3 从Generator中创建数组

## 16.7 Arrays实用功能

### 16.7.1 复制数组

### 16.7.2 数组的比较

### 16.7.3 数组元素的比较

### 16.7.4 数组排序

### 16.7.5 在已排序的数组中查找

## 16.8 总结

# 第17章 容器深入研究

## 17.1 完整的容器分类法

![](images\微信截图_20200419110912.png)

## 17.2 填充容器

### 17.2.1 一种Generator解决方案

### 17.2.2 Map生成器

### 17.2.3 使用Abstract类

## 17.3 Collection的功能方法

## 17.4 可选操作

### 17.4.1 未获支持的操作

## 17.5 List的功能方法

## 17.6 Set和存储顺序

### 17.6.1 SortedSet

## 17.7 队列

### 17.7.1 优先级队列

### 17.7.2 双相队列

## 17.8 理解Map

### 17.8.1 性能	

对Map中使用的键的要求与对Set中的元素的要求一样，任何键都必须具有一个equals()方法，如果键被用于散列Map，那么它必须还具有恰当的HasCode()方法，如果键被用于TreeMap，那么它必须实现Comparable。

### 17.8.2 SortedMap

### 17.8.3 LinkedHashMap

## 17.9 散列与散列码

​	正确的equals()方法必须满足下列5个条件：自反性、对称性、传递性、一致性、对任何不适null的x，x.equals(null)一定返回false。

### 17.9.1 理解hashCode()

### 17.9.2 为速度而散列

### 17.9.3 覆盖hashCode()

​	bucket数组的下标值是无法控制的，这个值依赖于具体的HashMap对象的容器，而容器的改变与容器的充满程度和负载因子有关，hashCode生成的结果，经过处理后成为桶位的下标。

## 17.10 选择接口的不同实现

### 17.10.1 性能测试框架

### 17.10.2 对List的选择

### 17.10.3 微基准测试的危险

### 17.10.4 对Set的选择

​	HashSet的性能基本上总是比TreeSet好，特别是在添加和查询元素时，而这两个操作也是最重要的操作，TreeSet存在的唯一原因是它可以维持元素的排序状态，所以，只有当需要一个排序好的Set时，才应该使用TreeSet。因为其内部结构支持排序，并且因为跌该是我们更可能执行的操作，所以，用TreeSet迭代通常比HashSet更快。

​	对于插入操作，LiinkedHashSet比HashSet的代价更高，这是由维护链表所带来额外开销造成的。

### 17.10.5 对Map的选择

## 17.11 实用方法

### 17.1 List的排序和查询

### 17.11.3 Collection或Map的同步控制

​	Java容器类类库采用快速报错(fial-fast)机制。它会探查容器上的任何除了你的进城进行的操作以外的所有变化，一旦它发现其他进程修改了ring器，就会立刻抛出ConcurrentModificationException异常。这就是“快速报错”的意思，即不是使用复杂的算法在事后来检查问题。

## 17.12 持有引用

### 17.12.1 WeakHashMap

## 17.13 Java1.0/1.1的容器

### 17.13.1 Vector和Enumeration

### 17.13.2 HashTable

### 17.13.3 Stack

### 17.13.4 BitSet

## 17.14 总结

# 第18章 Java I/O系统

## 18.1 FIle类

​	File（文件）类这个名字有一定的误导性，它既能代表一个特定文件的名字，又能代表一个目录下的一组文件的名字。

### 18.1.1 目录列表器

### 18.1.2 目录实用工具

### 18.1.3 目录的检查及创建

## 18.2 输入和输出

### 18.2.1 InputStream类型

### 18.2.2 OutputStream类型

## 18.3 添加属性和有用的接口

### 18.3.1 通过FilterInputStream从InputStream读取数据

### 18.3.2 通过FilterOutPutStream向OutputStrean写入

## 18.4 Reader和Writer

​	设计Reader和Writer继承层次结构主要是为了国际化。

### 18.4.1 数据的来源和去处

### 18.4.2 更改流的行为

### 18.4.3 未发生变化的类

## 18.5 自我独立的类：RandomAccessFile

## 18.6 I/O流的典型使用方式

### 18.6.1 缓冲输入方式

### 18.6.2 从内存输入

### 18.6.3 格式化的内存输入

### 18.6.4 基本的文件输出

### 18.6.5 存储和恢复数据

### 18.6.6 读写随机访问文件

### 18.6.7 管道流

## 18.7 文件读写的实用工具

### 18.7.1 读取二进制文件

## 18.8 标准I/O

### 18.8.1 从标准输入中读取

### 18.8.2 将System.out转换成PrintWriter

### 18.8.3 标准I/O重定向

## 18.9 进程控制

## 18.10 新I/O

### 18.10.1 转换数据

### 18.10.2 获取基本类型

### 18.10.3 视图缓冲器

### 18.10.4 用缓冲操纵数据

### 18.10.5 缓冲器的细节

### 18.10.6 内存映射文件

### 18.10.7 文件加锁

## 18.11 压缩

### 18.11.1 用GZIP进行简单压缩

### 18.11.2 用Zip进行多文件保存

### 18.11.3 Java档案文件

## 18.12 对象序列化

​	对象序列化的概念加入到语言中是为了支持两种主要特性，一是Java的远程方法调用（RMI），它使存活于其他计算机上的对象使用起来就像是存活于本机上以西洋；再者，对Java Beans来说，对象的序列化也是必须的。

### 18.12.1 寻找类

### 18.12.12 序列化的控制

​	transient(瞬时)关键字，可以用transient关键字逐个字段地关闭序列化。

### 18.12.13 使用"持久化"

## 18.13 XML

## 18.14 Preperences

## 18.15 总结

# 第19章 枚举类型

## 19.1 基本enum特性

## 19.2 向enum中添加新方法

### 19.2.1 覆盖enum的方法

## 19.3 switch语句中的enum

## 19.4 values()的神秘之处

​	values()是由编译器添加的static方法。

## 19.5 实现，而非继承

## 19.6 随机选取

## 19.7 使用接口组织枚举

​	对于enum而言，实现接口是使其子类化的唯一办法。

## 19.8使用EnumSet代替标志

## 19.9 使用EnumMap

## 19.10 常量相关的方法

### 19.10.1 使用enum责任链

​	在责任链(Chain of Responsibility)设计模式中，程序员以多种不同的方式来解决一个问题，然后将它们链接在一起，当一个请求到来时，它遍历这个链，直到链中的某个解决方案能够处理该请求。

